// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * itertools/module.go: transpiled from itertools.py
 */

package itertools

import (
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ϒchain λ.Object
	ϒcount λ.Object
)

func init() {
	λ.InitModule(func() {
		ϒchain = λ.Cal(λ.TypeType, λ.NewStr("chain"), λ.NewTuple(), func() λ.Dict {
			var (
				ϒchain___init__ λ.Object
				ϒchain___iter__ λ.Object
				ϒchain___next__ λ.Object
			)
			ϒchain___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒiterables = λargs[1]
						ϒself      = λargs[0]
					)
					λ.SetAttr(ϒself, "iterables", λ.Cal(λ.BuiltinIter, func() λ.Object {
						if λv := ϒiterables; λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList(λ.NewList())
						}
					}()))
					λ.SetAttr(ϒself, "iterable", λ.Cal(λ.BuiltinIter, λ.Cal(λ.BuiltinNext, λ.GetAttr(ϒself, "iterables", nil))))
					return λ.None
				})
			ϒchain___iter__ = λ.NewFunction("__iter__",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					return ϒself
				})
			ϒchain___next__ = λ.NewFunction("__next__",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
						τmp0  λ.Object
						τmp1  λ.Object
					)
					for λ.IsTrue(λ.True) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.StopIterationType, func(λex λ.BaseException) {
									λ.SetAttr(ϒself, "iterable", λ.Cal(λ.BuiltinIter, λ.Cal(λ.BuiltinNext, λ.GetAttr(ϒself, "iterables", nil))))
								}},
							)
							λexit, λret = λ.BlockExitReturn, λ.Cal(λ.BuiltinNext, λ.GetAttr(ϒself, "iterable", nil))
							return
							return λ.BlockExitNormally, nil
						}()
						if τmp0 == λ.BlockExitReturn {
							return τmp1
						}
					}
					return λ.None
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"): ϒchain___init__,
				λ.NewStr("__iter__"): ϒchain___iter__,
				λ.NewStr("__next__"): ϒchain___next__,
			})
		}())
		ϒcount = λ.NewFunction("count",
			[]λ.Param{
				{Name: "start", Def: λ.NewInt(0)},
				{Name: "step", Def: λ.NewInt(1)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
					var (
						ϒn     λ.Object
						ϒstart = λargs[0]
						ϒstep  = λargs[1]
						τmp0   λ.Object
					)
					ϒn = ϒstart
					for λ.IsTrue(λ.True) {
						λgy.Yield(ϒn)
						τmp0 = λ.IAdd(ϒn, ϒstep)
						ϒn = τmp0
					}
					return λ.None
				})
			})
	})
}

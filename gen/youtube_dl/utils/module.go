// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * utils/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/utils.py
 */

package utils

import (
	Ωcodecs "github.com/tenta-browser/go-video-downloader/gen/codecs"
	Ωentities "github.com/tenta-browser/go-video-downloader/gen/html/entities"
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωsys "github.com/tenta-browser/go-video-downloader/gen/sys"
	Ωerror "github.com/tenta-browser/go-video-downloader/gen/urllib/error"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωrequest "github.com/tenta-browser/go-video-downloader/gen/urllib/request"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωnet "github.com/tenta-browser/go-video-downloader/lib/net"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	DATE_FORMATS                      λ.Object
	DATE_FORMATS_DAY_FIRST            λ.Object
	DATE_FORMATS_MONTH_FIRST          λ.Object
	DEFAULT_OUTTMPL                   λ.Object
	DownloadError                     λ.Object
	ENGLISH_MONTH_NAMES               λ.Object
	ExtractorError                    λ.Object
	GeoRestrictedError                λ.Object
	GeoUtils                          λ.Object
	HEADRequest                       λ.Object
	HTMLAttributeParser               λ.Object
	ISO639Utils                       λ.Object
	JSON_LD_RE                        λ.Object
	KNOWN_EXTENSIONS                  λ.Object
	MONTH_NAMES                       λ.Object
	MaxDownloadsReached               λ.Object
	NO_DEFAULT                        λ.Object
	PagedList                         λ.Object
	PostProcessingError               λ.Object
	RegexNotFoundError                λ.Object
	TV_PARENTAL_GUIDELINES            λ.Object
	US_RATINGS                        λ.Object
	UnavailableVideoError             λ.Object
	YoutubeDLError                    λ.Object
	ϒ_htmlentity_transform            λ.Object
	ϒbase_url                         λ.Object
	ϒbug_reports_message              λ.Object
	ϒclean_html                       λ.Object
	ϒcompat_HTMLParseError            λ.Object
	ϒcompat_HTMLParser                λ.Object
	ϒcompat_basestring                λ.Object
	ϒcompat_chr                       λ.Object
	ϒcompat_etree_fromstring          λ.Object
	ϒcompat_html_entities_html5       λ.Object
	ϒcompat_http_client               λ.Object
	ϒcompat_kwargs                    λ.Object
	ϒcompat_parse_qs                  λ.Object
	ϒcompat_str                       λ.Object
	ϒcompat_urllib_parse_unquote_plus λ.Object
	ϒcompat_urllib_parse_urlencode    λ.Object
	ϒcompat_urllib_parse_urlparse     λ.Object
	ϒcompat_xpath                     λ.Object
	ϒcompiled_regex_type              λ.Object
	ϒdetermine_ext                    λ.Object
	ϒdetermine_protocol               λ.Object
	ϒdict_get                         λ.Object
	ϒencode_base_n                    λ.Object
	ϒerror_to_compat_str              λ.Object
	ϒexpand_path                      λ.Object
	ϒextract_attributes               λ.Object
	ϒfind_xpath_attr                  λ.Object
	ϒfix_xml_ampersands               λ.Object
	ϒfloat_or_none                    λ.Object
	ϒget_element_by_attribute         λ.Object
	ϒget_element_by_class             λ.Object
	ϒget_element_by_id                λ.Object
	ϒget_elements_by_attribute        λ.Object
	ϒget_elements_by_class            λ.Object
	ϒint_or_none                      λ.Object
	ϒjs_to_json                       λ.Object
	ϒlimit_length                     λ.Object
	ϒlookup_unit_table                λ.Object
	ϒlowercase_escape                 λ.Object
	ϒmerge_dicts                      λ.Object
	ϒmimetype2ext                     λ.Object
	ϒmonth_by_name                    λ.Object
	ϒorderedSet                       λ.Object
	ϒparse_age_limit                  λ.Object
	ϒparse_bitrate                    λ.Object
	ϒparse_codecs                     λ.Object
	ϒparse_count                      λ.Object
	ϒparse_duration                   λ.Object
	ϒparse_filesize                   λ.Object
	ϒparse_iso8601                    λ.Object
	ϒparse_m3u8_attributes            λ.Object
	ϒparse_resolution                 λ.Object
	ϒpreferredencoding                λ.Object
	ϒqualities                        λ.Object
	ϒrandom_birthday                  λ.Object
	ϒremove_end                       λ.Object
	ϒremove_quotes                    λ.Object
	ϒremove_start                     λ.Object
	ϒsanitize_filename                λ.Object
	ϒsanitize_path                    λ.Object
	ϒsanitize_url                     λ.Object
	ϒsanitized_Request                λ.Object
	ϒsmuggle_url                      λ.Object
	ϒstd_headers                      λ.Object
	ϒstr_or_none                      λ.Object
	ϒstr_to_int                       λ.Object
	ϒstrip_jsonp                      λ.Object
	ϒstrip_or_none                    λ.Object
	ϒtry_get                          λ.Object
	ϒunescapeHTML                     λ.Object
	ϒunified_strdate                  λ.Object
	ϒunified_timestamp                λ.Object
	ϒunsmuggle_url                    λ.Object
	ϒupdate_Request                   λ.Object
	ϒupdate_url_query                 λ.Object
	ϒuppercase_escape                 λ.Object
	ϒurl_basename                     λ.Object
	ϒurl_or_none                      λ.Object
	ϒurlencode_postdata               λ.Object
	ϒurljoin                          λ.Object
	ϒxpath_attr                       λ.Object
	ϒxpath_element                    λ.Object
	ϒxpath_text                       λ.Object
	ϒxpath_with_ns                    λ.Object
	ϒytdl_is_updateable               λ.Object
	τmp0                              λ.Object
	τmp1                              λ.Object
)

func init() {
	λ.InitModule(func() {
		ϒcompat_HTMLParseError = Ωcompat.ϒcompat_HTMLParseError
		ϒcompat_HTMLParser = Ωcompat.ϒcompat_HTMLParser
		ϒcompat_basestring = Ωcompat.ϒcompat_basestring
		ϒcompat_chr = Ωcompat.ϒcompat_chr
		ϒcompat_etree_fromstring = Ωcompat.ϒcompat_etree_fromstring
		ϒcompat_html_entities_html5 = Ωcompat.ϒcompat_html_entities_html5
		ϒcompat_http_client = Ωcompat.ϒcompat_http_client
		ϒcompat_kwargs = Ωcompat.ϒcompat_kwargs
		ϒcompat_parse_qs = Ωcompat.ϒcompat_parse_qs
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒcompat_urllib_parse_urlencode = Ωcompat.ϒcompat_urllib_parse_urlencode
		ϒcompat_urllib_parse_urlparse = Ωcompat.ϒcompat_urllib_parse_urlparse
		ϒcompat_urllib_parse_unquote_plus = Ωcompat.ϒcompat_urllib_parse_unquote_plus
		ϒcompat_xpath = Ωcompat.ϒcompat_xpath
		ϒcompiled_regex_type = λ.Cal(λ.TypeType, λ.Cal(Ωre.ϒcompile, λ.NewStr("")))
		ϒstd_headers = λ.NewDictWithTable(map[λ.Object]λ.Object{
			λ.NewStr("User-Agent"):      λ.NewStr("Mozilla/5.0 (X11; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0"),
			λ.NewStr("Accept-Charset"):  λ.NewStr("ISO-8859-1,utf-8;q=0.7,*;q=0.7"),
			λ.NewStr("Accept"):          λ.NewStr("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"),
			λ.NewStr("Accept-Encoding"): λ.NewStr("gzip, deflate"),
			λ.NewStr("Accept-Language"): λ.NewStr("en-us,en;q=0.5"),
		})
		NO_DEFAULT = λ.Cal(λ.ObjectType)
		ENGLISH_MONTH_NAMES = λ.NewList(
			λ.NewStr("January"),
			λ.NewStr("February"),
			λ.NewStr("March"),
			λ.NewStr("April"),
			λ.NewStr("May"),
			λ.NewStr("June"),
			λ.NewStr("July"),
			λ.NewStr("August"),
			λ.NewStr("September"),
			λ.NewStr("October"),
			λ.NewStr("November"),
			λ.NewStr("December"),
		)
		MONTH_NAMES = λ.NewDictWithTable(map[λ.Object]λ.Object{
			λ.NewStr("en"): ENGLISH_MONTH_NAMES,
			λ.NewStr("fr"): λ.NewList(
				λ.NewStr("janvier"),
				λ.NewStr("février"),
				λ.NewStr("mars"),
				λ.NewStr("avril"),
				λ.NewStr("mai"),
				λ.NewStr("juin"),
				λ.NewStr("juillet"),
				λ.NewStr("août"),
				λ.NewStr("septembre"),
				λ.NewStr("octobre"),
				λ.NewStr("novembre"),
				λ.NewStr("décembre"),
			),
		})
		KNOWN_EXTENSIONS = λ.NewTuple(
			λ.NewStr("mp4"),
			λ.NewStr("m4a"),
			λ.NewStr("m4p"),
			λ.NewStr("m4b"),
			λ.NewStr("m4r"),
			λ.NewStr("m4v"),
			λ.NewStr("aac"),
			λ.NewStr("flv"),
			λ.NewStr("f4v"),
			λ.NewStr("f4a"),
			λ.NewStr("f4b"),
			λ.NewStr("webm"),
			λ.NewStr("ogg"),
			λ.NewStr("ogv"),
			λ.NewStr("oga"),
			λ.NewStr("ogx"),
			λ.NewStr("spx"),
			λ.NewStr("opus"),
			λ.NewStr("mkv"),
			λ.NewStr("mka"),
			λ.NewStr("mk3d"),
			λ.NewStr("avi"),
			λ.NewStr("divx"),
			λ.NewStr("mov"),
			λ.NewStr("asf"),
			λ.NewStr("wmv"),
			λ.NewStr("wma"),
			λ.NewStr("3gp"),
			λ.NewStr("3g2"),
			λ.NewStr("mp3"),
			λ.NewStr("flac"),
			λ.NewStr("ape"),
			λ.NewStr("wav"),
			λ.NewStr("f4f"),
			λ.NewStr("f4m"),
			λ.NewStr("m3u8"),
			λ.NewStr("smil"),
		)
		DATE_FORMATS = λ.NewTuple(
			λ.NewStr("%d %B %Y"),
			λ.NewStr("%d %b %Y"),
			λ.NewStr("%B %d %Y"),
			λ.NewStr("%B %dst %Y"),
			λ.NewStr("%B %dnd %Y"),
			λ.NewStr("%B %dth %Y"),
			λ.NewStr("%b %d %Y"),
			λ.NewStr("%b %dst %Y"),
			λ.NewStr("%b %dnd %Y"),
			λ.NewStr("%b %dth %Y"),
			λ.NewStr("%b %dst %Y %I:%M"),
			λ.NewStr("%b %dnd %Y %I:%M"),
			λ.NewStr("%b %dth %Y %I:%M"),
			λ.NewStr("%Y %m %d"),
			λ.NewStr("%Y-%m-%d"),
			λ.NewStr("%Y/%m/%d"),
			λ.NewStr("%Y/%m/%d %H:%M"),
			λ.NewStr("%Y/%m/%d %H:%M:%S"),
			λ.NewStr("%Y-%m-%d %H:%M"),
			λ.NewStr("%Y-%m-%d %H:%M:%S"),
			λ.NewStr("%Y-%m-%d %H:%M:%S.%f"),
			λ.NewStr("%d.%m.%Y %H:%M"),
			λ.NewStr("%d.%m.%Y %H.%M"),
			λ.NewStr("%Y-%m-%dT%H:%M:%SZ"),
			λ.NewStr("%Y-%m-%dT%H:%M:%S.%fZ"),
			λ.NewStr("%Y-%m-%dT%H:%M:%S.%f0Z"),
			λ.NewStr("%Y-%m-%dT%H:%M:%S"),
			λ.NewStr("%Y-%m-%dT%H:%M:%S.%f"),
			λ.NewStr("%Y-%m-%dT%H:%M"),
			λ.NewStr("%b %d %Y at %H:%M"),
			λ.NewStr("%b %d %Y at %H:%M:%S"),
			λ.NewStr("%B %d %Y at %H:%M"),
			λ.NewStr("%B %d %Y at %H:%M:%S"),
		)
		DATE_FORMATS_DAY_FIRST = λ.Cal(λ.ListType, DATE_FORMATS)
		λ.Cal(λ.GetAttr(DATE_FORMATS_DAY_FIRST, "extend", nil), λ.NewList(
			λ.NewStr("%d-%m-%Y"),
			λ.NewStr("%d.%m.%Y"),
			λ.NewStr("%d.%m.%y"),
			λ.NewStr("%d/%m/%Y"),
			λ.NewStr("%d/%m/%y"),
			λ.NewStr("%d/%m/%Y %H:%M:%S"),
		))
		DATE_FORMATS_MONTH_FIRST = λ.Cal(λ.ListType, DATE_FORMATS)
		λ.Cal(λ.GetAttr(DATE_FORMATS_MONTH_FIRST, "extend", nil), λ.NewList(
			λ.NewStr("%m-%d-%Y"),
			λ.NewStr("%m.%d.%Y"),
			λ.NewStr("%m/%d/%Y"),
			λ.NewStr("%m/%d/%y"),
			λ.NewStr("%m/%d/%Y %H:%M:%S"),
		))
		JSON_LD_RE = λ.NewStr("(?is)<script[^>]+type=([\"\\']?)application/ld\\+json\\1[^>]*>(?P<json_ld>.+?)</script>")
		ϒpreferredencoding = λ.NewFunction("preferredencoding",
			nil,
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒpref λ.Object
					τmp0  λ.Object
					τmp1  λ.Object
				)
				_ = τmp0
				_ = τmp1
				λ.NewStr("Get preferred encoding.\n\n    Returns the best encoding scheme for the system, based on\n    locale.getpreferredencoding() and some further tweaks.\n    ")
				τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
					defer λ.CatchMulti(
						nil,
						&λ.Catcher{λ.ExceptionType, func(λex λ.BaseException) {
							ϒpref = λ.NewStr("UTF-8")
						}},
					)
					ϒpref = λ.Cal(λ.GetAttr(λ.None, "getpreferredencoding", nil))
					λ.Cal(λ.GetAttr(λ.NewStr("TEST"), "encode", nil), ϒpref)
					return λ.BlockExitNormally, nil
				}()
				return ϒpref
			})
		if λ.IsTrue(λ.Ge(Ωsys.ϒversion_info, λ.NewTuple(
			λ.NewInt(2),
			λ.NewInt(7),
		))) {
			ϒfind_xpath_attr = λ.NewFunction("find_xpath_attr",
				[]λ.Param{
					{Name: "node"},
					{Name: "xpath"},
					{Name: "key"},
					{Name: "val", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒexpr  λ.Object
						ϒkey   = λargs[2]
						ϒnode  = λargs[0]
						ϒval   = λargs[3]
						ϒxpath = λargs[1]
					)
					λ.NewStr(" Find the xpath xpath[@key=val] ")
					if !λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^[a-zA-Z_-]+$"), ϒkey)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					ϒexpr = λ.Add(ϒxpath, func() λ.Object {
						if λ.IsTrue(λ.NewBool(ϒval == λ.None)) {
							return λ.Mod(λ.NewStr("[@%s]"), ϒkey)
						} else {
							return λ.Mod(λ.NewStr("[@%s='%s']"), λ.NewTuple(
								ϒkey,
								ϒval,
							))
						}
					}())
					return λ.Cal(λ.GetAttr(ϒnode, "find", nil), ϒexpr)
				})
		} else {
			ϒfind_xpath_attr = λ.NewFunction("find_xpath_attr",
				[]λ.Param{
					{Name: "node"},
					{Name: "xpath"},
					{Name: "key"},
					{Name: "val", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf     λ.Object
						ϒkey   = λargs[2]
						ϒnode  = λargs[0]
						ϒval   = λargs[3]
						ϒxpath = λargs[1]
						τmp0   λ.Object
						τmp1   λ.Object
					)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒnode, "findall", nil), λ.Cal(ϒcompat_xpath, ϒxpath)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒf = τmp1
						if λ.IsTrue(λ.NewBool(!λ.Contains(λ.GetAttr(ϒf, "attrib", nil), ϒkey))) {
							continue
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒval == λ.None); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(λ.Cal(λ.GetAttr(λ.GetAttr(ϒf, "attrib", nil), "get", nil), ϒkey), ϒval)
							}
						}()) {
							return ϒf
						}
					}
					return λ.None
				})
		}
		ϒxpath_with_ns = λ.NewFunction("xpath_with_ns",
			[]λ.Param{
				{Name: "path"},
				{Name: "ns_map"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒc          λ.Object
					ϒcomponents λ.Object
					ϒns         λ.Object
					ϒns_map     = λargs[1]
					ϒpath       = λargs[0]
					ϒreplaced   λ.Object
					ϒtag        λ.Object
					τmp0        λ.Object
					τmp1        λ.Object
					τmp2        λ.Object
				)
				ϒcomponents = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
					nil,
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
							var (
								ϒc   λ.Object
								τmp0 λ.Object
								τmp1 λ.Object
							)
							τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒpath, "split", nil), λ.NewStr("/")))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒc = τmp1
								λgy.Yield(λ.Cal(λ.GetAttr(ϒc, "split", nil), λ.NewStr(":")))
							}
							return λ.None
						})
					})))
				ϒreplaced = λ.NewList()
				τmp0 = λ.Cal(λ.BuiltinIter, ϒcomponents)
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒc = τmp1
					if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒc), λ.NewInt(1))) {
						λ.Cal(λ.GetAttr(ϒreplaced, "append", nil), λ.GetItem(ϒc, λ.NewInt(0)))
					} else {
						τmp2 = ϒc
						ϒns = λ.GetItem(τmp2, λ.NewInt(0))
						ϒtag = λ.GetItem(τmp2, λ.NewInt(1))
						λ.Cal(λ.GetAttr(ϒreplaced, "append", nil), λ.Mod(λ.NewStr("{%s}%s"), λ.NewTuple(
							λ.GetItem(ϒns_map, ϒns),
							ϒtag,
						)))
					}
				}
				return λ.Cal(λ.GetAttr(λ.NewStr("/"), "join", nil), ϒreplaced)
			})
		ϒxpath_element = λ.NewFunction("xpath_element",
			[]λ.Param{
				{Name: "node"},
				{Name: "xpath"},
				{Name: "name", Def: λ.None},
				{Name: "fatal", Def: λ.False},
				{Name: "default", Def: NO_DEFAULT},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒ_find_xpath λ.Object
					ϒdefault     = λargs[4]
					ϒfatal       = λargs[3]
					ϒn           λ.Object
					ϒname        = λargs[2]
					ϒnode        = λargs[0]
					ϒxp          λ.Object
					ϒxpath       = λargs[1]
					τmp0         λ.Object
					τmp1         λ.Object
				)
				ϒ_find_xpath = λ.NewFunction("_find_xpath",
					[]λ.Param{
						{Name: "xpath"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒxpath = λargs[0]
						)
						return λ.Cal(λ.GetAttr(ϒnode, "find", nil), λ.Cal(ϒcompat_xpath, ϒxpath))
					})
				if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒxpath, λ.NewTuple(
					λ.StrType,
					ϒcompat_str,
				))) {
					ϒn = λ.Cal(ϒ_find_xpath, ϒxpath)
				} else {
					τmp0 = λ.Cal(λ.BuiltinIter, ϒxpath)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒxp = τmp1
						ϒn = λ.Cal(ϒ_find_xpath, ϒxp)
						if λ.IsTrue(λ.NewBool(ϒn != λ.None)) {
							break
						}
					}
				}
				if λ.IsTrue(λ.NewBool(ϒn == λ.None)) {
					if λ.IsTrue(λ.NewBool(ϒdefault != NO_DEFAULT)) {
						return ϒdefault
					} else {
						if λ.IsTrue(ϒfatal) {
							ϒname = func() λ.Object {
								if λ.IsTrue(λ.NewBool(ϒname == λ.None)) {
									return ϒxpath
								} else {
									return ϒname
								}
							}()
							panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.NewStr("Could not find XML element %s"), ϒname))))
						} else {
							return λ.None
						}
					}
				}
				return ϒn
			})
		ϒxpath_text = λ.NewFunction("xpath_text",
			[]λ.Param{
				{Name: "node"},
				{Name: "xpath"},
				{Name: "name", Def: λ.None},
				{Name: "fatal", Def: λ.False},
				{Name: "default", Def: NO_DEFAULT},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault = λargs[4]
					ϒfatal   = λargs[3]
					ϒn       λ.Object
					ϒname    = λargs[2]
					ϒnode    = λargs[0]
					ϒxpath   = λargs[1]
				)
				ϒn = λ.Call(ϒxpath_element, λ.NewArgs(
					ϒnode,
					ϒxpath,
					ϒname,
				), λ.KWArgs{
					{Name: "fatal", Value: ϒfatal},
					{Name: "default", Value: ϒdefault},
				})
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(ϒn == λ.None); λ.IsTrue(λv) {
						return λv
					} else {
						return λ.Eq(ϒn, ϒdefault)
					}
				}()) {
					return ϒn
				}
				if λ.IsTrue(λ.NewBool(λ.GetAttr(ϒn, "text", nil) == λ.None)) {
					if λ.IsTrue(λ.NewBool(ϒdefault != NO_DEFAULT)) {
						return ϒdefault
					} else {
						if λ.IsTrue(ϒfatal) {
							ϒname = func() λ.Object {
								if λ.IsTrue(λ.NewBool(ϒname == λ.None)) {
									return ϒxpath
								} else {
									return ϒname
								}
							}()
							panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.NewStr("Could not find XML element's text %s"), ϒname))))
						} else {
							return λ.None
						}
					}
				}
				return λ.GetAttr(ϒn, "text", nil)
			})
		ϒxpath_attr = λ.NewFunction("xpath_attr",
			[]λ.Param{
				{Name: "node"},
				{Name: "xpath"},
				{Name: "key"},
				{Name: "name", Def: λ.None},
				{Name: "fatal", Def: λ.False},
				{Name: "default", Def: NO_DEFAULT},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault = λargs[5]
					ϒfatal   = λargs[4]
					ϒkey     = λargs[2]
					ϒn       λ.Object
					ϒname    = λargs[3]
					ϒnode    = λargs[0]
					ϒxpath   = λargs[1]
				)
				ϒn = λ.Cal(ϒfind_xpath_attr, ϒnode, ϒxpath, ϒkey)
				if λ.IsTrue(λ.NewBool(ϒn == λ.None)) {
					if λ.IsTrue(λ.NewBool(ϒdefault != NO_DEFAULT)) {
						return ϒdefault
					} else {
						if λ.IsTrue(ϒfatal) {
							ϒname = func() λ.Object {
								if λ.IsTrue(λ.NewBool(ϒname == λ.None)) {
									return λ.Mod(λ.NewStr("%s[@%s]"), λ.NewTuple(
										ϒxpath,
										ϒkey,
									))
								} else {
									return ϒname
								}
							}()
							panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.NewStr("Could not find XML attribute %s"), ϒname))))
						} else {
							return λ.None
						}
					}
				}
				return λ.GetItem(λ.GetAttr(ϒn, "attrib", nil), ϒkey)
			})
		ϒget_element_by_id = λ.NewFunction("get_element_by_id",
			[]λ.Param{
				{Name: "id"},
				{Name: "html"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒhtml = λargs[1]
					ϒid   = λargs[0]
				)
				λ.NewStr("Return the content of the tag with the specified ID in the passed HTML document")
				return λ.Cal(ϒget_element_by_attribute, λ.NewStr("id"), ϒid, ϒhtml)
			})
		ϒget_element_by_class = λ.NewFunction("get_element_by_class",
			[]λ.Param{
				{Name: "class_name"},
				{Name: "html"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒclass_name = λargs[0]
					ϒhtml       = λargs[1]
					ϒretval     λ.Object
				)
				λ.NewStr("Return the content of the first tag with the specified class in the passed HTML document")
				ϒretval = λ.Cal(ϒget_elements_by_class, ϒclass_name, ϒhtml)
				return func() λ.Object {
					if λ.IsTrue(ϒretval) {
						return λ.GetItem(ϒretval, λ.NewInt(0))
					} else {
						return λ.None
					}
				}()
			})
		ϒget_element_by_attribute = λ.NewFunction("get_element_by_attribute",
			[]λ.Param{
				{Name: "attribute"},
				{Name: "value"},
				{Name: "html"},
				{Name: "escape_value", Def: λ.True},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒattribute    = λargs[0]
					ϒescape_value = λargs[3]
					ϒhtml         = λargs[2]
					ϒretval       λ.Object
					ϒvalue        = λargs[1]
				)
				ϒretval = λ.Cal(ϒget_elements_by_attribute, ϒattribute, ϒvalue, ϒhtml, ϒescape_value)
				return func() λ.Object {
					if λ.IsTrue(ϒretval) {
						return λ.GetItem(ϒretval, λ.NewInt(0))
					} else {
						return λ.None
					}
				}()
			})
		ϒget_elements_by_class = λ.NewFunction("get_elements_by_class",
			[]λ.Param{
				{Name: "class_name"},
				{Name: "html"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒclass_name = λargs[0]
					ϒhtml       = λargs[1]
				)
				λ.NewStr("Return the content of all tags with the specified class in the passed HTML document as a list")
				return λ.Call(ϒget_elements_by_attribute, λ.NewArgs(
					λ.NewStr("class"),
					λ.Mod(λ.NewStr("[^\\'\"]*\\b%s\\b[^\\'\"]*"), λ.Cal(Ωre.ϒescape, ϒclass_name)),
					ϒhtml,
				), λ.KWArgs{
					{Name: "escape_value", Value: λ.False},
				})
			})
		ϒget_elements_by_attribute = λ.NewFunction("get_elements_by_attribute",
			[]λ.Param{
				{Name: "attribute"},
				{Name: "value"},
				{Name: "html"},
				{Name: "escape_value", Def: λ.True},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒattribute    = λargs[0]
					ϒescape_value = λargs[3]
					ϒhtml         = λargs[2]
					ϒm            λ.Object
					ϒres          λ.Object
					ϒretlist      λ.Object
					ϒvalue        = λargs[1]
					τmp0          λ.Object
					τmp1          λ.Object
				)
				λ.NewStr("Return the content of the tag with the specified attribute in the passed HTML document")
				ϒvalue = func() λ.Object {
					if λ.IsTrue(ϒescape_value) {
						return λ.Cal(Ωre.ϒescape, ϒvalue)
					} else {
						return ϒvalue
					}
				}()
				ϒretlist = λ.NewList()
				τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.Mod(λ.NewStr("(?xs)\n        <([a-zA-Z0-9:._-]+)\n         (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]*|=\"[^\"]*\"|='[^']*'|))*?\n         \\s+%s=['\"]?%s['\"]?\n         (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]*|=\"[^\"]*\"|='[^']*'|))*?\n        \\s*>\n        (?P<content>.*?)\n        </\\1>\n    "), λ.NewTuple(
					λ.Cal(Ωre.ϒescape, ϒattribute),
					ϒvalue,
				)), ϒhtml))
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒm = τmp1
					ϒres = λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewStr("content"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Cal(λ.GetAttr(ϒres, "startswith", nil), λ.NewStr("\"")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒres, "startswith", nil), λ.NewStr("'"))
						}
					}()) {
						ϒres = λ.GetItem(ϒres, λ.NewSlice(λ.NewInt(1), λ.Neg(λ.NewInt(1)), λ.None))
					}
					λ.Cal(λ.GetAttr(ϒretlist, "append", nil), λ.Cal(ϒunescapeHTML, ϒres))
				}
				return ϒretlist
			})
		HTMLAttributeParser = λ.Cal(λ.TypeType, λ.NewStr("HTMLAttributeParser"), λ.NewTuple(ϒcompat_HTMLParser), func() λ.Dict {
			var (
				HTMLAttributeParser___init__        λ.Object
				HTMLAttributeParser_handle_starttag λ.Object
			)
			λ.NewStr("Trivial HTML parser to gather the attributes for a single element")
			HTMLAttributeParser___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.SetAttr(ϒself, "attrs", λ.NewDictWithTable(map[λ.Object]λ.Object{}))
					λ.Cal(λ.GetAttr(ϒcompat_HTMLParser, "__init__", nil), ϒself)
					return λ.None
				})
			HTMLAttributeParser_handle_starttag = λ.NewFunction("handle_starttag",
				[]λ.Param{
					{Name: "self"},
					{Name: "tag"},
					{Name: "attrs"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒattrs = λargs[2]
						ϒself  = λargs[0]
						ϒtag   = λargs[1]
					)
					_ = ϒtag
					λ.SetAttr(ϒself, "attrs", λ.Cal(λ.DictType, ϒattrs))
					return λ.None
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"):        HTMLAttributeParser___init__,
				λ.NewStr("handle_starttag"): HTMLAttributeParser_handle_starttag,
			})
		}())
		ϒextract_attributes = λ.NewFunction("extract_attributes",
			[]λ.Param{
				{Name: "html_element"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒhtml_element = λargs[0]
					ϒparser       λ.Object
					τmp0          λ.Object
					τmp1          λ.Object
				)
				_ = τmp0
				_ = τmp1
				λ.NewStr("Given a string for an HTML element such as\n    <el\n         a=\"foo\" B=\"bar\" c=\"&98;az\" d=boz\n         empty= noval entity=\"&amp;\"\n         sq='\"' dq=\"'\"\n    >\n    Decode and return a dictionary of attributes.\n    {\n        'a': 'foo', 'b': 'bar', c: 'baz', d: 'boz',\n        'empty': '', 'noval': None, 'entity': '&',\n        'sq': '\"', 'dq': '''\n    }.\n    NB HTMLParser is stricter in Python 2.6 & 3.2 than in later versions,\n    but the cases in the unit test will work for all of 2.6, 2.7, 3.2-3.5.\n    ")
				ϒparser = λ.Cal(HTMLAttributeParser)
				τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
					defer λ.CatchMulti(
						nil,
						&λ.Catcher{ϒcompat_HTMLParseError, func(λex λ.BaseException) {
							// pass
						}},
					)
					λ.Cal(λ.GetAttr(ϒparser, "feed", nil), ϒhtml_element)
					λ.Cal(λ.GetAttr(ϒparser, "close", nil))
					return λ.BlockExitNormally, nil
				}()
				return λ.GetAttr(ϒparser, "attrs", nil)
			})
		ϒclean_html = λ.NewFunction("clean_html",
			[]λ.Param{
				{Name: "html"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒhtml = λargs[0]
				)
				λ.NewStr("Clean an HTML snippet into a readable string")
				if λ.IsTrue(λ.NewBool(ϒhtml == λ.None)) {
					return ϒhtml
				}
				ϒhtml = λ.Cal(λ.GetAttr(ϒhtml, "replace", nil), λ.NewStr("\n"), λ.NewStr(" "))
				ϒhtml = λ.Cal(Ωre.ϒsub, λ.NewStr("(?u)\\s*<\\s*br\\s*/?\\s*>\\s*"), λ.NewStr("\n"), ϒhtml)
				ϒhtml = λ.Cal(Ωre.ϒsub, λ.NewStr("(?u)<\\s*/\\s*p\\s*>\\s*<\\s*p[^>]*>"), λ.NewStr("\n"), ϒhtml)
				ϒhtml = λ.Cal(Ωre.ϒsub, λ.NewStr("<.*?>"), λ.NewStr(""), ϒhtml)
				ϒhtml = λ.Cal(ϒunescapeHTML, ϒhtml)
				return λ.Cal(λ.GetAttr(ϒhtml, "strip", nil))
			})
		ϒsanitize_filename = λ.NewFunction("sanitize_filename",
			[]λ.Param{
				{Name: "s"},
				{Name: "restricted", Def: λ.False},
				{Name: "is_id", Def: λ.False},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒis_id          = λargs[2]
					ϒreplace_insane λ.Object
					ϒrestricted     = λargs[1]
					ϒresult         λ.Object
					ϒs              = λargs[0]
				)
				λ.NewStr("Sanitizes a string so it could be used as part of a filename.\n    If restricted is set, use a stricter subset of allowed characters.\n    Set is_id if this is not an arbitrary string, but an ID that should be kept\n    if possible.\n    ")
				ϒreplace_insane = λ.NewFunction("replace_insane",
					[]λ.Param{
						{Name: "char"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒchar = λargs[0]
						)
						if λ.IsTrue(func() λ.Object {
							if λv := ϒrestricted; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(λ.None, ϒchar))
							}
						}()) {
							return λ.GetItem(λ.None, ϒchar)
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒchar, λ.NewStr("?")); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Lt(λ.Cal(λ.BuiltinOrd, ϒchar), λ.NewInt(32)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(λ.Cal(λ.BuiltinOrd, ϒchar), λ.NewInt(127))
							}
						}()) {
							return λ.NewStr("")
						} else {
							if λ.IsTrue(λ.Eq(ϒchar, λ.NewStr("\""))) {
								return func() λ.Object {
									if λ.IsTrue(ϒrestricted) {
										return λ.NewStr("")
									} else {
										return λ.NewStr("'")
									}
								}()
							} else {
								if λ.IsTrue(λ.Eq(ϒchar, λ.NewStr(":"))) {
									return func() λ.Object {
										if λ.IsTrue(ϒrestricted) {
											return λ.NewStr("_-")
										} else {
											return λ.NewStr(" -")
										}
									}()
								} else {
									if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewStr("\\/|*<>"), ϒchar))) {
										return λ.NewStr("_")
									}
								}
							}
						}
						if λ.IsTrue(func() λ.Object {
							if λv := ϒrestricted; !λ.IsTrue(λv) {
								return λv
							} else {
								return func() λ.Object {
									if λv := λ.NewBool(λ.Contains(λ.NewStr("!&'()[]{}$;`^,#"), ϒchar)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.GetAttr(ϒchar, "isspace", nil))
									}
								}()
							}
						}()) {
							return λ.NewStr("_")
						}
						if λ.IsTrue(func() λ.Object {
							if λv := ϒrestricted; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Gt(λ.Cal(λ.BuiltinOrd, ϒchar), λ.NewInt(127))
							}
						}()) {
							return λ.NewStr("_")
						}
						return ϒchar
					})
				ϒs = λ.Cal(Ωre.ϒsub, λ.NewStr("[0-9]+(?::[0-9]+)+"), λ.NewFunction("<lambda>",
					[]λ.Param{
						{Name: "m"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒm = λargs[0]
						)
						return λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(0)), "replace", nil), λ.NewStr(":"), λ.NewStr("_"))
					}), ϒs)
				ϒresult = λ.Cal(λ.GetAttr(λ.NewStr(""), "join", nil), λ.Cal(λ.MapIteratorType, ϒreplace_insane, ϒs))
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒis_id))) {
					for λ.IsTrue(λ.NewBool(λ.Contains(ϒresult, λ.NewStr("__")))) {
						ϒresult = λ.Cal(λ.GetAttr(ϒresult, "replace", nil), λ.NewStr("__"), λ.NewStr("_"))
					}
					ϒresult = λ.Cal(λ.GetAttr(ϒresult, "strip", nil), λ.NewStr("_"))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒrestricted; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒresult, "startswith", nil), λ.NewStr("-_"))
						}
					}()) {
						ϒresult = λ.GetItem(ϒresult, λ.NewSlice(λ.NewInt(2), λ.None, λ.None))
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(ϒresult, "startswith", nil), λ.NewStr("-"))) {
						ϒresult = λ.Add(λ.NewStr("_"), λ.GetItem(ϒresult, λ.NewSlice(λ.Cal(λ.BuiltinLen, λ.NewStr("-")), λ.None, λ.None)))
					}
					ϒresult = λ.Cal(λ.GetAttr(ϒresult, "lstrip", nil), λ.NewStr("."))
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒresult))) {
						ϒresult = λ.NewStr("_")
					}
				}
				return ϒresult
			})
		ϒsanitize_path = λ.NewFunction("sanitize_path",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdrive_or_unc   λ.Object
					ϒnorm_path      λ.Object
					ϒs              = λargs[0]
					ϒsanitized_path λ.Object
					τmp0            λ.Object
				)
				λ.NewStr("Sanitizes and normalizes path on Windows")
				if λ.IsTrue(λ.Ne(Ωsys.ϒplatform, λ.NewStr("win32"))) {
					return ϒs
				}
				τmp0 = λ.Cal(λ.None, ϒs)
				ϒdrive_or_unc = λ.GetItem(τmp0, λ.NewInt(0))
				_ = λ.GetItem(τmp0, λ.NewInt(1))
				if λ.IsTrue(func() λ.Object {
					if λv := λ.Lt(Ωsys.ϒversion_info, λ.NewTuple(
						λ.NewInt(2),
						λ.NewInt(7),
					)); !λ.IsTrue(λv) {
						return λv
					} else {
						return λ.NewBool(!λ.IsTrue(ϒdrive_or_unc))
					}
				}()) {
					τmp0 = λ.Cal(λ.None, ϒs)
					ϒdrive_or_unc = λ.GetItem(τmp0, λ.NewInt(0))
					_ = λ.GetItem(τmp0, λ.NewInt(1))
				}
				ϒnorm_path = λ.Cal(λ.GetAttr(λ.Cal(λ.None, λ.Cal(ϒremove_start, ϒs, ϒdrive_or_unc)), "split", nil), λ.None)
				if λ.IsTrue(ϒdrive_or_unc) {
					λ.Cal(λ.GetAttr(ϒnorm_path, "pop", nil), λ.NewInt(0))
				}
				ϒsanitized_path = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
					nil,
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
							var (
								ϒpath_part λ.Object
								τmp0       λ.Object
								τmp1       λ.Object
							)
							τmp0 = λ.Cal(λ.BuiltinIter, ϒnorm_path)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒpath_part = τmp1
								λgy.Yield(func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewList(
										λ.NewStr("."),
										λ.NewStr(".."),
									), ϒpath_part))) {
										return ϒpath_part
									} else {
										return λ.Cal(Ωre.ϒsub, λ.NewStr("(?:[/<>:\"\\|\\\\?\\*]|[\\s.]$)"), λ.NewStr("#"), ϒpath_part)
									}
								}())
							}
							return λ.None
						})
					})))
				if λ.IsTrue(ϒdrive_or_unc) {
					λ.Cal(λ.GetAttr(ϒsanitized_path, "insert", nil), λ.NewInt(0), λ.Add(ϒdrive_or_unc, λ.None))
				}
				return λ.Cal(λ.None, λ.Unpack(λ.AsStarred(ϒsanitized_path))...)
			})
		ϒsanitize_url = λ.NewFunction("sanitize_url",
			[]λ.Param{
				{Name: "url"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					COMMON_TYPOS λ.Object
					ϒfixup       λ.Object
					ϒmistake     λ.Object
					ϒurl         = λargs[0]
					τmp0         λ.Object
					τmp1         λ.Object
					τmp2         λ.Object
				)
				if λ.IsTrue(λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("//"))) {
					return λ.Mod(λ.NewStr("http:%s"), ϒurl)
				}
				COMMON_TYPOS = λ.NewTuple(
					λ.NewTuple(
						λ.NewStr("^httpss://"),
						λ.NewStr("https://"),
					),
					λ.NewTuple(
						λ.NewStr("^rmtp([es]?)://"),
						λ.NewStr("rtmp\\1://"),
					),
				)
				τmp0 = λ.Cal(λ.BuiltinIter, COMMON_TYPOS)
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					τmp2 = τmp1
					ϒmistake = λ.GetItem(τmp2, λ.NewInt(0))
					ϒfixup = λ.GetItem(τmp2, λ.NewInt(1))
					if λ.IsTrue(λ.Cal(Ωre.ϒmatch, ϒmistake, ϒurl)) {
						return λ.Cal(Ωre.ϒsub, ϒmistake, ϒfixup, ϒurl)
					}
				}
				return ϒurl
			})
		ϒsanitized_Request = λ.NewFunction("sanitized_Request",
			[]λ.Param{
				{Name: "url"},
			},
			0, true, true,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒargs   = λargs[1]
					ϒkwargs = λargs[2]
					ϒurl    = λargs[0]
				)
				return λ.Call(Ωrequest.Request, λ.NewArgs(λ.Unpack(
					λ.Cal(ϒsanitize_url, ϒurl),
					λ.AsStarred(ϒargs),
				)...), λ.KWArgs{
					{Name: "", Value: ϒkwargs},
				})
			})
		ϒexpand_path = λ.NewFunction("expand_path",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒs = λargs[0]
				)
				return ϒs
			})
		ϒorderedSet = λ.NewFunction("orderedSet",
			[]λ.Param{
				{Name: "iterable"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒel       λ.Object
					ϒiterable = λargs[0]
					ϒres      λ.Object
					τmp0      λ.Object
					τmp1      λ.Object
				)
				λ.NewStr(" Remove all duplicates from the input iterable ")
				ϒres = λ.NewList()
				τmp0 = λ.Cal(λ.BuiltinIter, ϒiterable)
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒel = τmp1
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒres, ϒel))) {
						λ.Cal(λ.GetAttr(ϒres, "append", nil), ϒel)
					}
				}
				return ϒres
			})
		ϒ_htmlentity_transform = λ.NewFunction("_htmlentity_transform",
			[]λ.Param{
				{Name: "entity_with_semicolon"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒbase                  λ.Object
					ϒentity                λ.Object
					ϒentity_with_semicolon = λargs[0]
					ϒmobj                  λ.Object
					ϒnumstr                λ.Object
					τmp0                   λ.Object
					τmp1                   λ.Object
				)
				λ.NewStr("Transforms an HTML entity to a character.")
				ϒentity = λ.GetItem(ϒentity_with_semicolon, λ.NewSlice(λ.None, λ.Neg(λ.NewInt(1)), λ.None))
				if λ.IsTrue(λ.NewBool(λ.Contains(Ωentities.ϒname2codepoint, ϒentity))) {
					return λ.Cal(ϒcompat_chr, λ.GetItem(Ωentities.ϒname2codepoint, ϒentity))
				}
				if λ.IsTrue(λ.NewBool(λ.Contains(ϒcompat_html_entities_html5, ϒentity_with_semicolon))) {
					return λ.GetItem(ϒcompat_html_entities_html5, ϒentity_with_semicolon)
				}
				ϒmobj = λ.Cal(Ωre.ϒmatch, λ.NewStr("#(x[0-9a-fA-F]+|[0-9]+)"), ϒentity)
				if λ.IsTrue(λ.NewBool(ϒmobj != λ.None)) {
					ϒnumstr = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1))
					if λ.IsTrue(λ.Cal(λ.GetAttr(ϒnumstr, "startswith", nil), λ.NewStr("x"))) {
						ϒbase = λ.NewInt(16)
						ϒnumstr = λ.Mod(λ.NewStr("0%s"), ϒnumstr)
					} else {
						ϒbase = λ.NewInt(10)
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
								// pass
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Cal(ϒcompat_chr, λ.Cal(λ.IntType, ϒnumstr, ϒbase))
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
				}
				return λ.Mod(λ.NewStr("&%s;"), ϒentity)
			})
		ϒunescapeHTML = λ.NewFunction("unescapeHTML",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒs = λargs[0]
				)
				if λ.IsTrue(λ.NewBool(ϒs == λ.None)) {
					return λ.None
				}
				if !λ.IsTrue(λ.Eq(λ.Cal(λ.TypeType, ϒs), ϒcompat_str)) {
					panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
				}
				return λ.Cal(Ωre.ϒsub, λ.NewStr("&([^&;]+;)"), λ.NewFunction("<lambda>",
					[]λ.Param{
						{Name: "m"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒm = λargs[0]
						)
						return λ.Cal(ϒ_htmlentity_transform, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(1)))
					}), ϒs)
			})
		ϒbug_reports_message = λ.NewFunction("bug_reports_message",
			nil,
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒmsg        λ.Object
					ϒupdate_cmd λ.Object
					τmp0        λ.Object
				)
				if λ.IsTrue(λ.Cal(ϒytdl_is_updateable)) {
					ϒupdate_cmd = λ.NewStr("type  youtube-dl -U  to update")
				} else {
					ϒupdate_cmd = λ.NewStr("see  https://yt-dl.org/update  on how to update")
				}
				ϒmsg = λ.NewStr("; please report this issue on https://yt-dl.org/bug .")
				τmp0 = λ.IAdd(ϒmsg, λ.Mod(λ.NewStr(" Make sure you are using the latest version; %s."), ϒupdate_cmd))
				ϒmsg = τmp0
				τmp0 = λ.IAdd(ϒmsg, λ.NewStr(" Be sure to call youtube-dl with the --verbose flag and include its complete output."))
				ϒmsg = τmp0
				return ϒmsg
			})
		YoutubeDLError = λ.Cal(λ.TypeType, λ.NewStr("YoutubeDLError"), λ.NewTuple(λ.ExceptionType), func() λ.Dict {
			λ.NewStr("Base exception for YoutubeDL errors.")
			// pass
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		ExtractorError = λ.Cal(λ.TypeType, λ.NewStr("ExtractorError"), λ.NewTuple(YoutubeDLError), func() λ.Dict {
			var (
				ExtractorError___init__         λ.Object
				ExtractorError_format_traceback λ.Object
			)
			λ.NewStr("Error during info extraction.")
			ExtractorError___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "msg"},
					{Name: "tb", Def: λ.None},
					{Name: "expected", Def: λ.False},
					{Name: "cause", Def: λ.None},
					{Name: "video_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcause    = λargs[4]
						ϒexpected = λargs[3]
						ϒmsg      = λargs[1]
						ϒself     = λargs[0]
						ϒtb       = λargs[2]
						ϒvideo_id = λargs[5]
						τmp0      λ.Object
					)
					λ.NewStr(" tb, if given, is the original traceback (so that it can be printed out).\n        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.\n        ")
					if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
						Ωerror.URLError,
						λ.None,
						UnavailableVideoError,
					), λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(0))))) {
						ϒexpected = λ.True
					}
					if λ.IsTrue(λ.NewBool(ϒvideo_id != λ.None)) {
						ϒmsg = λ.Add(λ.Add(ϒvideo_id, λ.NewStr(": ")), ϒmsg)
					}
					if λ.IsTrue(ϒcause) {
						τmp0 = λ.IAdd(ϒmsg, λ.Mod(λ.NewStr(" (caused by %r)"), ϒcause))
						ϒmsg = τmp0
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒexpected))) {
						τmp0 = λ.IAdd(ϒmsg, λ.Cal(ϒbug_reports_message))
						ϒmsg = τmp0
					}
					λ.Cal(λ.GetAttr(λ.Cal(λ.SuperType, ExtractorError, ϒself), "__init__", nil), ϒmsg)
					λ.SetAttr(ϒself, "traceback", ϒtb)
					λ.SetAttr(ϒself, "exc_info", λ.Cal(Ωsys.ϒexc_info))
					λ.SetAttr(ϒself, "cause", ϒcause)
					λ.SetAttr(ϒself, "video_id", ϒvideo_id)
					return λ.None
				})
			ExtractorError_format_traceback = λ.NewFunction("format_traceback",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					if λ.IsTrue(λ.NewBool(λ.GetAttr(ϒself, "traceback", nil) == λ.None)) {
						return λ.None
					}
					return λ.Cal(λ.GetAttr(λ.NewStr(""), "join", nil), λ.Cal(λ.GetAttr(λ.None, "format_tb", nil), λ.GetAttr(ϒself, "traceback", nil)))
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"):         ExtractorError___init__,
				λ.NewStr("format_traceback"): ExtractorError_format_traceback,
			})
		}())
		RegexNotFoundError = λ.Cal(λ.TypeType, λ.NewStr("RegexNotFoundError"), λ.NewTuple(ExtractorError), func() λ.Dict {
			λ.NewStr("Error when a regex didn't match")
			// pass
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		GeoRestrictedError = λ.Cal(λ.TypeType, λ.NewStr("GeoRestrictedError"), λ.NewTuple(ExtractorError), func() λ.Dict {
			λ.NewStr("Geographic restriction Error exception.\n\n    This exception may be thrown when a video is not available from your\n    geographic location due to geographic restrictions imposed by a website.\n    ")
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		DownloadError = λ.Cal(λ.TypeType, λ.NewStr("DownloadError"), λ.NewTuple(YoutubeDLError), func() λ.Dict {
			var (
				DownloadError___init__ λ.Object
			)
			λ.NewStr("Download Error exception.\n\n    This exception may be thrown by FileDownloader objects if they are not\n    configured to continue on errors. They will contain the appropriate\n    error message.\n    ")
			DownloadError___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "msg"},
					{Name: "exc_info", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒexc_info = λargs[2]
						ϒmsg      = λargs[1]
						ϒself     = λargs[0]
					)
					λ.NewStr(" exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). ")
					λ.Cal(λ.GetAttr(λ.Cal(λ.SuperType, DownloadError, ϒself), "__init__", nil), ϒmsg)
					λ.SetAttr(ϒself, "exc_info", ϒexc_info)
					return λ.None
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"): DownloadError___init__,
			})
		}())
		PostProcessingError = λ.Cal(λ.TypeType, λ.NewStr("PostProcessingError"), λ.NewTuple(YoutubeDLError), func() λ.Dict {
			λ.NewStr("Post Processing exception.\n\n    This exception may be raised by PostProcessor's .run() method to\n    indicate an error in the postprocessing task.\n    ")
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		MaxDownloadsReached = λ.Cal(λ.TypeType, λ.NewStr("MaxDownloadsReached"), λ.NewTuple(YoutubeDLError), func() λ.Dict {
			λ.NewStr(" --max-downloads limit has been reached. ")
			// pass
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		UnavailableVideoError = λ.Cal(λ.TypeType, λ.NewStr("UnavailableVideoError"), λ.NewTuple(YoutubeDLError), func() λ.Dict {
			λ.NewStr("Unavailable Format exception.\n\n    This exception will be thrown when a video is requested\n    in a format that is not available for that video.\n    ")
			// pass
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		ϒparse_iso8601 = λ.NewFunction("parse_iso8601",
			[]λ.Param{
				{Name: "date_str"},
				{Name: "delimiter", Def: λ.NewStr("T")},
				{Name: "timezone", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdate_str  = λargs[0]
					ϒdelimiter = λargs[1]
					ϒtimezone  = λargs[2]
				)
				_ = ϒdate_str
				_ = ϒdelimiter
				_ = ϒtimezone
				λ.NewStr(" Return a UNIX timestamp from the given date ")
				return λ.NewInt(0)
			})
		ϒunified_strdate = λ.NewFunction("unified_strdate",
			[]λ.Param{
				{Name: "date_str"},
				{Name: "day_first", Def: λ.True},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdate_str  = λargs[0]
					ϒday_first = λargs[1]
				)
				_ = ϒdate_str
				_ = ϒday_first
				return λ.NewStr("20000101")
			})
		ϒunified_timestamp = λ.NewFunction("unified_timestamp",
			[]λ.Param{
				{Name: "date_str"},
				{Name: "day_first", Def: λ.True},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdate_str  = λargs[0]
					ϒday_first = λargs[1]
				)
				_ = ϒdate_str
				_ = ϒday_first
				return λ.NewInt(0)
			})
		ϒdetermine_ext = λ.NewFunction("determine_ext",
			[]λ.Param{
				{Name: "url"},
				{Name: "default_ext", Def: λ.NewStr("unknown_video")},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault_ext = λargs[1]
					ϒguess       λ.Object
					ϒurl         = λargs[0]
				)
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(ϒurl == λ.None); λ.IsTrue(λv) {
						return λv
					} else {
						return λ.NewBool(!λ.Contains(ϒurl, λ.NewStr(".")))
					}
				}()) {
					return ϒdefault_ext
				}
				ϒguess = λ.GetItem(λ.Cal(λ.GetAttr(λ.GetItem(λ.Cal(λ.GetAttr(ϒurl, "partition", nil), λ.NewStr("?")), λ.NewInt(0)), "rpartition", nil), λ.NewStr(".")), λ.NewInt(2))
				if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^[A-Za-z0-9]+$"), ϒguess)) {
					return ϒguess
				} else {
					if λ.IsTrue(λ.NewBool(λ.Contains(KNOWN_EXTENSIONS, λ.Cal(λ.GetAttr(ϒguess, "rstrip", nil), λ.NewStr("/"))))) {
						return λ.Cal(λ.GetAttr(ϒguess, "rstrip", nil), λ.NewStr("/"))
					} else {
						return ϒdefault_ext
					}
				}
				return λ.None
			})
		if λ.IsTrue(λ.Eq(Ωsys.ϒplatform, λ.NewStr("win32"))) {
			λ.SetAttr(λ.None, "argtypes", λ.NewList(
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "HANDLE", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.Cal(λ.GetAttr(λ.None, "POINTER", nil), λ.None),
			))
			λ.SetAttr(λ.None, "restype", λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "BOOL", nil))
			λ.SetAttr(λ.None, "argtypes", λ.NewList(
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "HANDLE", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "DWORD", nil),
				λ.Cal(λ.GetAttr(λ.None, "POINTER", nil), λ.None),
			))
			λ.SetAttr(λ.None, "restype", λ.GetAttr(λ.GetAttr(λ.None, "wintypes", nil), "BOOL", nil))
		} else {
			τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
				defer λ.CatchMulti(
					nil,
					&λ.Catcher{λ.ImportErrorType, func(λex λ.BaseException) {

					}},
				)

				return λ.BlockExitNormally, nil
			}()
		}
		ϒsmuggle_url = λ.NewFunction("smuggle_url",
			[]λ.Param{
				{Name: "url"},
				{Name: "data"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdata  = λargs[1]
					ϒidata λ.Object
					ϒsdata λ.Object
					ϒurl   = λargs[0]
					τmp0   λ.Object
				)
				λ.NewStr(" Pass additional data in a URL for internal use. ")
				τmp0 = λ.Cal(ϒunsmuggle_url, ϒurl, λ.NewDictWithTable(map[λ.Object]λ.Object{}))
				ϒurl = λ.GetItem(τmp0, λ.NewInt(0))
				ϒidata = λ.GetItem(τmp0, λ.NewInt(1))
				λ.Cal(λ.GetAttr(ϒdata, "update", nil), ϒidata)
				ϒsdata = λ.Cal(ϒcompat_urllib_parse_urlencode, λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("__youtubedl_smuggle"): λ.Cal(Ωjson.ϒdumps, ϒdata),
				}))
				return λ.Add(λ.Add(ϒurl, λ.NewStr("#")), ϒsdata)
			})
		ϒunsmuggle_url = λ.NewFunction("unsmuggle_url",
			[]λ.Param{
				{Name: "smug_url"},
				{Name: "default", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdata     λ.Object
					ϒdefault  = λargs[1]
					ϒjsond    λ.Object
					ϒsdata    λ.Object
					ϒsmug_url = λargs[0]
					ϒurl      λ.Object
					τmp0      λ.Object
				)
				if λ.IsTrue(λ.NewBool(!λ.Contains(ϒsmug_url, λ.NewStr("#__youtubedl_smuggle")))) {
					return λ.NewTuple(
						ϒsmug_url,
						ϒdefault,
					)
				}
				τmp0 = λ.Cal(λ.GetAttr(ϒsmug_url, "rpartition", nil), λ.NewStr("#"))
				ϒurl = λ.GetItem(τmp0, λ.NewInt(0))
				_ = λ.GetItem(τmp0, λ.NewInt(1))
				ϒsdata = λ.GetItem(τmp0, λ.NewInt(2))
				ϒjsond = λ.GetItem(λ.GetItem(λ.Cal(ϒcompat_parse_qs, ϒsdata), λ.NewStr("__youtubedl_smuggle")), λ.NewInt(0))
				ϒdata = λ.Cal(Ωjson.ϒloads, ϒjsond)
				return λ.NewTuple(
					ϒurl,
					ϒdata,
				)
			})
		ϒlookup_unit_table = λ.NewFunction("lookup_unit_table",
			[]λ.Param{
				{Name: "unit_table"},
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒm          λ.Object
					ϒmult       λ.Object
					ϒnum_str    λ.Object
					ϒs          = λargs[1]
					ϒunit_table = λargs[0]
					ϒunits_re   λ.Object
				)
				ϒunits_re = λ.Cal(λ.GetAttr(λ.NewStr("|"), "join", nil), λ.Cal(λ.NewFunction("<generator>",
					nil,
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
							var (
								ϒu   λ.Object
								τmp0 λ.Object
								τmp1 λ.Object
							)
							τmp0 = λ.Cal(λ.BuiltinIter, ϒunit_table)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒu = τmp1
								λgy.Yield(λ.Cal(Ωre.ϒescape, ϒu))
							}
							return λ.None
						})
					})))
				ϒm = λ.Cal(Ωre.ϒmatch, λ.Mod(λ.NewStr("(?P<num>[0-9]+(?:[,.][0-9]*)?)\\s*(?P<unit>%s)\\b"), ϒunits_re), ϒs)
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒm))) {
					return λ.None
				}
				ϒnum_str = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewStr("num")), "replace", nil), λ.NewStr(","), λ.NewStr("."))
				ϒmult = λ.GetItem(ϒunit_table, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewStr("unit")))
				return λ.Cal(λ.IntType, λ.Mul(λ.Cal(λ.FloatType, ϒnum_str), ϒmult))
			})
		ϒparse_filesize = λ.NewFunction("parse_filesize",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒ_UNIT_TABLE λ.Object
					ϒs           = λargs[0]
				)
				if λ.IsTrue(λ.NewBool(ϒs == λ.None)) {
					return λ.None
				}
				ϒ_UNIT_TABLE = λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("B"):          λ.NewInt(1),
					λ.NewStr("b"):          λ.NewInt(1),
					λ.NewStr("bytes"):      λ.NewInt(1),
					λ.NewStr("KiB"):        λ.NewInt(1024),
					λ.NewStr("KB"):         λ.NewInt(1000),
					λ.NewStr("kB"):         λ.NewInt(1024),
					λ.NewStr("Kb"):         λ.NewInt(1000),
					λ.NewStr("kb"):         λ.NewInt(1000),
					λ.NewStr("kilobytes"):  λ.NewInt(1000),
					λ.NewStr("kibibytes"):  λ.NewInt(1024),
					λ.NewStr("MiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(2)),
					λ.NewStr("MB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("mB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(2)),
					λ.NewStr("Mb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("mb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("megabytes"):  λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("mebibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(2)),
					λ.NewStr("GiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(3)),
					λ.NewStr("GB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(3)),
					λ.NewStr("gB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(3)),
					λ.NewStr("Gb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(3)),
					λ.NewStr("gb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(3)),
					λ.NewStr("gigabytes"):  λ.Pow(λ.NewInt(1000), λ.NewInt(3)),
					λ.NewStr("gibibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(3)),
					λ.NewStr("TiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(4)),
					λ.NewStr("TB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(4)),
					λ.NewStr("tB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(4)),
					λ.NewStr("Tb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(4)),
					λ.NewStr("tb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(4)),
					λ.NewStr("terabytes"):  λ.Pow(λ.NewInt(1000), λ.NewInt(4)),
					λ.NewStr("tebibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(4)),
					λ.NewStr("PiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(5)),
					λ.NewStr("PB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(5)),
					λ.NewStr("pB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(5)),
					λ.NewStr("Pb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(5)),
					λ.NewStr("pb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(5)),
					λ.NewStr("petabytes"):  λ.Pow(λ.NewInt(1000), λ.NewInt(5)),
					λ.NewStr("pebibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(5)),
					λ.NewStr("EiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(6)),
					λ.NewStr("EB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(6)),
					λ.NewStr("eB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(6)),
					λ.NewStr("Eb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(6)),
					λ.NewStr("eb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(6)),
					λ.NewStr("exabytes"):   λ.Pow(λ.NewInt(1000), λ.NewInt(6)),
					λ.NewStr("exbibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(6)),
					λ.NewStr("ZiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(7)),
					λ.NewStr("ZB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(7)),
					λ.NewStr("zB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(7)),
					λ.NewStr("Zb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(7)),
					λ.NewStr("zb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(7)),
					λ.NewStr("zettabytes"): λ.Pow(λ.NewInt(1000), λ.NewInt(7)),
					λ.NewStr("zebibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(7)),
					λ.NewStr("YiB"):        λ.Pow(λ.NewInt(1024), λ.NewInt(8)),
					λ.NewStr("YB"):         λ.Pow(λ.NewInt(1000), λ.NewInt(8)),
					λ.NewStr("yB"):         λ.Pow(λ.NewInt(1024), λ.NewInt(8)),
					λ.NewStr("Yb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(8)),
					λ.NewStr("yb"):         λ.Pow(λ.NewInt(1000), λ.NewInt(8)),
					λ.NewStr("yottabytes"): λ.Pow(λ.NewInt(1000), λ.NewInt(8)),
					λ.NewStr("yobibytes"):  λ.Pow(λ.NewInt(1024), λ.NewInt(8)),
				})
				return λ.Cal(ϒlookup_unit_table, ϒ_UNIT_TABLE, ϒs)
			})
		ϒparse_count = λ.NewFunction("parse_count",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒ_UNIT_TABLE λ.Object
					ϒs           = λargs[0]
				)
				if λ.IsTrue(λ.NewBool(ϒs == λ.None)) {
					return λ.None
				}
				ϒs = λ.Cal(λ.GetAttr(ϒs, "strip", nil))
				if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^[\\d,.]+$"), ϒs)) {
					return λ.Cal(ϒstr_to_int, ϒs)
				}
				ϒ_UNIT_TABLE = λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("k"):  λ.NewInt(1000),
					λ.NewStr("K"):  λ.NewInt(1000),
					λ.NewStr("m"):  λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("M"):  λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("kk"): λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
					λ.NewStr("KK"): λ.Pow(λ.NewInt(1000), λ.NewInt(2)),
				})
				return λ.Cal(ϒlookup_unit_table, ϒ_UNIT_TABLE, ϒs)
			})
		ϒparse_resolution = λ.NewFunction("parse_resolution",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒmobj λ.Object
					ϒs    = λargs[0]
				)
				if λ.IsTrue(λ.NewBool(ϒs == λ.None)) {
					return λ.NewDictWithTable(map[λ.Object]λ.Object{})
				}
				ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("\\b(?P<w>\\d+)\\s*[xX×]\\s*(?P<h>\\d+)\\b"), ϒs)
				if λ.IsTrue(ϒmobj) {
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("width"):  λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("w"))),
						λ.NewStr("height"): λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("h"))),
					})
				}
				ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("\\b(\\d+)[pPiI]\\b"), ϒs)
				if λ.IsTrue(ϒmobj) {
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("height"): λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1))),
					})
				}
				ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("\\b([48])[kK]\\b"), ϒs)
				if λ.IsTrue(ϒmobj) {
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("height"): λ.Mul(λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1))), λ.NewInt(540)),
					})
				}
				return λ.NewDictWithTable(map[λ.Object]λ.Object{})
			})
		ϒparse_bitrate = λ.NewFunction("parse_bitrate",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒmobj λ.Object
					ϒs    = λargs[0]
				)
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒs, ϒcompat_str)))) {
					return λ.None
				}
				ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("\\b(\\d+)\\s*kbps"), ϒs)
				if λ.IsTrue(ϒmobj) {
					return λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1)))
				}
				return λ.None
			})
		ϒmonth_by_name = λ.NewFunction("month_by_name",
			[]λ.Param{
				{Name: "name"},
				{Name: "lang", Def: λ.NewStr("en")},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒlang        = λargs[1]
					ϒmonth_names λ.Object
					ϒname        = λargs[0]
					τmp0         λ.Object
					τmp1         λ.Object
				)
				λ.NewStr(" Return the number of a month by (locale-independently) English name ")
				ϒmonth_names = λ.Cal(λ.GetAttr(MONTH_NAMES, "get", nil), ϒlang, λ.GetItem(MONTH_NAMES, λ.NewStr("en")))
				τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
					defer λ.CatchMulti(
						nil,
						&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
							λexit, λret = λ.BlockExitReturn, λ.None
							return
						}},
					)
					λexit, λret = λ.BlockExitReturn, λ.Add(λ.Cal(λ.GetAttr(ϒmonth_names, "index", nil), ϒname), λ.NewInt(1))
					return
					return λ.BlockExitNormally, nil
				}()
				if τmp0 == λ.BlockExitReturn {
					return τmp1
				}
				return λ.None
			})
		ϒfix_xml_ampersands = λ.NewFunction("fix_xml_ampersands",
			[]λ.Param{
				{Name: "xml_str"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒxml_str = λargs[0]
				)
				λ.NewStr("Replace all the '&' by '&amp;' in XML")
				return λ.Cal(Ωre.ϒsub, λ.NewStr("&(?!amp;|lt;|gt;|apos;|quot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)"), λ.NewStr("&amp;"), ϒxml_str)
			})
		ϒremove_start = λ.NewFunction("remove_start",
			[]λ.Param{
				{Name: "s"},
				{Name: "start"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒs     = λargs[0]
					ϒstart = λargs[1]
				)
				return func() λ.Object {
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(ϒs != λ.None); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒs, "startswith", nil), ϒstart)
						}
					}()) {
						return λ.GetItem(ϒs, λ.NewSlice(λ.Cal(λ.BuiltinLen, ϒstart), λ.None, λ.None))
					} else {
						return ϒs
					}
				}()
			})
		ϒremove_end = λ.NewFunction("remove_end",
			[]λ.Param{
				{Name: "s"},
				{Name: "end"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒend = λargs[1]
					ϒs   = λargs[0]
				)
				return func() λ.Object {
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(ϒs != λ.None); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒs, "endswith", nil), ϒend)
						}
					}()) {
						return λ.GetItem(ϒs, λ.NewSlice(λ.None, λ.Neg(λ.Cal(λ.BuiltinLen, ϒend)), λ.None))
					} else {
						return ϒs
					}
				}()
			})
		ϒremove_quotes = λ.NewFunction("remove_quotes",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒquote λ.Object
					ϒs     = λargs[0]
					τmp0   λ.Object
					τmp1   λ.Object
				)
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(ϒs == λ.None); λ.IsTrue(λv) {
						return λv
					} else {
						return λ.Lt(λ.Cal(λ.BuiltinLen, ϒs), λ.NewInt(2))
					}
				}()) {
					return ϒs
				}
				τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
					λ.NewStr("\""),
					λ.NewStr("'"),
				))
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒquote = τmp1
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Eq(λ.GetItem(ϒs, λ.NewInt(0)), ϒquote); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Eq(λ.GetItem(ϒs, λ.Neg(λ.NewInt(1))), ϒquote)
						}
					}()) {
						return λ.GetItem(ϒs, λ.NewSlice(λ.NewInt(1), λ.Neg(λ.NewInt(1)), λ.None))
					}
				}
				return ϒs
			})
		ϒurl_basename = λ.NewFunction("url_basename",
			[]λ.Param{
				{Name: "url"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒpath λ.Object
					ϒurl  = λargs[0]
				)
				ϒpath = λ.GetAttr(λ.Cal(Ωparse.ϒurlparse, ϒurl), "path", nil)
				return λ.GetItem(λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒpath, "strip", nil), λ.NewStr("/")), "split", nil), λ.NewStr("/")), λ.Neg(λ.NewInt(1)))
			})
		ϒbase_url = λ.NewFunction("base_url",
			[]λ.Param{
				{Name: "url"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒurl = λargs[0]
				)
				return λ.Cal(λ.GetAttr(λ.Cal(Ωre.ϒmatch, λ.NewStr("https?://[^?#&]+/"), ϒurl), "group", nil))
			})
		ϒurljoin = λ.NewFunction("urljoin",
			[]λ.Param{
				{Name: "base"},
				{Name: "path"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒbase = λargs[0]
					ϒpath = λargs[1]
				)
				if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpath, λ.BytesType)) {
					ϒpath = λ.Cal(λ.GetAttr(ϒpath, "decode", nil), λ.NewStr("utf-8"))
				}
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpath, ϒcompat_str))); λ.IsTrue(λv) {
						return λv
					} else {
						return λ.NewBool(!λ.IsTrue(ϒpath))
					}
				}()) {
					return λ.None
				}
				if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^(?:[a-zA-Z][a-zA-Z0-9+-.]*:)?//"), ϒpath)) {
					return ϒpath
				}
				if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒbase, λ.BytesType)) {
					ϒbase = λ.Cal(λ.GetAttr(ϒbase, "decode", nil), λ.NewStr("utf-8"))
				}
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒbase, ϒcompat_str))); λ.IsTrue(λv) {
						return λv
					} else {
						return λ.NewBool(!λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^(?:https?:)?//"), ϒbase)))
					}
				}()) {
					return λ.None
				}
				return λ.Cal(Ωparse.ϒurljoin, ϒbase, ϒpath)
			})
		HEADRequest = λ.Cal(λ.TypeType, λ.NewStr("HEADRequest"), λ.NewTuple(Ωrequest.Request), func() λ.Dict {
			var (
				HEADRequest_get_method λ.Object
			)
			HEADRequest_get_method = λ.NewFunction("get_method",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					_ = ϒself
					return λ.NewStr("HEAD")
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("get_method"): HEADRequest_get_method,
			})
		}())
		ϒint_or_none = λ.NewFunction("int_or_none",
			[]λ.Param{
				{Name: "v"},
				{Name: "scale", Def: λ.NewInt(1)},
				{Name: "default", Def: λ.None},
				{Name: "get_attr", Def: λ.None},
				{Name: "invscale", Def: λ.NewInt(1)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault  = λargs[2]
					ϒget_attr = λargs[3]
					ϒinvscale = λargs[4]
					ϒscale    = λargs[1]
					ϒv        = λargs[0]
					τmp0      λ.Object
					τmp1      λ.Object
				)
				if λ.IsTrue(ϒget_attr) {
					if λ.IsTrue(λ.NewBool(ϒv != λ.None)) {
						ϒv = λ.Cal(λ.BuiltinGetAttr, ϒv, ϒget_attr, λ.None)
					}
				}
				if λ.IsTrue(λ.Eq(ϒv, λ.NewStr(""))) {
					ϒv = λ.None
				}
				if λ.IsTrue(λ.NewBool(ϒv == λ.None)) {
					return ϒdefault
				}
				τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
					defer λ.CatchMulti(
						nil,
						&λ.Catcher{λ.NewTuple(
							λ.ValueErrorType,
							λ.TypeErrorType,
						), func(λex λ.BaseException) {
							λexit, λret = λ.BlockExitReturn, ϒdefault
							return
						}},
					)
					λexit, λret = λ.BlockExitReturn, λ.FloorDiv(λ.Mul(λ.Cal(λ.IntType, ϒv), ϒinvscale), ϒscale)
					return
					return λ.BlockExitNormally, nil
				}()
				if τmp0 == λ.BlockExitReturn {
					return τmp1
				}
				return λ.None
			})
		ϒstr_or_none = λ.NewFunction("str_or_none",
			[]λ.Param{
				{Name: "v"},
				{Name: "default", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault = λargs[1]
					ϒv       = λargs[0]
				)
				return func() λ.Object {
					if λ.IsTrue(λ.NewBool(ϒv == λ.None)) {
						return ϒdefault
					} else {
						return λ.Cal(ϒcompat_str, ϒv)
					}
				}()
			})
		ϒstr_to_int = λ.NewFunction("str_to_int",
			[]λ.Param{
				{Name: "int_str"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒint_str = λargs[0]
				)
				λ.NewStr(" A more relaxed version of int_or_none ")
				if λ.IsTrue(λ.NewBool(ϒint_str == λ.None)) {
					return λ.None
				}
				ϒint_str = λ.Cal(Ωre.ϒsub, λ.NewStr("[,\\.\\+]"), λ.NewStr(""), ϒint_str)
				return λ.Cal(λ.IntType, ϒint_str)
			})
		ϒfloat_or_none = λ.NewFunction("float_or_none",
			[]λ.Param{
				{Name: "v"},
				{Name: "scale", Def: λ.NewInt(1)},
				{Name: "invscale", Def: λ.NewInt(1)},
				{Name: "default", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault  = λargs[3]
					ϒinvscale = λargs[2]
					ϒscale    = λargs[1]
					ϒv        = λargs[0]
					τmp0      λ.Object
					τmp1      λ.Object
				)
				if λ.IsTrue(λ.NewBool(ϒv == λ.None)) {
					return ϒdefault
				}
				τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
					defer λ.CatchMulti(
						nil,
						&λ.Catcher{λ.NewTuple(
							λ.ValueErrorType,
							λ.TypeErrorType,
						), func(λex λ.BaseException) {
							λexit, λret = λ.BlockExitReturn, ϒdefault
							return
						}},
					)
					λexit, λret = λ.BlockExitReturn, λ.TrueDiv(λ.Mul(λ.Cal(λ.FloatType, ϒv), ϒinvscale), ϒscale)
					return
					return λ.BlockExitNormally, nil
				}()
				if τmp0 == λ.BlockExitReturn {
					return τmp1
				}
				return λ.None
			})
		ϒstrip_or_none = λ.NewFunction("strip_or_none",
			[]λ.Param{
				{Name: "v"},
				{Name: "default", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdefault = λargs[1]
					ϒv       = λargs[0]
				)
				return func() λ.Object {
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒv, ϒcompat_str)) {
						return λ.Cal(λ.GetAttr(ϒv, "strip", nil))
					} else {
						return ϒdefault
					}
				}()
			})
		ϒurl_or_none = λ.NewFunction("url_or_none",
			[]λ.Param{
				{Name: "url"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒurl = λargs[0]
				)
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(!λ.IsTrue(ϒurl)); λ.IsTrue(λv) {
						return λv
					} else {
						return λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl, ϒcompat_str)))
					}
				}()) {
					return λ.None
				}
				ϒurl = λ.Cal(λ.GetAttr(ϒurl, "strip", nil))
				return func() λ.Object {
					if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^(?:[a-zA-Z][\\da-zA-Z.+-]*:)?//"), ϒurl)) {
						return ϒurl
					} else {
						return λ.None
					}
				}()
			})
		ϒparse_duration = λ.NewFunction("parse_duration",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdays     λ.Object
					ϒduration λ.Object
					ϒhours    λ.Object
					ϒm        λ.Object
					ϒmins     λ.Object
					ϒms       λ.Object
					ϒs        = λargs[0]
					ϒsecs     λ.Object
					τmp0      λ.Object
				)
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒs, ϒcompat_basestring)))) {
					return λ.None
				}
				ϒs = λ.Cal(λ.GetAttr(ϒs, "strip", nil))
				τmp0 = λ.Mul(λ.NewList(λ.None), λ.NewInt(5))
				ϒdays = λ.GetItem(τmp0, λ.NewInt(0))
				ϒhours = λ.GetItem(τmp0, λ.NewInt(1))
				ϒmins = λ.GetItem(τmp0, λ.NewInt(2))
				ϒsecs = λ.GetItem(τmp0, λ.NewInt(3))
				ϒms = λ.GetItem(τmp0, λ.NewInt(4))
				ϒm = λ.Cal(Ωre.ϒmatch, λ.NewStr("(?:(?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?(?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?Z?$"), ϒs)
				if λ.IsTrue(ϒm) {
					τmp0 = λ.Cal(λ.GetAttr(ϒm, "groups", nil))
					ϒdays = λ.GetItem(τmp0, λ.NewInt(0))
					ϒhours = λ.GetItem(τmp0, λ.NewInt(1))
					ϒmins = λ.GetItem(τmp0, λ.NewInt(2))
					ϒsecs = λ.GetItem(τmp0, λ.NewInt(3))
					ϒms = λ.GetItem(τmp0, λ.NewInt(4))
				} else {
					ϒm = λ.Cal(Ωre.ϒmatch, λ.NewStr("(?ix)(?:P?\n                (?:\n                    [0-9]+\\s*y(?:ears?)?\\s*\n                )?\n                (?:\n                    [0-9]+\\s*m(?:onths?)?\\s*\n                )?\n                (?:\n                    [0-9]+\\s*w(?:eeks?)?\\s*\n                )?\n                (?:\n                    (?P<days>[0-9]+)\\s*d(?:ays?)?\\s*\n                )?\n                T)?\n                (?:\n                    (?P<hours>[0-9]+)\\s*h(?:ours?)?\\s*\n                )?\n                (?:\n                    (?P<mins>[0-9]+)\\s*m(?:in(?:ute)?s?)?\\s*\n                )?\n                (?:\n                    (?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?\\s*s(?:ec(?:ond)?s?)?\\s*\n                )?Z?$"), ϒs)
					if λ.IsTrue(ϒm) {
						τmp0 = λ.Cal(λ.GetAttr(ϒm, "groups", nil))
						ϒdays = λ.GetItem(τmp0, λ.NewInt(0))
						ϒhours = λ.GetItem(τmp0, λ.NewInt(1))
						ϒmins = λ.GetItem(τmp0, λ.NewInt(2))
						ϒsecs = λ.GetItem(τmp0, λ.NewInt(3))
						ϒms = λ.GetItem(τmp0, λ.NewInt(4))
					} else {
						ϒm = λ.Cal(Ωre.ϒmatch, λ.NewStr("(?i)(?:(?P<hours>[0-9.]+)\\s*(?:hours?)|(?P<mins>[0-9.]+)\\s*(?:mins?\\.?|minutes?)\\s*)Z?$"), ϒs)
						if λ.IsTrue(ϒm) {
							τmp0 = λ.Cal(λ.GetAttr(ϒm, "groups", nil))
							ϒhours = λ.GetItem(τmp0, λ.NewInt(0))
							ϒmins = λ.GetItem(τmp0, λ.NewInt(1))
						} else {
							return λ.None
						}
					}
				}
				ϒduration = λ.NewInt(0)
				if λ.IsTrue(ϒsecs) {
					τmp0 = λ.IAdd(ϒduration, λ.Cal(λ.FloatType, ϒsecs))
					ϒduration = τmp0
				}
				if λ.IsTrue(ϒmins) {
					τmp0 = λ.IAdd(ϒduration, λ.Mul(λ.Cal(λ.FloatType, ϒmins), λ.NewInt(60)))
					ϒduration = τmp0
				}
				if λ.IsTrue(ϒhours) {
					τmp0 = λ.IAdd(ϒduration, λ.Mul(λ.Mul(λ.Cal(λ.FloatType, ϒhours), λ.NewInt(60)), λ.NewInt(60)))
					ϒduration = τmp0
				}
				if λ.IsTrue(ϒdays) {
					τmp0 = λ.IAdd(ϒduration, λ.Mul(λ.Mul(λ.Mul(λ.Cal(λ.FloatType, ϒdays), λ.NewInt(24)), λ.NewInt(60)), λ.NewInt(60)))
					ϒduration = τmp0
				}
				if λ.IsTrue(ϒms) {
					τmp0 = λ.IAdd(ϒduration, λ.Cal(λ.FloatType, ϒms))
					ϒduration = τmp0
				}
				return ϒduration
			})
		PagedList = λ.Cal(λ.TypeType, λ.NewStr("PagedList"), λ.NewTuple(λ.ObjectType), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		ϒuppercase_escape = λ.NewFunction("uppercase_escape",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒs              = λargs[0]
					ϒunicode_escape λ.Object
				)
				ϒunicode_escape = λ.Cal(Ωcodecs.ϒgetdecoder, λ.NewStr("unicode_escape"))
				return λ.Cal(Ωre.ϒsub, λ.NewStr("\\\\U[0-9a-fA-F]{8}"), λ.NewFunction("<lambda>",
					[]λ.Param{
						{Name: "m"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒm = λargs[0]
						)
						return λ.GetItem(λ.Cal(ϒunicode_escape, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(0))), λ.NewInt(0))
					}), ϒs)
			})
		ϒlowercase_escape = λ.NewFunction("lowercase_escape",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒs              = λargs[0]
					ϒunicode_escape λ.Object
				)
				ϒunicode_escape = λ.Cal(Ωcodecs.ϒgetdecoder, λ.NewStr("unicode_escape"))
				return λ.Cal(Ωre.ϒsub, λ.NewStr("\\\\u[0-9a-fA-F]{4}"), λ.NewFunction("<lambda>",
					[]λ.Param{
						{Name: "m"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒm = λargs[0]
						)
						return λ.GetItem(λ.Cal(ϒunicode_escape, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(0))), λ.NewInt(0))
					}), ϒs)
			})
		ϒurlencode_postdata = λ.NewFunction("urlencode_postdata",
			nil,
			0, true, true,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒargs  = λargs[0]
					ϒkargs = λargs[1]
				)
				return λ.Cal(λ.GetAttr(λ.Call(ϒcompat_urllib_parse_urlencode, λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
					{Name: "", Value: ϒkargs},
				}), "encode", nil), λ.NewStr("ascii"))
			})
		ϒupdate_url_query = λ.NewFunction("update_url_query",
			[]λ.Param{
				{Name: "url"},
				{Name: "query"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒparsed_url λ.Object
					ϒqs         λ.Object
					ϒquery      = λargs[1]
					ϒurl        = λargs[0]
				)
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒquery))) {
					return ϒurl
				}
				ϒparsed_url = λ.Cal(Ωparse.ϒurlparse, ϒurl)
				ϒqs = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(ϒparsed_url, "query", nil))
				λ.Cal(λ.GetAttr(ϒqs, "update", nil), ϒquery)
				return λ.Cal(Ωparse.ϒurlunparse, λ.Call(λ.GetAttr(ϒparsed_url, "_replace", nil), nil, λ.KWArgs{
					{Name: "query", Value: λ.Cal(ϒcompat_urllib_parse_urlencode, ϒqs, λ.True)},
				}))
			})
		ϒupdate_Request = λ.NewFunction("update_Request",
			[]λ.Param{
				{Name: "req"},
				{Name: "url", Def: λ.None},
				{Name: "data", Def: λ.None},
				{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
				{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒdata           = λargs[2]
					ϒheaders        = λargs[3]
					ϒnew_req        λ.Object
					ϒquery          = λargs[4]
					ϒreq            = λargs[0]
					ϒreq_data       λ.Object
					ϒreq_get_method λ.Object
					ϒreq_headers    λ.Object
					ϒreq_type       λ.Object
					ϒreq_url        λ.Object
					ϒurl            = λargs[1]
				)
				ϒreq_headers = λ.Cal(λ.GetAttr(λ.GetAttr(ϒreq, "headers", nil), "copy", nil))
				λ.Cal(λ.GetAttr(ϒreq_headers, "update", nil), ϒheaders)
				ϒreq_data = func() λ.Object {
					if λv := ϒdata; λ.IsTrue(λv) {
						return λv
					} else {
						return λ.GetAttr(ϒreq, "data", nil)
					}
				}()
				ϒreq_url = λ.Cal(ϒupdate_url_query, func() λ.Object {
					if λv := ϒurl; λ.IsTrue(λv) {
						return λv
					} else {
						return λ.Cal(λ.GetAttr(ϒreq, "get_full_url", nil))
					}
				}(), ϒquery)
				ϒreq_get_method = λ.Cal(λ.GetAttr(ϒreq, "get_method", nil))
				if λ.IsTrue(λ.Eq(ϒreq_get_method, λ.NewStr("HEAD"))) {
					ϒreq_type = HEADRequest
				} else {
					if λ.IsTrue(λ.Eq(ϒreq_get_method, λ.NewStr("PUT"))) {
						ϒreq_type = λ.None
					} else {
						ϒreq_type = Ωrequest.Request
					}
				}
				ϒnew_req = λ.Call(ϒreq_type, λ.NewArgs(ϒreq_url), λ.KWArgs{
					{Name: "data", Value: ϒreq_data},
					{Name: "headers", Value: ϒreq_headers},
					{Name: "origin_req_host", Value: λ.GetAttr(ϒreq, "origin_req_host", nil)},
					{Name: "unverifiable", Value: λ.GetAttr(ϒreq, "unverifiable", nil)},
				})
				if λ.IsTrue(λ.Cal(λ.BuiltinHasAttr, ϒreq, λ.NewStr("timeout"))) {
					λ.SetAttr(ϒnew_req, "timeout", λ.GetAttr(ϒreq, "timeout", nil))
				}
				return ϒnew_req
			})
		ϒdict_get = λ.NewFunction("dict_get",
			[]λ.Param{
				{Name: "d"},
				{Name: "key_or_keys"},
				{Name: "default", Def: λ.None},
				{Name: "skip_false_values", Def: λ.True},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒd                 = λargs[0]
					ϒdefault           = λargs[2]
					ϒkey               λ.Object
					ϒkey_or_keys       = λargs[1]
					ϒskip_false_values = λargs[3]
					τmp0               λ.Object
					τmp1               λ.Object
				)
				if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒkey_or_keys, λ.NewTuple(
					λ.ListType,
					λ.TupleType,
				))) {
					τmp0 = λ.Cal(λ.BuiltinIter, ϒkey_or_keys)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒkey = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.Contains(ϒd, ϒkey)); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.NewBool(λ.GetItem(ϒd, ϒkey) == λ.None); λ.IsTrue(λv) {
								return λv
							} else {
								return func() λ.Object {
									if λv := ϒskip_false_values; !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.GetItem(ϒd, ϒkey)))
									}
								}()
							}
						}()) {
							continue
						}
						return λ.GetItem(ϒd, ϒkey)
					}
					return ϒdefault
				}
				return λ.Cal(λ.GetAttr(ϒd, "get", nil), ϒkey_or_keys, ϒdefault)
			})
		ϒtry_get = λ.NewFunction("try_get",
			[]λ.Param{
				{Name: "src"},
				{Name: "getter"},
				{Name: "expected_type", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒexpected_type = λargs[2]
					ϒget           λ.Object
					ϒgetter        = λargs[1]
					ϒsrc           = λargs[0]
					ϒv             λ.Object
					τmp0           λ.Object
					τmp1           λ.Object
					τmp2           λ.Object
					τmp3           λ.Object
				)
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒgetter, λ.NewTuple(
					λ.ListType,
					λ.TupleType,
				))))) {
					ϒgetter = λ.NewList(ϒgetter)
				}
				τmp0 = λ.Cal(λ.BuiltinIter, ϒgetter)
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒget = τmp1
					τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							func() {
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(ϒexpected_type == λ.None); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.BuiltinIsInstance, ϒv, ϒexpected_type)
									}
								}()) {
									λexit, λret = λ.BlockExitReturn, ϒv
									return
								}
							},
							&λ.Catcher{λ.NewTuple(
								λ.AttributeErrorType,
								λ.KeyErrorType,
								λ.TypeErrorType,
								λ.IndexErrorType,
							), func(λex λ.BaseException) {
								// pass
							}},
						)
						ϒv = λ.Cal(ϒget, ϒsrc)
						return λ.BlockExitNormally, nil
					}()
					if τmp2 == λ.BlockExitReturn {
						return τmp3
					}
				}
				return λ.None
			})
		ϒmerge_dicts = λ.NewFunction("merge_dicts",
			nil,
			0, true, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒa_dict λ.Object
					ϒdicts  = λargs[0]
					ϒk      λ.Object
					ϒmerged λ.Object
					ϒv      λ.Object
					τmp0    λ.Object
					τmp1    λ.Object
					τmp2    λ.Object
					τmp3    λ.Object
					τmp4    λ.Object
				)
				ϒmerged = λ.NewDictWithTable(map[λ.Object]λ.Object{})
				τmp0 = λ.Cal(λ.BuiltinIter, ϒdicts)
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒa_dict = τmp1
					τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒa_dict, "items", nil)))
					for {
						if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
							break
						}
						τmp4 = τmp3
						ϒk = λ.GetItem(τmp4, λ.NewInt(0))
						ϒv = λ.GetItem(τmp4, λ.NewInt(1))
						if λ.IsTrue(λ.NewBool(ϒv == λ.None)) {
							continue
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.Contains(ϒmerged, ϒk)); λ.IsTrue(λv) {
								return λv
							} else {
								return func() λ.Object {
									if λv := λ.Cal(λ.BuiltinIsInstance, ϒv, ϒcompat_str); !λ.IsTrue(λv) {
										return λv
									} else if λv := ϒv; !λ.IsTrue(λv) {
										return λv
									} else if λv := λ.Cal(λ.BuiltinIsInstance, λ.GetItem(ϒmerged, ϒk), ϒcompat_str); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.GetItem(ϒmerged, ϒk)))
									}
								}()
							}
						}()) {
							λ.SetItem(ϒmerged, ϒk, ϒv)
						}
					}
				}
				return ϒmerged
			})
		US_RATINGS = λ.NewDictWithTable(map[λ.Object]λ.Object{
			λ.NewStr("G"):     λ.NewInt(0),
			λ.NewStr("PG"):    λ.NewInt(10),
			λ.NewStr("PG-13"): λ.NewInt(13),
			λ.NewStr("R"):     λ.NewInt(16),
			λ.NewStr("NC"):    λ.NewInt(18),
		})
		TV_PARENTAL_GUIDELINES = λ.NewDictWithTable(map[λ.Object]λ.Object{
			λ.NewStr("TV-Y"):  λ.NewInt(0),
			λ.NewStr("TV-Y7"): λ.NewInt(7),
			λ.NewStr("TV-G"):  λ.NewInt(0),
			λ.NewStr("TV-PG"): λ.NewInt(0),
			λ.NewStr("TV-14"): λ.NewInt(14),
			λ.NewStr("TV-MA"): λ.NewInt(17),
		})
		ϒparse_age_limit = λ.NewFunction("parse_age_limit",
			[]λ.Param{
				{Name: "s"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒm λ.Object
					ϒs = λargs[0]
				)
				if λ.IsTrue(λ.Eq(λ.Cal(λ.TypeType, ϒs), λ.IntType)) {
					return func() λ.Object {
						if λ.IsTrue(func() λ.Object {
							var λl λ.Object = λ.NewInt(0)
							var λr λ.Object = ϒs
							if !λ.IsTrue(λ.Le(λl, λr)) {
								return λ.False
							}
							λl = λr
							λr = λ.NewInt(21)
							if !λ.IsTrue(λ.Le(λl, λr)) {
								return λ.False
							}
							return λ.True
						}()) {
							return ϒs
						} else {
							return λ.None
						}
					}()
				}
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒs, ϒcompat_basestring)))) {
					return λ.None
				}
				ϒm = λ.Cal(Ωre.ϒmatch, λ.NewStr("^(?P<age>\\d{1,2})\\+?$"), ϒs)
				if λ.IsTrue(ϒm) {
					return λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewStr("age")))
				}
				if λ.IsTrue(λ.NewBool(λ.Contains(US_RATINGS, ϒs))) {
					return λ.GetItem(US_RATINGS, ϒs)
				}
				ϒm = λ.Cal(Ωre.ϒmatch, λ.Mod(λ.NewStr("^TV[_-]?(%s)$"), λ.Cal(λ.GetAttr(λ.NewStr("|"), "join", nil), λ.Cal(λ.NewFunction("<generator>",
					nil,
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
							var (
								ϒk   λ.Object
								τmp0 λ.Object
								τmp1 λ.Object
							)
							τmp0 = λ.Cal(λ.BuiltinIter, TV_PARENTAL_GUIDELINES)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒk = τmp1
								λgy.Yield(λ.GetItem(ϒk, λ.NewSlice(λ.NewInt(3), λ.None, λ.None)))
							}
							return λ.None
						})
					})))), ϒs)
				if λ.IsTrue(ϒm) {
					return λ.GetItem(TV_PARENTAL_GUIDELINES, λ.Add(λ.NewStr("TV-"), λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(1))))
				}
				return λ.None
			})
		ϒstrip_jsonp = λ.NewFunction("strip_jsonp",
			[]λ.Param{
				{Name: "code"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒcode = λargs[0]
				)
				return λ.Cal(Ωre.ϒsub, λ.NewStr("(?sx)^\n            (?:window\\.)?(?P<func_name>[a-zA-Z0-9_.$]*)\n            (?:\\s*&&\\s*(?P=func_name))?\n            \\s*\\(\\s*(?P<callback_data>.*)\\);?\n            \\s*?(?://[^\\n]*)*$"), λ.NewStr("\\g<callback_data>"), ϒcode)
			})
		ϒjs_to_json = λ.NewFunction("js_to_json",
			[]λ.Param{
				{Name: "code"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					COMMENT_RE    λ.Object
					INTEGER_TABLE λ.Object
					SKIP_RE       λ.Object
					ϒcode         = λargs[0]
					ϒfix_kv       λ.Object
				)
				COMMENT_RE = λ.NewStr("/\\*(?:(?!\\*/).)*?\\*/|//[^\\n]*")
				SKIP_RE = λ.Call(λ.GetAttr(λ.NewStr("\\s*(?:{comment})?\\s*"), "format", nil), nil, λ.KWArgs{
					{Name: "comment", Value: COMMENT_RE},
				})
				INTEGER_TABLE = λ.NewTuple(
					λ.NewTuple(
						λ.Call(λ.GetAttr(λ.NewStr("(?s)^(0[xX][0-9a-fA-F]+){skip}:?$"), "format", nil), nil, λ.KWArgs{
							{Name: "skip", Value: SKIP_RE},
						}),
						λ.NewInt(16),
					),
					λ.NewTuple(
						λ.Call(λ.GetAttr(λ.NewStr("(?s)^(0+[0-7]+){skip}:?$"), "format", nil), nil, λ.KWArgs{
							{Name: "skip", Value: SKIP_RE},
						}),
						λ.NewInt(8),
					),
				)
				ϒfix_kv = λ.NewFunction("fix_kv",
					[]λ.Param{
						{Name: "m"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒbase  λ.Object
							ϒi     λ.Object
							ϒim    λ.Object
							ϒm     = λargs[0]
							ϒregex λ.Object
							ϒv     λ.Object
							τmp0   λ.Object
							τmp1   λ.Object
							τmp2   λ.Object
						)
						ϒv = λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(0))
						if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
							λ.NewStr("true"),
							λ.NewStr("false"),
							λ.NewStr("null"),
						), ϒv))) {
							return ϒv
						} else {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒv, "startswith", nil), λ.NewStr("/*")); λ.IsTrue(λv) {
									return λv
								} else if λv := λ.Cal(λ.GetAttr(ϒv, "startswith", nil), λ.NewStr("//")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(ϒv, λ.NewStr(","))
								}
							}()) {
								return λ.NewStr("")
							}
						}
						if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
							λ.NewStr("'"),
							λ.NewStr("\""),
						), λ.GetItem(ϒv, λ.NewInt(0))))) {
							ϒv = λ.Cal(Ωre.ϒsub, λ.NewStr("(?s)\\\\.|\""), λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "m"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒm = λargs[0]
									)
									return λ.Cal(λ.GetAttr(λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("\""):   λ.NewStr("\\\""),
										λ.NewStr("\\'"):  λ.NewStr("'"),
										λ.NewStr("\\\n"): λ.NewStr(""),
										λ.NewStr("\\x"):  λ.NewStr("\\u00"),
									}), "get", nil), λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(0)), λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(0)))
								}), λ.GetItem(ϒv, λ.NewSlice(λ.NewInt(1), λ.Neg(λ.NewInt(1)), λ.None)))
						}
						τmp0 = λ.Cal(λ.BuiltinIter, INTEGER_TABLE)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒregex = λ.GetItem(τmp2, λ.NewInt(0))
							ϒbase = λ.GetItem(τmp2, λ.NewInt(1))
							ϒim = λ.Cal(Ωre.ϒmatch, ϒregex, ϒv)
							if λ.IsTrue(ϒim) {
								ϒi = λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒim, "group", nil), λ.NewInt(1)), ϒbase)
								return func() λ.Object {
									if λ.IsTrue(λ.Cal(λ.GetAttr(ϒv, "endswith", nil), λ.NewStr(":"))) {
										return λ.Mod(λ.NewStr("\"%d\":"), ϒi)
									} else {
										return λ.Mod(λ.NewStr("%d"), ϒi)
									}
								}()
							}
						}
						return λ.Mod(λ.NewStr("\"%s\""), ϒv)
					})
				return λ.Cal(Ωre.ϒsub, λ.Call(λ.GetAttr(λ.NewStr("(?sx)\n        \"(?:[^\"\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^\"\\\\]*\"|\n        '(?:[^'\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^'\\\\]*'|\n        {comment}|,(?={skip}[\\]}}])|\n        (?:(?<![0-9])[eE]|[a-df-zA-DF-Z_])[.a-zA-Z_0-9]*|\n        \\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{skip}:)?|\n        [0-9]+(?={skip}:)\n        "), "format", nil), nil, λ.KWArgs{
					{Name: "comment", Value: COMMENT_RE},
					{Name: "skip", Value: SKIP_RE},
				}), ϒfix_kv, ϒcode)
			})
		ϒqualities = λ.NewFunction("qualities",
			[]λ.Param{
				{Name: "quality_ids"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒq           λ.Object
					ϒquality_ids = λargs[0]
				)
				λ.NewStr(" Get a numeric quality value out of a list of possible values ")
				ϒq = λ.NewFunction("q",
					[]λ.Param{
						{Name: "qid"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒqid = λargs[0]
							τmp0 λ.Object
							τmp1 λ.Object
						)
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
									λexit, λret = λ.BlockExitReturn, λ.Neg(λ.NewInt(1))
									return
								}},
							)
							λexit, λret = λ.BlockExitReturn, λ.Cal(λ.GetAttr(ϒquality_ids, "index", nil), ϒqid)
							return
							return λ.BlockExitNormally, nil
						}()
						if τmp0 == λ.BlockExitReturn {
							return τmp1
						}
						return λ.None
					})
				return ϒq
			})
		DEFAULT_OUTTMPL = λ.NewStr("%(title)s-%(id)s.%(ext)s")
		ϒlimit_length = λ.NewFunction("limit_length",
			[]λ.Param{
				{Name: "s"},
				{Name: "length"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ELLIPSES λ.Object
					ϒlength  = λargs[1]
					ϒs       = λargs[0]
				)
				λ.NewStr(" Add ellipses to overly long strings ")
				if λ.IsTrue(λ.NewBool(ϒs == λ.None)) {
					return λ.None
				}
				ELLIPSES = λ.NewStr("...")
				if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒs), ϒlength)) {
					return λ.Add(λ.GetItem(ϒs, λ.NewSlice(λ.None, λ.Sub(ϒlength, λ.Cal(λ.BuiltinLen, ELLIPSES)), λ.None)), ELLIPSES)
				}
				return ϒs
			})
		ϒytdl_is_updateable = λ.NewFunction("ytdl_is_updateable",
			nil,
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				λ.NewStr(" Returns if youtube-dl can be updated with -U ")
				return λ.False
			})
		ϒerror_to_compat_str = λ.NewFunction("error_to_compat_str",
			[]λ.Param{
				{Name: "err"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒerr     = λargs[0]
					ϒerr_str λ.Object
				)
				ϒerr_str = λ.Cal(λ.StrType, ϒerr)
				if λ.IsTrue(λ.Lt(λ.GetItem(Ωsys.ϒversion_info, λ.NewInt(0)), λ.NewInt(3))) {
					ϒerr_str = λ.Cal(λ.GetAttr(ϒerr_str, "decode", nil), λ.Cal(ϒpreferredencoding))
				}
				return ϒerr_str
			})
		ϒmimetype2ext = λ.NewFunction("mimetype2ext",
			[]λ.Param{
				{Name: "mt"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒext λ.Object
					ϒmt  = λargs[0]
					ϒres λ.Object
					τmp0 λ.Object
				)
				if λ.IsTrue(λ.NewBool(ϒmt == λ.None)) {
					return λ.None
				}
				ϒext = λ.Cal(λ.GetAttr(λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("audio/mp4"):  λ.NewStr("m4a"),
					λ.NewStr("audio/mpeg"): λ.NewStr("mp3"),
				}), "get", nil), ϒmt)
				if λ.IsTrue(λ.NewBool(ϒext != λ.None)) {
					return ϒext
				}
				τmp0 = λ.Cal(λ.GetAttr(ϒmt, "rpartition", nil), λ.NewStr("/"))
				_ = λ.GetItem(τmp0, λ.NewInt(0))
				_ = λ.GetItem(τmp0, λ.NewInt(1))
				ϒres = λ.GetItem(τmp0, λ.NewInt(2))
				ϒres = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(λ.GetItem(λ.Cal(λ.GetAttr(ϒres, "split", nil), λ.NewStr(";")), λ.NewInt(0)), "strip", nil)), "lower", nil))
				return λ.Cal(λ.GetAttr(λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("3gpp"):              λ.NewStr("3gp"),
					λ.NewStr("smptett+xml"):       λ.NewStr("tt"),
					λ.NewStr("ttaf+xml"):          λ.NewStr("dfxp"),
					λ.NewStr("ttml+xml"):          λ.NewStr("ttml"),
					λ.NewStr("x-flv"):             λ.NewStr("flv"),
					λ.NewStr("x-mp4-fragmented"):  λ.NewStr("mp4"),
					λ.NewStr("x-ms-sami"):         λ.NewStr("sami"),
					λ.NewStr("x-ms-wmv"):          λ.NewStr("wmv"),
					λ.NewStr("mpegurl"):           λ.NewStr("m3u8"),
					λ.NewStr("x-mpegurl"):         λ.NewStr("m3u8"),
					λ.NewStr("vnd.apple.mpegurl"): λ.NewStr("m3u8"),
					λ.NewStr("dash+xml"):          λ.NewStr("mpd"),
					λ.NewStr("f4m+xml"):           λ.NewStr("f4m"),
					λ.NewStr("hds+xml"):           λ.NewStr("f4m"),
					λ.NewStr("vnd.ms-sstr+xml"):   λ.NewStr("ism"),
					λ.NewStr("quicktime"):         λ.NewStr("mov"),
					λ.NewStr("mp2t"):              λ.NewStr("ts"),
				}), "get", nil), ϒres, ϒres)
			})
		ϒparse_codecs = λ.NewFunction("parse_codecs",
			[]λ.Param{
				{Name: "codecs_str"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒacodec         λ.Object
					ϒcodec          λ.Object
					ϒcodecs_str     = λargs[0]
					ϒfull_codec     λ.Object
					ϒsplited_codecs λ.Object
					ϒvcodec         λ.Object
					τmp0            λ.Object
					τmp1            λ.Object
				)
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒcodecs_str))) {
					return λ.NewDictWithTable(map[λ.Object]λ.Object{})
				}
				ϒsplited_codecs = λ.Cal(λ.ListType, λ.Cal(λ.FilterIteratorType, λ.None, λ.Cal(λ.MapIteratorType, λ.NewFunction("<lambda>",
					[]λ.Param{
						{Name: "str"},
					},
					0, false, false,
					func(λargs []λ.Object) λ.Object {
						var (
							ϒstr = λargs[0]
						)
						return λ.Cal(λ.GetAttr(ϒstr, "strip", nil))
					}), λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒcodecs_str, "strip", nil)), "strip", nil), λ.NewStr(",")), "split", nil), λ.NewStr(",")))))
				τmp0 = λ.NewTuple(
					λ.None,
					λ.None,
				)
				ϒvcodec = λ.GetItem(τmp0, λ.NewInt(0))
				ϒacodec = λ.GetItem(τmp0, λ.NewInt(1))
				τmp0 = λ.Cal(λ.BuiltinIter, ϒsplited_codecs)
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					ϒfull_codec = τmp1
					ϒcodec = λ.GetItem(λ.Cal(λ.GetAttr(ϒfull_codec, "split", nil), λ.NewStr(".")), λ.NewInt(0))
					if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
						λ.NewStr("avc1"),
						λ.NewStr("avc2"),
						λ.NewStr("avc3"),
						λ.NewStr("avc4"),
						λ.NewStr("vp9"),
						λ.NewStr("vp8"),
						λ.NewStr("hev1"),
						λ.NewStr("hev2"),
						λ.NewStr("h263"),
						λ.NewStr("h264"),
						λ.NewStr("mp4v"),
						λ.NewStr("hvc1"),
						λ.NewStr("av01"),
						λ.NewStr("theora"),
					), ϒcodec))) {
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒvcodec))) {
							ϒvcodec = ϒfull_codec
						}
					} else {
						if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
							λ.NewStr("mp4a"),
							λ.NewStr("opus"),
							λ.NewStr("vorbis"),
							λ.NewStr("mp3"),
							λ.NewStr("aac"),
							λ.NewStr("ac-3"),
							λ.NewStr("ec-3"),
							λ.NewStr("eac3"),
							λ.NewStr("dtsc"),
							λ.NewStr("dtse"),
							λ.NewStr("dtsh"),
							λ.NewStr("dtsl"),
						), ϒcodec))) {
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒacodec))) {
								ϒacodec = ϒfull_codec
							}
						} else {
							λ.Cal(λ.None, λ.Mod(λ.NewStr("WARNING: Unknown codec %s\n"), ϒfull_codec), λ.None)
						}
					}
				}
				if λ.IsTrue(func() λ.Object {
					if λv := λ.NewBool(!λ.IsTrue(ϒvcodec)); !λ.IsTrue(λv) {
						return λv
					} else {
						return λ.NewBool(!λ.IsTrue(ϒacodec))
					}
				}()) {
					if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒsplited_codecs), λ.NewInt(2))) {
						return λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("vcodec"): λ.GetItem(ϒsplited_codecs, λ.NewInt(0)),
							λ.NewStr("acodec"): λ.GetItem(ϒsplited_codecs, λ.NewInt(1)),
						})
					}
				} else {
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("vcodec"): func() λ.Object {
							if λv := ϒvcodec; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("none")
							}
						}(),
						λ.NewStr("acodec"): func() λ.Object {
							if λv := ϒacodec; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("none")
							}
						}(),
					})
				}
				return λ.NewDictWithTable(map[λ.Object]λ.Object{})
			})
		ϒdetermine_protocol = λ.NewFunction("determine_protocol",
			[]λ.Param{
				{Name: "info_dict"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒext       λ.Object
					ϒinfo_dict = λargs[0]
					ϒprotocol  λ.Object
					ϒurl       λ.Object
				)
				ϒprotocol = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("protocol"))
				if λ.IsTrue(λ.NewBool(ϒprotocol != λ.None)) {
					return ϒprotocol
				}
				ϒurl = λ.GetItem(ϒinfo_dict, λ.NewStr("url"))
				if λ.IsTrue(λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("rtmp"))) {
					return λ.NewStr("rtmp")
				} else {
					if λ.IsTrue(λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("mms"))) {
						return λ.NewStr("mms")
					} else {
						if λ.IsTrue(λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("rtsp"))) {
							return λ.NewStr("rtsp")
						}
					}
				}
				ϒext = λ.Cal(ϒdetermine_ext, ϒurl)
				if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("m3u8"))) {
					return λ.NewStr("m3u8")
				} else {
					if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("f4m"))) {
						return λ.NewStr("f4m")
					}
				}
				return λ.GetAttr(λ.Cal(ϒcompat_urllib_parse_urlparse, ϒurl), "scheme", nil)
			})
		ISO639Utils = λ.Cal(λ.TypeType, λ.NewStr("ISO639Utils"), λ.NewTuple(λ.ObjectType), func() λ.Dict {
			var (
				ISO639Utils__lang_map  λ.Object
				ISO639Utils_long2short λ.Object
			)
			ISO639Utils__lang_map = λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("aa"): λ.NewStr("aar"),
				λ.NewStr("ab"): λ.NewStr("abk"),
				λ.NewStr("ae"): λ.NewStr("ave"),
				λ.NewStr("af"): λ.NewStr("afr"),
				λ.NewStr("ak"): λ.NewStr("aka"),
				λ.NewStr("am"): λ.NewStr("amh"),
				λ.NewStr("an"): λ.NewStr("arg"),
				λ.NewStr("ar"): λ.NewStr("ara"),
				λ.NewStr("as"): λ.NewStr("asm"),
				λ.NewStr("av"): λ.NewStr("ava"),
				λ.NewStr("ay"): λ.NewStr("aym"),
				λ.NewStr("az"): λ.NewStr("aze"),
				λ.NewStr("ba"): λ.NewStr("bak"),
				λ.NewStr("be"): λ.NewStr("bel"),
				λ.NewStr("bg"): λ.NewStr("bul"),
				λ.NewStr("bh"): λ.NewStr("bih"),
				λ.NewStr("bi"): λ.NewStr("bis"),
				λ.NewStr("bm"): λ.NewStr("bam"),
				λ.NewStr("bn"): λ.NewStr("ben"),
				λ.NewStr("bo"): λ.NewStr("bod"),
				λ.NewStr("br"): λ.NewStr("bre"),
				λ.NewStr("bs"): λ.NewStr("bos"),
				λ.NewStr("ca"): λ.NewStr("cat"),
				λ.NewStr("ce"): λ.NewStr("che"),
				λ.NewStr("ch"): λ.NewStr("cha"),
				λ.NewStr("co"): λ.NewStr("cos"),
				λ.NewStr("cr"): λ.NewStr("cre"),
				λ.NewStr("cs"): λ.NewStr("ces"),
				λ.NewStr("cu"): λ.NewStr("chu"),
				λ.NewStr("cv"): λ.NewStr("chv"),
				λ.NewStr("cy"): λ.NewStr("cym"),
				λ.NewStr("da"): λ.NewStr("dan"),
				λ.NewStr("de"): λ.NewStr("deu"),
				λ.NewStr("dv"): λ.NewStr("div"),
				λ.NewStr("dz"): λ.NewStr("dzo"),
				λ.NewStr("ee"): λ.NewStr("ewe"),
				λ.NewStr("el"): λ.NewStr("ell"),
				λ.NewStr("en"): λ.NewStr("eng"),
				λ.NewStr("eo"): λ.NewStr("epo"),
				λ.NewStr("es"): λ.NewStr("spa"),
				λ.NewStr("et"): λ.NewStr("est"),
				λ.NewStr("eu"): λ.NewStr("eus"),
				λ.NewStr("fa"): λ.NewStr("fas"),
				λ.NewStr("ff"): λ.NewStr("ful"),
				λ.NewStr("fi"): λ.NewStr("fin"),
				λ.NewStr("fj"): λ.NewStr("fij"),
				λ.NewStr("fo"): λ.NewStr("fao"),
				λ.NewStr("fr"): λ.NewStr("fra"),
				λ.NewStr("fy"): λ.NewStr("fry"),
				λ.NewStr("ga"): λ.NewStr("gle"),
				λ.NewStr("gd"): λ.NewStr("gla"),
				λ.NewStr("gl"): λ.NewStr("glg"),
				λ.NewStr("gn"): λ.NewStr("grn"),
				λ.NewStr("gu"): λ.NewStr("guj"),
				λ.NewStr("gv"): λ.NewStr("glv"),
				λ.NewStr("ha"): λ.NewStr("hau"),
				λ.NewStr("he"): λ.NewStr("heb"),
				λ.NewStr("iw"): λ.NewStr("heb"),
				λ.NewStr("hi"): λ.NewStr("hin"),
				λ.NewStr("ho"): λ.NewStr("hmo"),
				λ.NewStr("hr"): λ.NewStr("hrv"),
				λ.NewStr("ht"): λ.NewStr("hat"),
				λ.NewStr("hu"): λ.NewStr("hun"),
				λ.NewStr("hy"): λ.NewStr("hye"),
				λ.NewStr("hz"): λ.NewStr("her"),
				λ.NewStr("ia"): λ.NewStr("ina"),
				λ.NewStr("id"): λ.NewStr("ind"),
				λ.NewStr("in"): λ.NewStr("ind"),
				λ.NewStr("ie"): λ.NewStr("ile"),
				λ.NewStr("ig"): λ.NewStr("ibo"),
				λ.NewStr("ii"): λ.NewStr("iii"),
				λ.NewStr("ik"): λ.NewStr("ipk"),
				λ.NewStr("io"): λ.NewStr("ido"),
				λ.NewStr("is"): λ.NewStr("isl"),
				λ.NewStr("it"): λ.NewStr("ita"),
				λ.NewStr("iu"): λ.NewStr("iku"),
				λ.NewStr("ja"): λ.NewStr("jpn"),
				λ.NewStr("jv"): λ.NewStr("jav"),
				λ.NewStr("ka"): λ.NewStr("kat"),
				λ.NewStr("kg"): λ.NewStr("kon"),
				λ.NewStr("ki"): λ.NewStr("kik"),
				λ.NewStr("kj"): λ.NewStr("kua"),
				λ.NewStr("kk"): λ.NewStr("kaz"),
				λ.NewStr("kl"): λ.NewStr("kal"),
				λ.NewStr("km"): λ.NewStr("khm"),
				λ.NewStr("kn"): λ.NewStr("kan"),
				λ.NewStr("ko"): λ.NewStr("kor"),
				λ.NewStr("kr"): λ.NewStr("kau"),
				λ.NewStr("ks"): λ.NewStr("kas"),
				λ.NewStr("ku"): λ.NewStr("kur"),
				λ.NewStr("kv"): λ.NewStr("kom"),
				λ.NewStr("kw"): λ.NewStr("cor"),
				λ.NewStr("ky"): λ.NewStr("kir"),
				λ.NewStr("la"): λ.NewStr("lat"),
				λ.NewStr("lb"): λ.NewStr("ltz"),
				λ.NewStr("lg"): λ.NewStr("lug"),
				λ.NewStr("li"): λ.NewStr("lim"),
				λ.NewStr("ln"): λ.NewStr("lin"),
				λ.NewStr("lo"): λ.NewStr("lao"),
				λ.NewStr("lt"): λ.NewStr("lit"),
				λ.NewStr("lu"): λ.NewStr("lub"),
				λ.NewStr("lv"): λ.NewStr("lav"),
				λ.NewStr("mg"): λ.NewStr("mlg"),
				λ.NewStr("mh"): λ.NewStr("mah"),
				λ.NewStr("mi"): λ.NewStr("mri"),
				λ.NewStr("mk"): λ.NewStr("mkd"),
				λ.NewStr("ml"): λ.NewStr("mal"),
				λ.NewStr("mn"): λ.NewStr("mon"),
				λ.NewStr("mr"): λ.NewStr("mar"),
				λ.NewStr("ms"): λ.NewStr("msa"),
				λ.NewStr("mt"): λ.NewStr("mlt"),
				λ.NewStr("my"): λ.NewStr("mya"),
				λ.NewStr("na"): λ.NewStr("nau"),
				λ.NewStr("nb"): λ.NewStr("nob"),
				λ.NewStr("nd"): λ.NewStr("nde"),
				λ.NewStr("ne"): λ.NewStr("nep"),
				λ.NewStr("ng"): λ.NewStr("ndo"),
				λ.NewStr("nl"): λ.NewStr("nld"),
				λ.NewStr("nn"): λ.NewStr("nno"),
				λ.NewStr("no"): λ.NewStr("nor"),
				λ.NewStr("nr"): λ.NewStr("nbl"),
				λ.NewStr("nv"): λ.NewStr("nav"),
				λ.NewStr("ny"): λ.NewStr("nya"),
				λ.NewStr("oc"): λ.NewStr("oci"),
				λ.NewStr("oj"): λ.NewStr("oji"),
				λ.NewStr("om"): λ.NewStr("orm"),
				λ.NewStr("or"): λ.NewStr("ori"),
				λ.NewStr("os"): λ.NewStr("oss"),
				λ.NewStr("pa"): λ.NewStr("pan"),
				λ.NewStr("pi"): λ.NewStr("pli"),
				λ.NewStr("pl"): λ.NewStr("pol"),
				λ.NewStr("ps"): λ.NewStr("pus"),
				λ.NewStr("pt"): λ.NewStr("por"),
				λ.NewStr("qu"): λ.NewStr("que"),
				λ.NewStr("rm"): λ.NewStr("roh"),
				λ.NewStr("rn"): λ.NewStr("run"),
				λ.NewStr("ro"): λ.NewStr("ron"),
				λ.NewStr("ru"): λ.NewStr("rus"),
				λ.NewStr("rw"): λ.NewStr("kin"),
				λ.NewStr("sa"): λ.NewStr("san"),
				λ.NewStr("sc"): λ.NewStr("srd"),
				λ.NewStr("sd"): λ.NewStr("snd"),
				λ.NewStr("se"): λ.NewStr("sme"),
				λ.NewStr("sg"): λ.NewStr("sag"),
				λ.NewStr("si"): λ.NewStr("sin"),
				λ.NewStr("sk"): λ.NewStr("slk"),
				λ.NewStr("sl"): λ.NewStr("slv"),
				λ.NewStr("sm"): λ.NewStr("smo"),
				λ.NewStr("sn"): λ.NewStr("sna"),
				λ.NewStr("so"): λ.NewStr("som"),
				λ.NewStr("sq"): λ.NewStr("sqi"),
				λ.NewStr("sr"): λ.NewStr("srp"),
				λ.NewStr("ss"): λ.NewStr("ssw"),
				λ.NewStr("st"): λ.NewStr("sot"),
				λ.NewStr("su"): λ.NewStr("sun"),
				λ.NewStr("sv"): λ.NewStr("swe"),
				λ.NewStr("sw"): λ.NewStr("swa"),
				λ.NewStr("ta"): λ.NewStr("tam"),
				λ.NewStr("te"): λ.NewStr("tel"),
				λ.NewStr("tg"): λ.NewStr("tgk"),
				λ.NewStr("th"): λ.NewStr("tha"),
				λ.NewStr("ti"): λ.NewStr("tir"),
				λ.NewStr("tk"): λ.NewStr("tuk"),
				λ.NewStr("tl"): λ.NewStr("tgl"),
				λ.NewStr("tn"): λ.NewStr("tsn"),
				λ.NewStr("to"): λ.NewStr("ton"),
				λ.NewStr("tr"): λ.NewStr("tur"),
				λ.NewStr("ts"): λ.NewStr("tso"),
				λ.NewStr("tt"): λ.NewStr("tat"),
				λ.NewStr("tw"): λ.NewStr("twi"),
				λ.NewStr("ty"): λ.NewStr("tah"),
				λ.NewStr("ug"): λ.NewStr("uig"),
				λ.NewStr("uk"): λ.NewStr("ukr"),
				λ.NewStr("ur"): λ.NewStr("urd"),
				λ.NewStr("uz"): λ.NewStr("uzb"),
				λ.NewStr("ve"): λ.NewStr("ven"),
				λ.NewStr("vi"): λ.NewStr("vie"),
				λ.NewStr("vo"): λ.NewStr("vol"),
				λ.NewStr("wa"): λ.NewStr("wln"),
				λ.NewStr("wo"): λ.NewStr("wol"),
				λ.NewStr("xh"): λ.NewStr("xho"),
				λ.NewStr("yi"): λ.NewStr("yid"),
				λ.NewStr("ji"): λ.NewStr("yid"),
				λ.NewStr("yo"): λ.NewStr("yor"),
				λ.NewStr("za"): λ.NewStr("zha"),
				λ.NewStr("zh"): λ.NewStr("zho"),
				λ.NewStr("zu"): λ.NewStr("zul"),
			})
			ISO639Utils_long2short = λ.NewFunction("long2short",
				[]λ.Param{
					{Name: "cls"},
					{Name: "code"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls        = λargs[0]
						ϒcode       = λargs[1]
						ϒlong_name  λ.Object
						ϒshort_name λ.Object
						τmp0        λ.Object
						τmp1        λ.Object
						τmp2        λ.Object
					)
					λ.NewStr("Convert language code from ISO 639-2/T to ISO 639-1")
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(λ.GetAttr(ϒcls, "_lang_map", nil), "items", nil)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒshort_name = λ.GetItem(τmp2, λ.NewInt(0))
						ϒlong_name = λ.GetItem(τmp2, λ.NewInt(1))
						if λ.IsTrue(λ.Eq(ϒlong_name, ϒcode)) {
							return ϒshort_name
						}
					}
					return λ.None
				})
			ISO639Utils_long2short = λ.Cal(λ.ClassMethodType, ISO639Utils_long2short)
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_lang_map"):  ISO639Utils__lang_map,
				λ.NewStr("long2short"): ISO639Utils_long2short,
			})
		}())
		GeoUtils = λ.Cal(λ.TypeType, λ.NewStr("GeoUtils"), λ.NewTuple(λ.ObjectType), func() λ.Dict {
			var (
				GeoUtils__country_ip_map λ.Object
				GeoUtils_random_ipv4     λ.Object
			)
			GeoUtils__country_ip_map = λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("AD"): λ.NewStr("85.94.160.0/19"),
				λ.NewStr("AE"): λ.NewStr("94.200.0.0/13"),
				λ.NewStr("AF"): λ.NewStr("149.54.0.0/17"),
				λ.NewStr("AG"): λ.NewStr("209.59.64.0/18"),
				λ.NewStr("AI"): λ.NewStr("204.14.248.0/21"),
				λ.NewStr("AL"): λ.NewStr("46.99.0.0/16"),
				λ.NewStr("AM"): λ.NewStr("46.70.0.0/15"),
				λ.NewStr("AO"): λ.NewStr("105.168.0.0/13"),
				λ.NewStr("AP"): λ.NewStr("159.117.192.0/21"),
				λ.NewStr("AR"): λ.NewStr("181.0.0.0/12"),
				λ.NewStr("AS"): λ.NewStr("202.70.112.0/20"),
				λ.NewStr("AT"): λ.NewStr("84.112.0.0/13"),
				λ.NewStr("AU"): λ.NewStr("1.128.0.0/11"),
				λ.NewStr("AW"): λ.NewStr("181.41.0.0/18"),
				λ.NewStr("AZ"): λ.NewStr("5.191.0.0/16"),
				λ.NewStr("BA"): λ.NewStr("31.176.128.0/17"),
				λ.NewStr("BB"): λ.NewStr("65.48.128.0/17"),
				λ.NewStr("BD"): λ.NewStr("114.130.0.0/16"),
				λ.NewStr("BE"): λ.NewStr("57.0.0.0/8"),
				λ.NewStr("BF"): λ.NewStr("129.45.128.0/17"),
				λ.NewStr("BG"): λ.NewStr("95.42.0.0/15"),
				λ.NewStr("BH"): λ.NewStr("37.131.0.0/17"),
				λ.NewStr("BI"): λ.NewStr("154.117.192.0/18"),
				λ.NewStr("BJ"): λ.NewStr("137.255.0.0/16"),
				λ.NewStr("BL"): λ.NewStr("192.131.134.0/24"),
				λ.NewStr("BM"): λ.NewStr("196.12.64.0/18"),
				λ.NewStr("BN"): λ.NewStr("156.31.0.0/16"),
				λ.NewStr("BO"): λ.NewStr("161.56.0.0/16"),
				λ.NewStr("BQ"): λ.NewStr("161.0.80.0/20"),
				λ.NewStr("BR"): λ.NewStr("152.240.0.0/12"),
				λ.NewStr("BS"): λ.NewStr("24.51.64.0/18"),
				λ.NewStr("BT"): λ.NewStr("119.2.96.0/19"),
				λ.NewStr("BW"): λ.NewStr("168.167.0.0/16"),
				λ.NewStr("BY"): λ.NewStr("178.120.0.0/13"),
				λ.NewStr("BZ"): λ.NewStr("179.42.192.0/18"),
				λ.NewStr("CA"): λ.NewStr("99.224.0.0/11"),
				λ.NewStr("CD"): λ.NewStr("41.243.0.0/16"),
				λ.NewStr("CF"): λ.NewStr("196.32.200.0/21"),
				λ.NewStr("CG"): λ.NewStr("197.214.128.0/17"),
				λ.NewStr("CH"): λ.NewStr("85.0.0.0/13"),
				λ.NewStr("CI"): λ.NewStr("154.232.0.0/14"),
				λ.NewStr("CK"): λ.NewStr("202.65.32.0/19"),
				λ.NewStr("CL"): λ.NewStr("152.172.0.0/14"),
				λ.NewStr("CM"): λ.NewStr("165.210.0.0/15"),
				λ.NewStr("CN"): λ.NewStr("36.128.0.0/10"),
				λ.NewStr("CO"): λ.NewStr("181.240.0.0/12"),
				λ.NewStr("CR"): λ.NewStr("201.192.0.0/12"),
				λ.NewStr("CU"): λ.NewStr("152.206.0.0/15"),
				λ.NewStr("CV"): λ.NewStr("165.90.96.0/19"),
				λ.NewStr("CW"): λ.NewStr("190.88.128.0/17"),
				λ.NewStr("CY"): λ.NewStr("46.198.0.0/15"),
				λ.NewStr("CZ"): λ.NewStr("88.100.0.0/14"),
				λ.NewStr("DE"): λ.NewStr("53.0.0.0/8"),
				λ.NewStr("DJ"): λ.NewStr("197.241.0.0/17"),
				λ.NewStr("DK"): λ.NewStr("87.48.0.0/12"),
				λ.NewStr("DM"): λ.NewStr("192.243.48.0/20"),
				λ.NewStr("DO"): λ.NewStr("152.166.0.0/15"),
				λ.NewStr("DZ"): λ.NewStr("41.96.0.0/12"),
				λ.NewStr("EC"): λ.NewStr("186.68.0.0/15"),
				λ.NewStr("EE"): λ.NewStr("90.190.0.0/15"),
				λ.NewStr("EG"): λ.NewStr("156.160.0.0/11"),
				λ.NewStr("ER"): λ.NewStr("196.200.96.0/20"),
				λ.NewStr("ES"): λ.NewStr("88.0.0.0/11"),
				λ.NewStr("ET"): λ.NewStr("196.188.0.0/14"),
				λ.NewStr("EU"): λ.NewStr("2.16.0.0/13"),
				λ.NewStr("FI"): λ.NewStr("91.152.0.0/13"),
				λ.NewStr("FJ"): λ.NewStr("144.120.0.0/16"),
				λ.NewStr("FM"): λ.NewStr("119.252.112.0/20"),
				λ.NewStr("FO"): λ.NewStr("88.85.32.0/19"),
				λ.NewStr("FR"): λ.NewStr("90.0.0.0/9"),
				λ.NewStr("GA"): λ.NewStr("41.158.0.0/15"),
				λ.NewStr("GB"): λ.NewStr("25.0.0.0/8"),
				λ.NewStr("GD"): λ.NewStr("74.122.88.0/21"),
				λ.NewStr("GE"): λ.NewStr("31.146.0.0/16"),
				λ.NewStr("GF"): λ.NewStr("161.22.64.0/18"),
				λ.NewStr("GG"): λ.NewStr("62.68.160.0/19"),
				λ.NewStr("GH"): λ.NewStr("45.208.0.0/14"),
				λ.NewStr("GI"): λ.NewStr("85.115.128.0/19"),
				λ.NewStr("GL"): λ.NewStr("88.83.0.0/19"),
				λ.NewStr("GM"): λ.NewStr("160.182.0.0/15"),
				λ.NewStr("GN"): λ.NewStr("197.149.192.0/18"),
				λ.NewStr("GP"): λ.NewStr("104.250.0.0/19"),
				λ.NewStr("GQ"): λ.NewStr("105.235.224.0/20"),
				λ.NewStr("GR"): λ.NewStr("94.64.0.0/13"),
				λ.NewStr("GT"): λ.NewStr("168.234.0.0/16"),
				λ.NewStr("GU"): λ.NewStr("168.123.0.0/16"),
				λ.NewStr("GW"): λ.NewStr("197.214.80.0/20"),
				λ.NewStr("GY"): λ.NewStr("181.41.64.0/18"),
				λ.NewStr("HK"): λ.NewStr("113.252.0.0/14"),
				λ.NewStr("HN"): λ.NewStr("181.210.0.0/16"),
				λ.NewStr("HR"): λ.NewStr("93.136.0.0/13"),
				λ.NewStr("HT"): λ.NewStr("148.102.128.0/17"),
				λ.NewStr("HU"): λ.NewStr("84.0.0.0/14"),
				λ.NewStr("ID"): λ.NewStr("39.192.0.0/10"),
				λ.NewStr("IE"): λ.NewStr("87.32.0.0/12"),
				λ.NewStr("IL"): λ.NewStr("79.176.0.0/13"),
				λ.NewStr("IM"): λ.NewStr("5.62.80.0/20"),
				λ.NewStr("IN"): λ.NewStr("117.192.0.0/10"),
				λ.NewStr("IO"): λ.NewStr("203.83.48.0/21"),
				λ.NewStr("IQ"): λ.NewStr("37.236.0.0/14"),
				λ.NewStr("IR"): λ.NewStr("2.176.0.0/12"),
				λ.NewStr("IS"): λ.NewStr("82.221.0.0/16"),
				λ.NewStr("IT"): λ.NewStr("79.0.0.0/10"),
				λ.NewStr("JE"): λ.NewStr("87.244.64.0/18"),
				λ.NewStr("JM"): λ.NewStr("72.27.0.0/17"),
				λ.NewStr("JO"): λ.NewStr("176.29.0.0/16"),
				λ.NewStr("JP"): λ.NewStr("126.0.0.0/8"),
				λ.NewStr("KE"): λ.NewStr("105.48.0.0/12"),
				λ.NewStr("KG"): λ.NewStr("158.181.128.0/17"),
				λ.NewStr("KH"): λ.NewStr("36.37.128.0/17"),
				λ.NewStr("KI"): λ.NewStr("103.25.140.0/22"),
				λ.NewStr("KM"): λ.NewStr("197.255.224.0/20"),
				λ.NewStr("KN"): λ.NewStr("198.32.32.0/19"),
				λ.NewStr("KP"): λ.NewStr("175.45.176.0/22"),
				λ.NewStr("KR"): λ.NewStr("175.192.0.0/10"),
				λ.NewStr("KW"): λ.NewStr("37.36.0.0/14"),
				λ.NewStr("KY"): λ.NewStr("64.96.0.0/15"),
				λ.NewStr("KZ"): λ.NewStr("2.72.0.0/13"),
				λ.NewStr("LA"): λ.NewStr("115.84.64.0/18"),
				λ.NewStr("LB"): λ.NewStr("178.135.0.0/16"),
				λ.NewStr("LC"): λ.NewStr("192.147.231.0/24"),
				λ.NewStr("LI"): λ.NewStr("82.117.0.0/19"),
				λ.NewStr("LK"): λ.NewStr("112.134.0.0/15"),
				λ.NewStr("LR"): λ.NewStr("41.86.0.0/19"),
				λ.NewStr("LS"): λ.NewStr("129.232.0.0/17"),
				λ.NewStr("LT"): λ.NewStr("78.56.0.0/13"),
				λ.NewStr("LU"): λ.NewStr("188.42.0.0/16"),
				λ.NewStr("LV"): λ.NewStr("46.109.0.0/16"),
				λ.NewStr("LY"): λ.NewStr("41.252.0.0/14"),
				λ.NewStr("MA"): λ.NewStr("105.128.0.0/11"),
				λ.NewStr("MC"): λ.NewStr("88.209.64.0/18"),
				λ.NewStr("MD"): λ.NewStr("37.246.0.0/16"),
				λ.NewStr("ME"): λ.NewStr("178.175.0.0/17"),
				λ.NewStr("MF"): λ.NewStr("74.112.232.0/21"),
				λ.NewStr("MG"): λ.NewStr("154.126.0.0/17"),
				λ.NewStr("MH"): λ.NewStr("117.103.88.0/21"),
				λ.NewStr("MK"): λ.NewStr("77.28.0.0/15"),
				λ.NewStr("ML"): λ.NewStr("154.118.128.0/18"),
				λ.NewStr("MM"): λ.NewStr("37.111.0.0/17"),
				λ.NewStr("MN"): λ.NewStr("49.0.128.0/17"),
				λ.NewStr("MO"): λ.NewStr("60.246.0.0/16"),
				λ.NewStr("MP"): λ.NewStr("202.88.64.0/20"),
				λ.NewStr("MQ"): λ.NewStr("109.203.224.0/19"),
				λ.NewStr("MR"): λ.NewStr("41.188.64.0/18"),
				λ.NewStr("MS"): λ.NewStr("208.90.112.0/22"),
				λ.NewStr("MT"): λ.NewStr("46.11.0.0/16"),
				λ.NewStr("MU"): λ.NewStr("105.16.0.0/12"),
				λ.NewStr("MV"): λ.NewStr("27.114.128.0/18"),
				λ.NewStr("MW"): λ.NewStr("105.234.0.0/16"),
				λ.NewStr("MX"): λ.NewStr("187.192.0.0/11"),
				λ.NewStr("MY"): λ.NewStr("175.136.0.0/13"),
				λ.NewStr("MZ"): λ.NewStr("197.218.0.0/15"),
				λ.NewStr("NA"): λ.NewStr("41.182.0.0/16"),
				λ.NewStr("NC"): λ.NewStr("101.101.0.0/18"),
				λ.NewStr("NE"): λ.NewStr("197.214.0.0/18"),
				λ.NewStr("NF"): λ.NewStr("203.17.240.0/22"),
				λ.NewStr("NG"): λ.NewStr("105.112.0.0/12"),
				λ.NewStr("NI"): λ.NewStr("186.76.0.0/15"),
				λ.NewStr("NL"): λ.NewStr("145.96.0.0/11"),
				λ.NewStr("NO"): λ.NewStr("84.208.0.0/13"),
				λ.NewStr("NP"): λ.NewStr("36.252.0.0/15"),
				λ.NewStr("NR"): λ.NewStr("203.98.224.0/19"),
				λ.NewStr("NU"): λ.NewStr("49.156.48.0/22"),
				λ.NewStr("NZ"): λ.NewStr("49.224.0.0/14"),
				λ.NewStr("OM"): λ.NewStr("5.36.0.0/15"),
				λ.NewStr("PA"): λ.NewStr("186.72.0.0/15"),
				λ.NewStr("PE"): λ.NewStr("186.160.0.0/14"),
				λ.NewStr("PF"): λ.NewStr("123.50.64.0/18"),
				λ.NewStr("PG"): λ.NewStr("124.240.192.0/19"),
				λ.NewStr("PH"): λ.NewStr("49.144.0.0/13"),
				λ.NewStr("PK"): λ.NewStr("39.32.0.0/11"),
				λ.NewStr("PL"): λ.NewStr("83.0.0.0/11"),
				λ.NewStr("PM"): λ.NewStr("70.36.0.0/20"),
				λ.NewStr("PR"): λ.NewStr("66.50.0.0/16"),
				λ.NewStr("PS"): λ.NewStr("188.161.0.0/16"),
				λ.NewStr("PT"): λ.NewStr("85.240.0.0/13"),
				λ.NewStr("PW"): λ.NewStr("202.124.224.0/20"),
				λ.NewStr("PY"): λ.NewStr("181.120.0.0/14"),
				λ.NewStr("QA"): λ.NewStr("37.210.0.0/15"),
				λ.NewStr("RE"): λ.NewStr("139.26.0.0/16"),
				λ.NewStr("RO"): λ.NewStr("79.112.0.0/13"),
				λ.NewStr("RS"): λ.NewStr("178.220.0.0/14"),
				λ.NewStr("RU"): λ.NewStr("5.136.0.0/13"),
				λ.NewStr("RW"): λ.NewStr("105.178.0.0/15"),
				λ.NewStr("SA"): λ.NewStr("188.48.0.0/13"),
				λ.NewStr("SB"): λ.NewStr("202.1.160.0/19"),
				λ.NewStr("SC"): λ.NewStr("154.192.0.0/11"),
				λ.NewStr("SD"): λ.NewStr("154.96.0.0/13"),
				λ.NewStr("SE"): λ.NewStr("78.64.0.0/12"),
				λ.NewStr("SG"): λ.NewStr("152.56.0.0/14"),
				λ.NewStr("SI"): λ.NewStr("188.196.0.0/14"),
				λ.NewStr("SK"): λ.NewStr("78.98.0.0/15"),
				λ.NewStr("SL"): λ.NewStr("197.215.0.0/17"),
				λ.NewStr("SM"): λ.NewStr("89.186.32.0/19"),
				λ.NewStr("SN"): λ.NewStr("41.82.0.0/15"),
				λ.NewStr("SO"): λ.NewStr("197.220.64.0/19"),
				λ.NewStr("SR"): λ.NewStr("186.179.128.0/17"),
				λ.NewStr("SS"): λ.NewStr("105.235.208.0/21"),
				λ.NewStr("ST"): λ.NewStr("197.159.160.0/19"),
				λ.NewStr("SV"): λ.NewStr("168.243.0.0/16"),
				λ.NewStr("SX"): λ.NewStr("190.102.0.0/20"),
				λ.NewStr("SY"): λ.NewStr("5.0.0.0/16"),
				λ.NewStr("SZ"): λ.NewStr("41.84.224.0/19"),
				λ.NewStr("TC"): λ.NewStr("65.255.48.0/20"),
				λ.NewStr("TD"): λ.NewStr("154.68.128.0/19"),
				λ.NewStr("TG"): λ.NewStr("196.168.0.0/14"),
				λ.NewStr("TH"): λ.NewStr("171.96.0.0/13"),
				λ.NewStr("TJ"): λ.NewStr("85.9.128.0/18"),
				λ.NewStr("TK"): λ.NewStr("27.96.24.0/21"),
				λ.NewStr("TL"): λ.NewStr("180.189.160.0/20"),
				λ.NewStr("TM"): λ.NewStr("95.85.96.0/19"),
				λ.NewStr("TN"): λ.NewStr("197.0.0.0/11"),
				λ.NewStr("TO"): λ.NewStr("175.176.144.0/21"),
				λ.NewStr("TR"): λ.NewStr("78.160.0.0/11"),
				λ.NewStr("TT"): λ.NewStr("186.44.0.0/15"),
				λ.NewStr("TV"): λ.NewStr("202.2.96.0/19"),
				λ.NewStr("TW"): λ.NewStr("120.96.0.0/11"),
				λ.NewStr("TZ"): λ.NewStr("156.156.0.0/14"),
				λ.NewStr("UA"): λ.NewStr("93.72.0.0/13"),
				λ.NewStr("UG"): λ.NewStr("154.224.0.0/13"),
				λ.NewStr("US"): λ.NewStr("3.0.0.0/8"),
				λ.NewStr("UY"): λ.NewStr("167.56.0.0/13"),
				λ.NewStr("UZ"): λ.NewStr("82.215.64.0/18"),
				λ.NewStr("VA"): λ.NewStr("212.77.0.0/19"),
				λ.NewStr("VC"): λ.NewStr("24.92.144.0/20"),
				λ.NewStr("VE"): λ.NewStr("186.88.0.0/13"),
				λ.NewStr("VG"): λ.NewStr("172.103.64.0/18"),
				λ.NewStr("VI"): λ.NewStr("146.226.0.0/16"),
				λ.NewStr("VN"): λ.NewStr("14.160.0.0/11"),
				λ.NewStr("VU"): λ.NewStr("202.80.32.0/20"),
				λ.NewStr("WF"): λ.NewStr("117.20.32.0/21"),
				λ.NewStr("WS"): λ.NewStr("202.4.32.0/19"),
				λ.NewStr("YE"): λ.NewStr("134.35.0.0/16"),
				λ.NewStr("YT"): λ.NewStr("41.242.116.0/22"),
				λ.NewStr("ZA"): λ.NewStr("41.0.0.0/11"),
				λ.NewStr("ZM"): λ.NewStr("165.56.0.0/13"),
				λ.NewStr("ZW"): λ.NewStr("41.85.192.0/19"),
			})
			GeoUtils_random_ipv4 = λ.NewFunction("random_ipv4",
				[]λ.Param{
					{Name: "cls"},
					{Name: "code_or_block"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						RandomIPv4     λ.Object
						ϒblock         λ.Object
						ϒcls           = λargs[0]
						ϒcode_or_block = λargs[1]
					)
					if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒcode_or_block), λ.NewInt(2))) {
						ϒblock = λ.Cal(λ.GetAttr(λ.GetAttr(ϒcls, "_country_ip_map", nil), "get", nil), λ.Cal(λ.GetAttr(ϒcode_or_block, "upper", nil)))
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒblock))) {
							return λ.None
						}
					} else {
						ϒblock = ϒcode_or_block
					}
					RandomIPv4 = Ωnet.RandomIPv4
					return λ.Cal(RandomIPv4, ϒblock)
				})
			GeoUtils_random_ipv4 = λ.Cal(λ.ClassMethodType, GeoUtils_random_ipv4)
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_country_ip_map"): GeoUtils__country_ip_map,
				λ.NewStr("random_ipv4"):     GeoUtils_random_ipv4,
			})
		}())
		ϒencode_base_n = λ.NewFunction("encode_base_n",
			[]λ.Param{
				{Name: "num"},
				{Name: "n"},
				{Name: "table", Def: λ.None},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					FULL_TABLE λ.Object
					ϒn         = λargs[1]
					ϒnum       = λargs[0]
					ϒret       λ.Object
					ϒtable     = λargs[2]
				)
				FULL_TABLE = λ.NewStr("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
				if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒtable))) {
					ϒtable = λ.GetItem(FULL_TABLE, λ.NewSlice(λ.None, ϒn, λ.None))
				}
				if λ.IsTrue(λ.Gt(ϒn, λ.Cal(λ.BuiltinLen, ϒtable))) {
					panic(λ.Raise(λ.Cal(λ.ValueErrorType, λ.Mod(λ.NewStr("base %d exceeds table length %d"), λ.NewTuple(
						ϒn,
						λ.Cal(λ.BuiltinLen, ϒtable),
					)))))
				}
				if λ.IsTrue(λ.Eq(ϒnum, λ.NewInt(0))) {
					return λ.GetItem(ϒtable, λ.NewInt(0))
				}
				ϒret = λ.NewStr("")
				for λ.IsTrue(ϒnum) {
					ϒret = λ.Add(λ.GetItem(ϒtable, λ.Mod(ϒnum, ϒn)), ϒret)
					ϒnum = λ.FloorDiv(ϒnum, ϒn)
				}
				return ϒret
			})
		ϒparse_m3u8_attributes = λ.NewFunction("parse_m3u8_attributes",
			[]λ.Param{
				{Name: "attrib"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒattrib = λargs[0]
					ϒinfo   λ.Object
					ϒkey    λ.Object
					ϒval    λ.Object
					τmp0    λ.Object
					τmp1    λ.Object
					τmp2    λ.Object
				)
				ϒinfo = λ.NewDictWithTable(map[λ.Object]λ.Object{})
				τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.NewStr("(?P<key>[A-Z0-9-]+)=(?P<val>\"[^\"]+\"|[^\",]+)(?:,|$)"), ϒattrib))
				for {
					if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
						break
					}
					τmp2 = τmp1
					ϒkey = λ.GetItem(τmp2, λ.NewInt(0))
					ϒval = λ.GetItem(τmp2, λ.NewInt(1))
					if λ.IsTrue(λ.Cal(λ.GetAttr(ϒval, "startswith", nil), λ.NewStr("\""))) {
						ϒval = λ.GetItem(ϒval, λ.NewSlice(λ.NewInt(1), λ.Neg(λ.NewInt(1)), λ.None))
					}
					λ.SetItem(ϒinfo, ϒkey, ϒval)
				}
				return ϒinfo
			})
		ϒrandom_birthday = λ.NewFunction("random_birthday",
			[]λ.Param{
				{Name: "year_field"},
				{Name: "month_field"},
				{Name: "day_field"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒday_field   = λargs[2]
					ϒmonth_field = λargs[1]
					ϒyear_field  = λargs[0]
				)
				return λ.NewDictWithTable(map[λ.Object]λ.Object{
					ϒyear_field:  λ.NewStr("1987"),
					ϒmonth_field: λ.NewStr("12"),
					ϒday_field:   λ.NewStr("12"),
				})
			})
	})
}

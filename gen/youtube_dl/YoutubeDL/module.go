// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * YoutubeDL/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/YoutubeDL.py
 */

package YoutubeDL

import (
	Ωcollections "github.com/tenta-browser/go-video-downloader/gen/collections"
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωrandom "github.com/tenta-browser/go-video-downloader/gen/random"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωsocket "github.com/tenta-browser/go-video-downloader/gen/socket"
	Ωstring "github.com/tenta-browser/go-video-downloader/gen/string"
	Ωsys "github.com/tenta-browser/go-video-downloader/gen/sys"
	Ωtime "github.com/tenta-browser/go-video-downloader/gen/time"
	Ωerror "github.com/tenta-browser/go-video-downloader/gen/urllib/error"
	Ωcache "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/cache"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωextractor "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor"
	Ωopenload "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/openload"
	Ωpostprocessor "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/postprocessor"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	Cache                  λ.Object
	DEFAULT_OUTTMPL        λ.Object
	DownloadError          λ.Object
	ExtractorError         λ.Object
	FFmpegPostProcessor    λ.Object
	GeoRestrictedError     λ.Object
	MaxDownloadsReached    λ.Object
	PagedList              λ.Object
	PhantomJSwrapper       λ.Object
	PostProcessingError    λ.Object
	UnavailableVideoError  λ.Object
	YoutubeDL              λ.Object
	ϒascii_letters         λ.Object
	ϒcompat_basestring     λ.Object
	ϒcompat_http_client    λ.Object
	ϒcompat_kwargs         λ.Object
	ϒcompat_numeric_types  λ.Object
	ϒcompat_str            λ.Object
	ϒdetermine_ext         λ.Object
	ϒdetermine_protocol    λ.Object
	ϒerror_to_compat_str   λ.Object
	ϒexpand_path           λ.Object
	ϒgen_extractor_classes λ.Object
	ϒget_info_extractor    λ.Object
	ϒint_or_none           λ.Object
	ϒorderedSet            λ.Object
	ϒparse_filesize        λ.Object
	ϒpreferredencoding     λ.Object
	ϒsanitize_filename     λ.Object
	ϒsanitize_path         λ.Object
	ϒsanitize_url          λ.Object
	ϒsanitized_Request     λ.Object
	ϒstd_headers           λ.Object
	ϒstr_or_none           λ.Object
	ϒurl_basename          λ.Object
)

func init() {
	λ.InitModule(func() {
		ϒascii_letters = Ωstring.ϒascii_letters
		ϒcompat_basestring = Ωcompat.ϒcompat_basestring
		ϒcompat_http_client = Ωcompat.ϒcompat_http_client
		ϒcompat_kwargs = Ωcompat.ϒcompat_kwargs
		ϒcompat_numeric_types = Ωcompat.ϒcompat_numeric_types
		ϒcompat_str = Ωcompat.ϒcompat_str
		DEFAULT_OUTTMPL = Ωutils.DEFAULT_OUTTMPL
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ϒdetermine_protocol = Ωutils.ϒdetermine_protocol
		DownloadError = Ωutils.DownloadError
		ϒerror_to_compat_str = Ωutils.ϒerror_to_compat_str
		ϒexpand_path = Ωutils.ϒexpand_path
		ExtractorError = Ωutils.ExtractorError
		GeoRestrictedError = Ωutils.GeoRestrictedError
		ϒint_or_none = Ωutils.ϒint_or_none
		MaxDownloadsReached = Ωutils.MaxDownloadsReached
		ϒorderedSet = Ωutils.ϒorderedSet
		PagedList = Ωutils.PagedList
		ϒparse_filesize = Ωutils.ϒparse_filesize
		PostProcessingError = Ωutils.PostProcessingError
		ϒpreferredencoding = Ωutils.ϒpreferredencoding
		ϒsanitize_filename = Ωutils.ϒsanitize_filename
		ϒsanitize_path = Ωutils.ϒsanitize_path
		ϒsanitize_url = Ωutils.ϒsanitize_url
		ϒsanitized_Request = Ωutils.ϒsanitized_Request
		ϒstd_headers = Ωutils.ϒstd_headers
		ϒstr_or_none = Ωutils.ϒstr_or_none
		UnavailableVideoError = Ωutils.UnavailableVideoError
		ϒurl_basename = Ωutils.ϒurl_basename
		Cache = Ωcache.Cache
		ϒget_info_extractor = Ωextractor.ϒget_info_extractor
		ϒgen_extractor_classes = Ωextractor.ϒgen_extractor_classes
		PhantomJSwrapper = Ωopenload.PhantomJSwrapper
		FFmpegPostProcessor = Ωpostprocessor.FFmpegPostProcessor
		if λ.IsTrue(λ.Eq(λ.None, λ.NewStr("nt"))) {

		}
		YoutubeDL = λ.Cal(λ.TypeType, λ.NewStr("YoutubeDL"), λ.NewTuple(λ.ObjectType), func() λ.Dict {
			var (
				YoutubeDL__NUMERIC_FIELDS             λ.Object
				YoutubeDL___forced_printings          λ.Object
				YoutubeDL__bidi_workaround            λ.Object
				YoutubeDL__calc_cookies               λ.Object
				YoutubeDL__calc_headers               λ.Object
				YoutubeDL__default_format_spec        λ.Object
				YoutubeDL__ies                        λ.Object
				YoutubeDL__num_downloads              λ.Object
				YoutubeDL__screen_file                λ.Object
				YoutubeDL_add_default_extra_info      λ.Object
				YoutubeDL_add_default_info_extractors λ.Object
				YoutubeDL_add_extra_info              λ.Object
				YoutubeDL_add_info_extractor          λ.Object
				YoutubeDL_extract_info                λ.Object
				YoutubeDL_format_resolution           λ.Object
				YoutubeDL_get_info_extractor          λ.Object
				YoutubeDL_params                      λ.Object
				YoutubeDL_prepare_filename            λ.Object
				YoutubeDL_process_ie_result           λ.Object
				YoutubeDL_process_info                λ.Object
				YoutubeDL_process_subtitles           λ.Object
				YoutubeDL_process_video_result        λ.Object
				YoutubeDL_report_error                λ.Object
				YoutubeDL_report_warning              λ.Object
				YoutubeDL_to_screen                   λ.Object
				YoutubeDL_to_stderr                   λ.Object
				YoutubeDL_to_stdout                   λ.Object
				YoutubeDL_trouble                     λ.Object
			)
			YoutubeDL__NUMERIC_FIELDS = λ.Cal(λ.SetType, λ.NewTuple(
				λ.NewStr("width"),
				λ.NewStr("height"),
				λ.NewStr("tbr"),
				λ.NewStr("abr"),
				λ.NewStr("asr"),
				λ.NewStr("vbr"),
				λ.NewStr("fps"),
				λ.NewStr("filesize"),
				λ.NewStr("filesize_approx"),
				λ.NewStr("timestamp"),
				λ.NewStr("upload_year"),
				λ.NewStr("upload_month"),
				λ.NewStr("upload_day"),
				λ.NewStr("duration"),
				λ.NewStr("view_count"),
				λ.NewStr("like_count"),
				λ.NewStr("dislike_count"),
				λ.NewStr("repost_count"),
				λ.NewStr("average_rating"),
				λ.NewStr("comment_count"),
				λ.NewStr("age_limit"),
				λ.NewStr("start_time"),
				λ.NewStr("end_time"),
				λ.NewStr("chapter_number"),
				λ.NewStr("season_number"),
				λ.NewStr("episode_number"),
				λ.NewStr("track_number"),
				λ.NewStr("disc_number"),
				λ.NewStr("release_year"),
				λ.NewStr("playlist_index"),
			))
			YoutubeDL_params = λ.None
			YoutubeDL__ies = λ.NewList()
			YoutubeDL__num_downloads = λ.None
			YoutubeDL__screen_file = λ.None
			YoutubeDL_add_info_extractor = λ.NewFunction("add_info_extractor",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie   = λargs[1]
						ϒself = λargs[0]
					)
					λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_ies", nil), "append", nil), ϒie)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒie, λ.TypeType)))) {
						λ.SetItem(λ.GetAttr(ϒself, "_ies_instances", nil), λ.Cal(λ.GetAttr(ϒie, "ie_key", nil)), ϒie)
						λ.Cal(λ.GetAttr(ϒie, "set_downloader", nil), ϒself)
					}
					return λ.None
				})
			YoutubeDL_get_info_extractor = λ.NewFunction("get_info_extractor",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie_key"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie     λ.Object
						ϒie_key = λargs[1]
						ϒself   = λargs[0]
					)
					ϒie = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_ies_instances", nil), "get", nil), ϒie_key)
					if λ.IsTrue(λ.NewBool(ϒie == λ.None)) {
						ϒie = λ.Cal(λ.Cal(ϒget_info_extractor, ϒie_key))
						λ.Cal(λ.GetAttr(ϒself, "add_info_extractor", nil), ϒie)
					}
					return ϒie
				})
			YoutubeDL_add_default_info_extractors = λ.NewFunction("add_default_info_extractors",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie   λ.Object
						ϒself = λargs[0]
						τmp0  λ.Object
						τmp1  λ.Object
					)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(ϒgen_extractor_classes))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒie = τmp1
						λ.Cal(λ.GetAttr(ϒself, "add_info_extractor", nil), ϒie)
					}
					return λ.None
				})
			YoutubeDL__bidi_workaround = λ.NewFunction("_bidi_workaround",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒline_count λ.Object
						ϒmessage    = λargs[1]
						ϒres        λ.Object
						ϒself       = λargs[0]
					)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinHasAttr, ϒself, λ.NewStr("_output_channel"))))) {
						return ϒmessage
					}
					if !λ.IsTrue(λ.Cal(λ.BuiltinHasAttr, ϒself, λ.NewStr("_output_process"))) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒmessage, ϒcompat_str)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					ϒline_count = λ.Add(λ.Cal(λ.GetAttr(ϒmessage, "count", nil), λ.NewStr("\n")), λ.NewInt(1))
					λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_output_process", nil), "stdin", nil), "write", nil), λ.Cal(λ.GetAttr(λ.Add(ϒmessage, λ.NewStr("\n")), "encode", nil), λ.NewStr("utf-8")))
					λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_output_process", nil), "stdin", nil), "flush", nil))
					ϒres = λ.Cal(λ.GetAttr(λ.NewStr(""), "join", nil), λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, ϒline_count))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									_ = τmp1
									λgy.Yield(λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_output_channel", nil), "readline", nil)), "decode", nil), λ.NewStr("utf-8")))
								}
								return λ.None
							})
						})))
					return λ.GetItem(ϒres, λ.NewSlice(λ.None, λ.Neg(λ.Cal(λ.BuiltinLen, λ.NewStr("\n"))), λ.None))
				})
			YoutubeDL_to_screen = λ.NewFunction("to_screen",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
					{Name: "skip_eol", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmessage  = λargs[1]
						ϒself     = λargs[0]
						ϒskip_eol = λargs[2]
					)
					return λ.Call(λ.GetAttr(ϒself, "to_stdout", nil), λ.NewArgs(
						ϒmessage,
						ϒskip_eol,
					), λ.KWArgs{
						{Name: "check_quiet", Value: λ.True},
					})
				})
			YoutubeDL_to_stdout = λ.NewFunction("to_stdout",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
					{Name: "skip_eol", Def: λ.False},
					{Name: "check_quiet", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcheck_quiet = λargs[3]
						ϒmessage     = λargs[1]
						ϒoutput      λ.Object
						ϒself        = λargs[0]
						ϒskip_eol    = λargs[2]
						ϒterminator  λ.Object
					)
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("logger"))) {
						λ.Cal(λ.GetAttr(λ.GetItem(λ.GetAttr(ϒself, "params", nil), λ.NewStr("logger")), "debug", nil), ϒmessage)
					} else {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒcheck_quiet)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("quiet"), λ.False)))
							}
						}()) {
							ϒmessage = λ.Cal(λ.GetAttr(ϒself, "_bidi_workaround", nil), ϒmessage)
							ϒterminator = λ.GetItem(λ.NewList(
								λ.NewStr("\n"),
								λ.NewStr(""),
							), ϒskip_eol)
							ϒoutput = λ.Add(ϒmessage, ϒterminator)
							λ.Cal(λ.GetAttr(ϒself, "_write_string", nil), ϒoutput, λ.GetAttr(ϒself, "_screen_file", nil))
						}
					}
					return λ.None
				})
			YoutubeDL_to_stderr = λ.NewFunction("to_stderr",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmessage = λargs[1]
						ϒoutput  λ.Object
						ϒself    = λargs[0]
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒmessage, ϒcompat_str)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("logger"))) {
						λ.Cal(λ.GetAttr(λ.GetItem(λ.GetAttr(ϒself, "params", nil), λ.NewStr("logger")), "error", nil), ϒmessage)
					} else {
						ϒmessage = λ.Cal(λ.GetAttr(ϒself, "_bidi_workaround", nil), ϒmessage)
						ϒoutput = λ.Add(ϒmessage, λ.NewStr("\n"))
						λ.Cal(λ.GetAttr(ϒself, "_write_string", nil), ϒoutput, λ.GetAttr(ϒself, "_err_file", nil))
					}
					return λ.None
				})
			YoutubeDL_trouble = λ.NewFunction("trouble",
				[]λ.Param{
					{Name: "self"},
					{Name: "message", Def: λ.None},
					{Name: "tb", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒexc_info λ.Object
						ϒmessage  = λargs[1]
						ϒself     = λargs[0]
						ϒtb       = λargs[2]
						ϒtb_data  λ.Object
						τmp0      λ.Object
					)
					if λ.IsTrue(λ.NewBool(ϒmessage != λ.None)) {
						λ.Cal(λ.GetAttr(ϒself, "to_stderr", nil), ϒmessage)
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("verbose"))) {
						if λ.IsTrue(λ.NewBool(ϒtb == λ.None)) {
							if λ.IsTrue(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(0))) {
								ϒtb = λ.NewStr("")
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.BuiltinHasAttr, λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(1)), λ.NewStr("exc_info")); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.GetItem(λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(1)), "exc_info", nil), λ.NewInt(0))
									}
								}()) {
									τmp0 = λ.IAdd(ϒtb, λ.Cal(λ.GetAttr(λ.NewStr(""), "join", nil), λ.Cal(λ.GetAttr(λ.None, "format_exception", nil), λ.Unpack(λ.AsStarred(λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(1)), "exc_info", nil)))...)))
									ϒtb = τmp0
								}
								τmp0 = λ.IAdd(ϒtb, λ.Cal(λ.None, λ.Cal(λ.GetAttr(λ.None, "format_exc", nil))))
								ϒtb = τmp0
							} else {
								ϒtb_data = λ.Cal(λ.GetAttr(λ.None, "format_list", nil), λ.Cal(λ.GetAttr(λ.None, "extract_stack", nil)))
								ϒtb = λ.Cal(λ.GetAttr(λ.NewStr(""), "join", nil), ϒtb_data)
							}
						}
						λ.Cal(λ.GetAttr(ϒself, "to_stderr", nil), ϒtb)
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("ignoreerrors"), λ.False)))) {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(0)); !λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Cal(λ.BuiltinHasAttr, λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(1)), λ.NewStr("exc_info")); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.GetItem(λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(1)), "exc_info", nil), λ.NewInt(0))
							}
						}()) {
							ϒexc_info = λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(1)), "exc_info", nil)
						} else {
							ϒexc_info = λ.Cal(Ωsys.ϒexc_info)
						}
						panic(λ.Raise(λ.Cal(DownloadError, ϒmessage, ϒexc_info)))
					}
					λ.SetAttr(ϒself, "_download_retcode", λ.NewInt(1))
					return λ.None
				})
			YoutubeDL_report_warning = λ.NewFunction("report_warning",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_msg_header     λ.Object
						ϒmessage         = λargs[1]
						ϒself            = λargs[0]
						ϒwarning_message λ.Object
					)
					if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("logger")) != λ.None)) {
						λ.Cal(λ.GetAttr(λ.GetItem(λ.GetAttr(ϒself, "params", nil), λ.NewStr("logger")), "warning", nil), ϒmessage)
					} else {
						if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("no_warnings"))) {
							return λ.None
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("no_color")))); !λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_err_file", nil), "isatty", nil)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Ne(λ.None, λ.NewStr("nt"))
							}
						}()) {
							ϒ_msg_header = λ.NewStr("[0;33mWARNING:[0m")
						} else {
							ϒ_msg_header = λ.NewStr("WARNING:")
						}
						ϒwarning_message = λ.Mod(λ.NewStr("%s %s"), λ.NewTuple(
							ϒ_msg_header,
							ϒmessage,
						))
						λ.Cal(λ.GetAttr(ϒself, "to_stderr", nil), ϒwarning_message)
					}
					return λ.None
				})
			YoutubeDL_report_error = λ.NewFunction("report_error",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
					{Name: "tb", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_msg_header   λ.Object
						ϒerror_message λ.Object
						ϒmessage       = λargs[1]
						ϒself          = λargs[0]
						ϒtb            = λargs[2]
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("no_color")))); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_err_file", nil), "isatty", nil)); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Ne(λ.None, λ.NewStr("nt"))
						}
					}()) {
						ϒ_msg_header = λ.NewStr("[0;31mERROR:[0m")
					} else {
						ϒ_msg_header = λ.NewStr("ERROR:")
					}
					ϒerror_message = λ.Mod(λ.NewStr("%s %s"), λ.NewTuple(
						ϒ_msg_header,
						ϒmessage,
					))
					λ.Cal(λ.GetAttr(ϒself, "trouble", nil), ϒerror_message, ϒtb)
					return λ.None
				})
			YoutubeDL_prepare_filename = λ.NewFunction("prepare_filename",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						FIELD_SIZE_COMPAT_RE   λ.Object
						FORMAT_RE              λ.Object
						ϒautonumber_size       λ.Object
						ϒfield_size_compat_map λ.Object
						ϒfilename              λ.Object
						ϒinfo_dict             = λargs[1]
						ϒmobj                  λ.Object
						ϒnumeric_field         λ.Object
						ϒouttmpl               λ.Object
						ϒsanitize              λ.Object
						ϒself                  = λargs[0]
						ϒsep                   λ.Object
						ϒtemplate_dict         λ.Object
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
						τmp3                   λ.Object
					)
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
								var ϒerr λ.Object = λex
								λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Add(λ.Add(λ.Add(λ.Add(λ.NewStr("Error in output template: "), λ.Cal(λ.StrType, ϒerr)), λ.NewStr(" (encoding: ")), λ.Cal(λ.BuiltinRepr, λ.Cal(ϒpreferredencoding))), λ.NewStr(")")))
								λexit, λret = λ.BlockExitReturn, λ.None
								return
							}},
						)
						ϒtemplate_dict = λ.Cal(λ.DictType, ϒinfo_dict)
						λ.SetItem(ϒtemplate_dict, λ.NewStr("epoch"), λ.Cal(λ.IntType, λ.Cal(Ωtime.ϒtime)))
						ϒautonumber_size = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("autonumber_size"))
						if λ.IsTrue(λ.NewBool(ϒautonumber_size == λ.None)) {
							ϒautonumber_size = λ.NewInt(5)
						}
						λ.SetItem(ϒtemplate_dict, λ.NewStr("autonumber"), λ.Add(λ.Sub(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("autonumber_start"), λ.NewInt(1)), λ.NewInt(1)), λ.GetAttr(ϒself, "_num_downloads", nil)))
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒtemplate_dict, "get", nil), λ.NewStr("resolution")) == λ.None)) {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒtemplate_dict, "get", nil), λ.NewStr("width")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒtemplate_dict, "get", nil), λ.NewStr("height"))
								}
							}()) {
								λ.SetItem(ϒtemplate_dict, λ.NewStr("resolution"), λ.Mod(λ.NewStr("%dx%d"), λ.NewTuple(
									λ.GetItem(ϒtemplate_dict, λ.NewStr("width")),
									λ.GetItem(ϒtemplate_dict, λ.NewStr("height")),
								)))
							} else {
								if λ.IsTrue(λ.Cal(λ.GetAttr(ϒtemplate_dict, "get", nil), λ.NewStr("height"))) {
									λ.SetItem(ϒtemplate_dict, λ.NewStr("resolution"), λ.Mod(λ.NewStr("%sp"), λ.GetItem(ϒtemplate_dict, λ.NewStr("height"))))
								} else {
									if λ.IsTrue(λ.Cal(λ.GetAttr(ϒtemplate_dict, "get", nil), λ.NewStr("width"))) {
										λ.SetItem(ϒtemplate_dict, λ.NewStr("resolution"), λ.Mod(λ.NewStr("%dx?"), λ.GetItem(ϒtemplate_dict, λ.NewStr("width"))))
									}
								}
							}
						}
						ϒsanitize = λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "k"},
								{Name: "v"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒk = λargs[0]
									ϒv = λargs[1]
								)
								return λ.Call(ϒsanitize_filename, λ.NewArgs(λ.Cal(ϒcompat_str, ϒv)), λ.KWArgs{
									{Name: "restricted", Value: λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("restrictfilenames"))},
									{Name: "is_id", Value: func() λ.Object {
										if λv := λ.Eq(ϒk, λ.NewStr("id")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.GetAttr(ϒk, "endswith", nil), λ.NewStr("_id"))
										}
									}()},
								})
							})
						ϒtemplate_dict = λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒk   λ.Object
										ϒv   λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
										τmp2 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒtemplate_dict, "items", nil)))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										τmp2 = τmp1
										ϒk = λ.GetItem(τmp2, λ.NewInt(0))
										ϒv = λ.GetItem(τmp2, λ.NewInt(1))
										if λ.IsTrue(func() λ.Object {
											if λv := λ.NewBool(ϒv != λ.None); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒv, λ.NewTuple(
													λ.ListType,
													λ.TupleType,
													λ.DictType,
												))))
											}
										}()) {
											λgy.Yield(λ.NewTuple(
												ϒk,
												func() λ.Object {
													if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒv, ϒcompat_numeric_types)) {
														return ϒv
													} else {
														return λ.Cal(ϒsanitize, ϒk, ϒv)
													}
												}(),
											))
										}
									}
									return λ.None
								})
							})))
						ϒtemplate_dict = λ.Cal(Ωcollections.ϒdefaultdict, λ.NewFunction("<lambda>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewStr("NA")
							}), ϒtemplate_dict)
						ϒouttmpl = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("outtmpl"), DEFAULT_OUTTMPL)
						ϒfield_size_compat_map = λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("playlist_index"): λ.Cal(λ.BuiltinLen, λ.Cal(λ.StrType, λ.GetItem(ϒtemplate_dict, λ.NewStr("n_entries")))),
							λ.NewStr("autonumber"):     ϒautonumber_size,
						})
						FIELD_SIZE_COMPAT_RE = λ.NewStr("(?<!%)%\\((?P<field>autonumber|playlist_index)\\)s")
						ϒmobj = λ.Cal(Ωre.ϒsearch, FIELD_SIZE_COMPAT_RE, ϒouttmpl)
						if λ.IsTrue(ϒmobj) {
							ϒouttmpl = λ.Cal(Ωre.ϒsub, FIELD_SIZE_COMPAT_RE, λ.Mod(λ.NewStr("%%(\\1)0%dd"), λ.GetItem(ϒfield_size_compat_map, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("field")))), ϒouttmpl)
						}
						τmp2 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_NUMERIC_FIELDS", nil))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒnumeric_field = τmp3
							if λ.IsTrue(λ.NewBool(!λ.Contains(ϒtemplate_dict, ϒnumeric_field))) {
								FORMAT_RE = λ.NewStr("(?x)\n                        (?<!%)\n                        %\n                        \\({0}\\)  # mapping key\n                        (?:[#0\\-+ ]+)?  # conversion flags (optional)\n                        (?:\\d+)?  # minimum field width (optional)\n                        (?:\\.\\d+)?  # precision (optional)\n                        [hlL]?  # length modifier (optional)\n                        [diouxXeEfFgGcrs%]  # conversion type\n                    ")
								ϒouttmpl = λ.Cal(Ωre.ϒsub, λ.Cal(λ.GetAttr(FORMAT_RE, "format", nil), ϒnumeric_field), λ.Cal(λ.GetAttr(λ.NewStr("%({0})s"), "format", nil), ϒnumeric_field), ϒouttmpl)
							}
						}
						ϒsep = λ.Cal(λ.GetAttr(λ.NewStr(""), "join", nil), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.NewInt(32)))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										_ = τmp1
										λgy.Yield(λ.Cal(Ωrandom.ϒchoice, ϒascii_letters))
									}
									return λ.None
								})
							}))))
						ϒouttmpl = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒouttmpl, "replace", nil), λ.NewStr("%%"), λ.Cal(λ.GetAttr(λ.NewStr("%{0}%"), "format", nil), ϒsep)), "replace", nil), λ.NewStr("$$"), λ.Cal(λ.GetAttr(λ.NewStr("${0}$"), "format", nil), ϒsep))
						ϒfilename = λ.Mod(λ.Cal(λ.GetAttr(λ.Cal(ϒexpand_path, ϒouttmpl), "replace", nil), ϒsep, λ.NewStr("")), ϒtemplate_dict)
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Lt(Ωsys.ϒversion_info, λ.NewTuple(
								λ.NewInt(3),
								λ.NewInt(0),
							)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(Ωsys.ϒplatform, λ.NewStr("win32"))
							}
						}()) {
							ϒfilename = λ.Cal(λ.GetAttr(λ.Cal(λ.None, ϒfilename, λ.True), "decode", nil), λ.Cal(ϒpreferredencoding))
						}
						λexit, λret = λ.BlockExitReturn, λ.Cal(ϒsanitize_path, ϒfilename)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			YoutubeDL_add_extra_info = λ.NewFunction("add_extra_info",
				[]λ.Param{
					{Name: "info_dict"},
					{Name: "extra_info"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒextra_info = λargs[1]
						ϒinfo_dict  = λargs[0]
						ϒkey        λ.Object
						ϒvalue      λ.Object
						τmp0        λ.Object
						τmp1        λ.Object
						τmp2        λ.Object
					)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒextra_info, "items", nil)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒkey = λ.GetItem(τmp2, λ.NewInt(0))
						ϒvalue = λ.GetItem(τmp2, λ.NewInt(1))
						λ.Cal(λ.GetAttr(ϒinfo_dict, "setdefault", nil), ϒkey, ϒvalue)
					}
					return λ.None
				})
			YoutubeDL_add_extra_info = λ.Cal(λ.StaticMethodType, YoutubeDL_add_extra_info)
			YoutubeDL_extract_info = λ.NewFunction("extract_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "download", Def: λ.True},
					{Name: "ie_key", Def: λ.None},
					{Name: "extra_info", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "process", Def: λ.True},
					{Name: "force_generic_extractor", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownload                = λargs[2]
						ϒextra_info              = λargs[4]
						ϒforce_generic_extractor = λargs[6]
						ϒie                      λ.Object
						ϒie_key                  = λargs[3]
						ϒie_result               λ.Object
						ϒies                     λ.Object
						ϒmsg                     λ.Object
						ϒprocess                 = λargs[5]
						ϒself                    = λargs[0]
						ϒurl                     = λargs[1]
						τmp0                     λ.Object
						τmp1                     λ.Object
						τmp2                     λ.Object
						τmp3                     λ.Object
						τmp4                     λ.Object
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(ϒie_key)); !λ.IsTrue(λv) {
							return λv
						} else {
							return ϒforce_generic_extractor
						}
					}()) {
						ϒie_key = λ.NewStr("Generic")
					}
					if λ.IsTrue(ϒie_key) {
						ϒies = λ.NewList(λ.Cal(λ.GetAttr(ϒself, "get_info_extractor", nil), ϒie_key))
					} else {
						ϒies = λ.GetAttr(ϒself, "_ies", nil)
					}
					τmp0 = λ.Cal(λ.BuiltinIter, ϒies)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒie = τmp1
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒie, "suitable", nil), ϒurl)))) {
							continue
						}
						ϒie = λ.Cal(λ.GetAttr(ϒself, "get_info_extractor", nil), λ.Cal(λ.GetAttr(ϒie, "ie_key", nil)))
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒie, "working", nil))))) {
							λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("The program functionality for this site has been marked as broken, and will probably not work."))
						}
						τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{GeoRestrictedError, func(λex λ.BaseException) {
									var ϒe λ.Object = λex
									ϒmsg = λ.GetAttr(ϒe, "msg", nil)
									if λ.IsTrue(λ.GetAttr(ϒe, "countries", nil)) {
										τmp4 = λ.IAdd(ϒmsg, λ.Mod(λ.NewStr("\nThis video is available in %s."), λ.Cal(λ.GetAttr(λ.NewStr(", "), "join", nil), λ.Cal(λ.MapIteratorType, λ.GetAttr(λ.None, "short2full", nil), λ.GetAttr(ϒe, "countries", nil)))))
										ϒmsg = τmp4
									}
									τmp4 = λ.IAdd(ϒmsg, λ.NewStr("\nYou might want to use a VPN or a proxy server (with --proxy) to workaround."))
									ϒmsg = τmp4
									λ.Cal(λ.GetAttr(ϒself, "report_error", nil), ϒmsg)
									λexit = λ.BlockExitBreak
									return
								}},
								&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
									var ϒe λ.Object = λex
									λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Cal(ϒcompat_str, ϒe), λ.Cal(λ.GetAttr(ϒe, "format_traceback", nil)))
									λexit = λ.BlockExitBreak
									return
								}},
								&λ.Catcher{MaxDownloadsReached, func(λex λ.BaseException) {
									panic(λ.Raise(λex))
								}},
								&λ.Catcher{λ.ExceptionType, func(λex λ.BaseException) {
									var ϒe λ.Object = λex
									if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("ignoreerrors"), λ.False)) {
										λ.Call(λ.GetAttr(ϒself, "report_error", nil), λ.NewArgs(λ.Cal(ϒerror_to_compat_str, ϒe)), λ.KWArgs{
											{Name: "tb", Value: λ.Cal(λ.None, λ.Cal(λ.GetAttr(λ.None, "format_exc", nil)))},
										})
										λexit = λ.BlockExitBreak
										return
									} else {
										panic(λ.Raise(λex))
									}
								}},
							)
							ϒie_result = λ.Cal(λ.GetAttr(ϒie, "extract", nil), ϒurl)
							if λ.IsTrue(λ.NewBool(ϒie_result == λ.None)) {
								λexit = λ.BlockExitBreak
								return
							}
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒie_result, λ.ListType)) {
								ϒie_result = λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("_type"):   λ.NewStr("compat_list"),
									λ.NewStr("entries"): ϒie_result,
								})
							}
							λ.Cal(λ.GetAttr(ϒself, "add_default_extra_info", nil), ϒie_result, ϒie, ϒurl)
							if λ.IsTrue(ϒprocess) {
								λexit, λret = λ.BlockExitReturn, λ.Cal(λ.GetAttr(ϒself, "process_ie_result", nil), ϒie_result, ϒdownload, ϒextra_info)
								return
							} else {
								λexit, λret = λ.BlockExitReturn, ϒie_result
								return
							}
							return λ.BlockExitNormally, nil
						}()
						if τmp2 == λ.BlockExitReturn {
							return τmp3
						}
						if τmp2 == λ.BlockExitBreak {
							break
						}
					}
					if τmp1 == λ.AfterLast {
						λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Mod(λ.NewStr("no suitable InfoExtractor for URL %s"), ϒurl))
					}
					return λ.None
				})
			YoutubeDL_add_default_extra_info = λ.NewFunction("add_default_extra_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie_result"},
					{Name: "ie"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie        = λargs[2]
						ϒie_result = λargs[1]
						ϒself      = λargs[0]
						ϒurl       = λargs[3]
					)
					λ.Cal(λ.GetAttr(ϒself, "add_extra_info", nil), ϒie_result, λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("extractor"):            λ.GetAttr(ϒie, "IE_NAME", nil),
						λ.NewStr("webpage_url"):          ϒurl,
						λ.NewStr("webpage_url_basename"): λ.Cal(ϒurl_basename, ϒurl),
						λ.NewStr("extractor_key"):        λ.Cal(λ.GetAttr(ϒie, "ie_key", nil)),
					}))
					return λ.None
				})
			YoutubeDL_process_ie_result = λ.NewFunction("process_ie_result",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie_result"},
					{Name: "download", Def: λ.True},
					{Name: "extra_info", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_fixup                     λ.Object
						ϒdownload                   = λargs[2]
						ϒentries                    λ.Object
						ϒentry                      λ.Object
						ϒentry_result               λ.Object
						ϒextra                      λ.Object
						ϒextra_info                 = λargs[3]
						ϒextract_flat               λ.Object
						ϒf                          λ.Object
						ϒforce_properties           λ.Object
						ϒi                          λ.Object
						ϒie_entries                 λ.Object
						ϒie_result                  = λargs[1]
						ϒinfo                       λ.Object
						ϒitem                       λ.Object
						ϒiter_playlistitems         λ.Object
						ϒmake_playlistitems_entries λ.Object
						ϒn_all_entries              λ.Object
						ϒn_entries                  λ.Object
						ϒnew_result                 λ.Object
						ϒplaylist                   λ.Object
						ϒplaylist_results           λ.Object
						ϒplaylistend                λ.Object
						ϒplaylistitems              λ.Object
						ϒplaylistitems_str          λ.Object
						ϒplayliststart              λ.Object
						ϒreason                     λ.Object
						ϒreport_download            λ.Object
						ϒresult_type                λ.Object
						ϒself                       = λargs[0]
						ϒx_forwarded_for            λ.Object
						τmp0                        λ.Object
						τmp1                        λ.Object
						τmp2                        λ.Object
					)
					ϒresult_type = λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("_type"), λ.NewStr("video"))
					if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
						λ.NewStr("url"),
						λ.NewStr("url_transparent"),
					), ϒresult_type))) {
						λ.SetItem(ϒie_result, λ.NewStr("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒie_result, λ.NewStr("url"))))
						ϒextract_flat = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("extract_flat"), λ.False)
						if λ.IsTrue(func() λ.Object {
							if λv := func() λ.Object {
								if λv := λ.Eq(ϒextract_flat, λ.NewStr("in_playlist")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Contains(ϒextra_info, λ.NewStr("playlist")))
								}
							}(); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(ϒextract_flat == λ.True)
							}
						}()) {
							λ.Call(λ.GetAttr(ϒself, "__forced_printings", nil), λ.NewArgs(
								ϒie_result,
								λ.Cal(λ.GetAttr(ϒself, "prepare_filename", nil), ϒie_result),
							), λ.KWArgs{
								{Name: "incomplete", Value: λ.True},
							})
							return ϒie_result
						}
					}
					if λ.IsTrue(λ.Eq(ϒresult_type, λ.NewStr("video"))) {
						λ.Cal(λ.GetAttr(ϒself, "add_extra_info", nil), ϒie_result, ϒextra_info)
						return λ.Call(λ.GetAttr(ϒself, "process_video_result", nil), λ.NewArgs(ϒie_result), λ.KWArgs{
							{Name: "download", Value: ϒdownload},
						})
					} else {
						if λ.IsTrue(λ.Eq(ϒresult_type, λ.NewStr("url"))) {
							return λ.Call(λ.GetAttr(ϒself, "extract_info", nil), λ.NewArgs(
								λ.GetItem(ϒie_result, λ.NewStr("url")),
								ϒdownload,
							), λ.KWArgs{
								{Name: "ie_key", Value: λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("ie_key"))},
								{Name: "extra_info", Value: ϒextra_info},
							})
						} else {
							if λ.IsTrue(λ.Eq(ϒresult_type, λ.NewStr("url_transparent"))) {
								ϒinfo = λ.Call(λ.GetAttr(ϒself, "extract_info", nil), λ.NewArgs(λ.GetItem(ϒie_result, λ.NewStr("url"))), λ.KWArgs{
									{Name: "ie_key", Value: λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("ie_key"))},
									{Name: "extra_info", Value: ϒextra_info},
									{Name: "download", Value: λ.False},
									{Name: "process", Value: λ.False},
								})
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒinfo))) {
									return ϒinfo
								}
								ϒforce_properties = λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
											var (
												ϒk   λ.Object
												ϒv   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
												τmp2 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒie_result, "items", nil)))
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												τmp2 = τmp1
												ϒk = λ.GetItem(τmp2, λ.NewInt(0))
												ϒv = λ.GetItem(τmp2, λ.NewInt(1))
												if λ.IsTrue(λ.NewBool(ϒv != λ.None)) {
													λgy.Yield(λ.NewTuple(
														ϒk,
														ϒv,
													))
												}
											}
											return λ.None
										})
									})))
								τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
									λ.NewStr("_type"),
									λ.NewStr("url"),
									λ.NewStr("id"),
									λ.NewStr("extractor"),
									λ.NewStr("extractor_key"),
									λ.NewStr("ie_key"),
								))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒf = τmp1
									if λ.IsTrue(λ.NewBool(λ.Contains(ϒforce_properties, ϒf))) {
										λ.DelItem(ϒforce_properties, ϒf)
									}
								}
								ϒnew_result = λ.Cal(λ.GetAttr(ϒinfo, "copy", nil))
								λ.Cal(λ.GetAttr(ϒnew_result, "update", nil), ϒforce_properties)
								if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒnew_result, "get", nil), λ.NewStr("_type")), λ.NewStr("url"))) {
									λ.SetItem(ϒnew_result, λ.NewStr("_type"), λ.NewStr("url_transparent"))
								}
								return λ.Call(λ.GetAttr(ϒself, "process_ie_result", nil), λ.NewArgs(ϒnew_result), λ.KWArgs{
									{Name: "download", Value: ϒdownload},
									{Name: "extra_info", Value: ϒextra_info},
								})
							} else {
								if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
									λ.NewStr("playlist"),
									λ.NewStr("multi_video"),
								), ϒresult_type))) {
									panic(λ.Raise(λ.Cal(λ.ExceptionType, λ.NewStr("Playlists and multi video results are not supported!"))))
									ϒplaylist = func() λ.Object {
										if λv := λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("title")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("id"))
										}
									}()
									λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[download] Downloading playlist: %s"), ϒplaylist))
									ϒplaylist_results = λ.NewList()
									ϒplayliststart = λ.Sub(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("playliststart"), λ.NewInt(1)), λ.NewInt(1))
									ϒplaylistend = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("playlistend"))
									if λ.IsTrue(λ.Eq(ϒplaylistend, λ.Neg(λ.NewInt(1)))) {
										ϒplaylistend = λ.None
									}
									ϒplaylistitems_str = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("playlist_items"))
									ϒplaylistitems = λ.None
									if λ.IsTrue(λ.NewBool(ϒplaylistitems_str != λ.None)) {
										ϒiter_playlistitems = λ.NewFunction("iter_playlistitems",
											[]λ.Param{
												{Name: "format"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
													var (
														ϒend            λ.Object
														ϒformat         = λargs[0]
														ϒitem           λ.Object
														ϒstart          λ.Object
														ϒstring_segment λ.Object
														τmp0            λ.Object
														τmp1            λ.Object
														τmp2            λ.Object
														τmp3            λ.Object
													)
													τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒformat, "split", nil), λ.NewStr(",")))
													for {
														if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
															break
														}
														ϒstring_segment = τmp1
														if λ.IsTrue(λ.NewBool(λ.Contains(ϒstring_segment, λ.NewStr("-")))) {
															τmp2 = λ.Cal(λ.GetAttr(ϒstring_segment, "split", nil), λ.NewStr("-"))
															ϒstart = λ.GetItem(τmp2, λ.NewInt(0))
															ϒend = λ.GetItem(τmp2, λ.NewInt(1))
															τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.Cal(λ.IntType, ϒstart), λ.Add(λ.Cal(λ.IntType, ϒend), λ.NewInt(1))))
															for {
																if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
																	break
																}
																ϒitem = τmp3
																λgy.Yield(λ.Cal(λ.IntType, ϒitem))
															}
														} else {
															λgy.Yield(λ.Cal(λ.IntType, ϒstring_segment))
														}
													}
													return λ.None
												})
											})
										ϒplaylistitems = λ.Cal(ϒorderedSet, λ.Cal(ϒiter_playlistitems, ϒplaylistitems_str))
									}
									ϒie_entries = λ.GetItem(ϒie_result, λ.NewStr("entries"))
									ϒmake_playlistitems_entries = λ.NewFunction("make_playlistitems_entries",
										[]λ.Param{
											{Name: "list_ie_entries"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒlist_ie_entries = λargs[0]
												ϒnum_entries     λ.Object
											)
											ϒnum_entries = λ.Cal(λ.BuiltinLen, ϒlist_ie_entries)
											return λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
												nil,
												0, false, false,
												func(λargs []λ.Object) λ.Object {
													return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
														var (
															ϒi   λ.Object
															τmp0 λ.Object
															τmp1 λ.Object
														)
														τmp0 = λ.Cal(λ.BuiltinIter, ϒplaylistitems)
														for {
															if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
																break
															}
															ϒi = τmp1
															if λ.IsTrue(func() λ.Object {
																var λl λ.Object = λ.Neg(ϒnum_entries)
																var λr λ.Object = λ.Sub(ϒi, λ.NewInt(1))
																if !λ.IsTrue(λ.Le(λl, λr)) {
																	return λ.False
																}
																λl = λr
																λr = ϒnum_entries
																if !λ.IsTrue(λ.Lt(λl, λr)) {
																	return λ.False
																}
																return λ.True
															}()) {
																λgy.Yield(λ.GetItem(ϒlist_ie_entries, λ.Sub(ϒi, λ.NewInt(1))))
															}
														}
														return λ.None
													})
												})))
										})
									ϒreport_download = λ.NewFunction("report_download",
										[]λ.Param{
											{Name: "num_entries"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒnum_entries = λargs[0]
											)
											λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[%s] playlist %s: Downloading %d videos"), λ.NewTuple(
												λ.GetItem(ϒie_result, λ.NewStr("extractor")),
												ϒplaylist,
												ϒnum_entries,
											)))
											return λ.None
										})
									if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒie_entries, λ.ListType)) {
										ϒn_all_entries = λ.Cal(λ.BuiltinLen, ϒie_entries)
										if λ.IsTrue(ϒplaylistitems) {
											ϒentries = λ.Cal(ϒmake_playlistitems_entries, ϒie_entries)
										} else {
											ϒentries = λ.GetItem(ϒie_entries, λ.NewSlice(ϒplayliststart, ϒplaylistend, λ.None))
										}
										ϒn_entries = λ.Cal(λ.BuiltinLen, ϒentries)
										λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[%s] playlist %s: Collected %d video ids (downloading %d of them)"), λ.NewTuple(
											λ.GetItem(ϒie_result, λ.NewStr("extractor")),
											ϒplaylist,
											ϒn_all_entries,
											ϒn_entries,
										)))
									} else {
										if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒie_entries, PagedList)) {
											if λ.IsTrue(ϒplaylistitems) {
												ϒentries = λ.NewList()
												τmp0 = λ.Cal(λ.BuiltinIter, ϒplaylistitems)
												for {
													if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
														break
													}
													ϒitem = τmp1
													λ.Cal(λ.GetAttr(ϒentries, "extend", nil), λ.Cal(λ.GetAttr(ϒie_entries, "getslice", nil), λ.Sub(ϒitem, λ.NewInt(1)), ϒitem))
												}
											} else {
												ϒentries = λ.Cal(λ.GetAttr(ϒie_entries, "getslice", nil), ϒplayliststart, ϒplaylistend)
											}
											ϒn_entries = λ.Cal(λ.BuiltinLen, ϒentries)
											λ.Cal(ϒreport_download, ϒn_entries)
										} else {
											if λ.IsTrue(ϒplaylistitems) {
												ϒentries = λ.Cal(ϒmake_playlistitems_entries, λ.Cal(λ.ListType, λ.Cal(λ.None, ϒie_entries, λ.NewInt(0), λ.Cal(λ.BuiltinMax, ϒplaylistitems))))
											} else {
												ϒentries = λ.Cal(λ.ListType, λ.Cal(λ.None, ϒie_entries, ϒplayliststart, ϒplaylistend))
											}
											ϒn_entries = λ.Cal(λ.BuiltinLen, ϒentries)
											λ.Cal(ϒreport_download, ϒn_entries)
										}
									}
									if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("playlistreverse"), λ.False)) {
										ϒentries = λ.GetItem(ϒentries, λ.NewSlice(λ.None, λ.None, λ.Neg(λ.NewInt(1))))
									}
									if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("playlistrandom"), λ.False)) {
										λ.Cal(λ.None, ϒentries)
									}
									ϒx_forwarded_for = λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("__x_forwarded_for_ip"))
									τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒentries, λ.NewInt(1)))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										τmp2 = τmp1
										ϒi = λ.GetItem(τmp2, λ.NewInt(0))
										ϒentry = λ.GetItem(τmp2, λ.NewInt(1))
										λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[download] Downloading video %s of %s"), λ.NewTuple(
											ϒi,
											ϒn_entries,
										)))
										if λ.IsTrue(ϒx_forwarded_for) {
											λ.SetItem(ϒentry, λ.NewStr("__x_forwarded_for_ip"), ϒx_forwarded_for)
										}
										ϒextra = λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("n_entries"):            ϒn_entries,
											λ.NewStr("playlist"):             ϒplaylist,
											λ.NewStr("playlist_id"):          λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("id")),
											λ.NewStr("playlist_title"):       λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("title")),
											λ.NewStr("playlist_uploader"):    λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("uploader")),
											λ.NewStr("playlist_uploader_id"): λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("uploader_id")),
											λ.NewStr("playlist_index"):       λ.Add(ϒi, ϒplayliststart),
											λ.NewStr("extractor"):            λ.GetItem(ϒie_result, λ.NewStr("extractor")),
											λ.NewStr("webpage_url"):          λ.GetItem(ϒie_result, λ.NewStr("webpage_url")),
											λ.NewStr("webpage_url_basename"): λ.Cal(ϒurl_basename, λ.GetItem(ϒie_result, λ.NewStr("webpage_url"))),
											λ.NewStr("extractor_key"):        λ.GetItem(ϒie_result, λ.NewStr("extractor_key")),
										})
										ϒreason = λ.Call(λ.GetAttr(ϒself, "_match_entry", nil), λ.NewArgs(ϒentry), λ.KWArgs{
											{Name: "incomplete", Value: λ.True},
										})
										if λ.IsTrue(λ.NewBool(ϒreason != λ.None)) {
											λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("[download] "), ϒreason))
											continue
										}
										ϒentry_result = λ.Call(λ.GetAttr(ϒself, "process_ie_result", nil), λ.NewArgs(ϒentry), λ.KWArgs{
											{Name: "download", Value: ϒdownload},
											{Name: "extra_info", Value: ϒextra},
										})
										λ.Cal(λ.GetAttr(ϒplaylist_results, "append", nil), ϒentry_result)
									}
									λ.SetItem(ϒie_result, λ.NewStr("entries"), ϒplaylist_results)
									λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[download] Finished downloading playlist: %s"), ϒplaylist))
									return ϒie_result
								} else {
									if λ.IsTrue(λ.Eq(ϒresult_type, λ.NewStr("compat_list"))) {
										λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("Extractor %s returned a compat_list result. It needs to be updated."), λ.Cal(λ.GetAttr(ϒie_result, "get", nil), λ.NewStr("extractor"))))
										ϒ_fixup = λ.NewFunction("_fixup",
											[]λ.Param{
												{Name: "r"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒr = λargs[0]
												)
												λ.Cal(λ.GetAttr(ϒself, "add_extra_info", nil), ϒr, λ.NewDictWithTable(map[λ.Object]λ.Object{
													λ.NewStr("extractor"):            λ.GetItem(ϒie_result, λ.NewStr("extractor")),
													λ.NewStr("webpage_url"):          λ.GetItem(ϒie_result, λ.NewStr("webpage_url")),
													λ.NewStr("webpage_url_basename"): λ.Cal(ϒurl_basename, λ.GetItem(ϒie_result, λ.NewStr("webpage_url"))),
													λ.NewStr("extractor_key"):        λ.GetItem(ϒie_result, λ.NewStr("extractor_key")),
												}))
												return ϒr
											})
										λ.SetItem(ϒie_result, λ.NewStr("entries"), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
											nil,
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
													var (
														ϒr   λ.Object
														τmp0 λ.Object
														τmp1 λ.Object
													)
													τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒie_result, λ.NewStr("entries")))
													for {
														if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
															break
														}
														ϒr = τmp1
														λgy.Yield(λ.Cal(λ.GetAttr(ϒself, "process_ie_result", nil), λ.Cal(ϒ_fixup, ϒr), ϒdownload, ϒextra_info))
													}
													return λ.None
												})
											}))))
										return ϒie_result
									} else {
										panic(λ.Raise(λ.Cal(λ.ExceptionType, λ.Mod(λ.NewStr("Invalid result type: %s"), ϒresult_type))))
									}
								}
							}
						}
					}
					return λ.None
				})
			YoutubeDL__default_format_spec = λ.NewFunction("_default_format_spec",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
					{Name: "download", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcan_merge       λ.Object
						ϒdownload        = λargs[2]
						ϒinfo_dict       = λargs[1]
						ϒprefer_best     λ.Object
						ϒreq_format_list λ.Object
						ϒself            = λargs[0]
					)
					ϒcan_merge = λ.NewFunction("can_merge",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒmerger λ.Object
							)
							ϒmerger = λ.Cal(λ.None, ϒself)
							return func() λ.Object {
								if λv := λ.GetAttr(ϒmerger, "available", nil); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒmerger, "can_merge", nil))
								}
							}()
						})
					ϒprefer_best = λ.NewFunction("prefer_best",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("simulate"), λ.False)) {
								return λ.False
							}
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒdownload))) {
								return λ.False
							}
							if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("outtmpl"), DEFAULT_OUTTMPL), λ.NewStr("-"))) {
								return λ.True
							}
							if λ.IsTrue(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("is_live"))) {
								return λ.True
							}
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(ϒcan_merge)))) {
								return λ.True
							}
							return λ.False
						})
					ϒreq_format_list = λ.NewList(
						λ.NewStr("bestvideo+bestaudio"),
						λ.NewStr("best"),
					)
					if λ.IsTrue(λ.Cal(ϒprefer_best)) {
						λ.Cal(λ.GetAttr(ϒreq_format_list, "reverse", nil))
					}
					return λ.Cal(λ.GetAttr(λ.NewStr("/"), "join", nil), ϒreq_format_list)
				})
			YoutubeDL__calc_headers = λ.NewFunction("_calc_headers",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒadd_headers        λ.Object
						ϒcookies            λ.Object
						ϒinfo_dict          = λargs[1]
						ϒres                λ.Object
						ϒself               = λargs[0]
						ϒx_forwarded_for_ip λ.Object
					)
					ϒres = λ.Cal(λ.GetAttr(ϒstd_headers, "copy", nil))
					ϒadd_headers = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("http_headers"))
					if λ.IsTrue(ϒadd_headers) {
						λ.Cal(λ.GetAttr(ϒres, "update", nil), ϒadd_headers)
					}
					ϒcookies = λ.Cal(λ.GetAttr(ϒself, "_calc_cookies", nil), ϒinfo_dict)
					if λ.IsTrue(ϒcookies) {
						λ.SetItem(ϒres, λ.NewStr("Cookie"), ϒcookies)
					}
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒres, λ.NewStr("X-Forwarded-For")))) {
						ϒx_forwarded_for_ip = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("__x_forwarded_for_ip"))
						if λ.IsTrue(ϒx_forwarded_for_ip) {
							λ.SetItem(ϒres, λ.NewStr("X-Forwarded-For"), ϒx_forwarded_for_ip)
						}
					}
					return ϒres
				})
			YoutubeDL__calc_cookies = λ.NewFunction("_calc_cookies",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒinfo_dict = λargs[1]
						ϒpr        λ.Object
						ϒself      = λargs[0]
					)
					ϒpr = λ.Cal(ϒsanitized_Request, λ.GetItem(ϒinfo_dict, λ.NewStr("url")))
					λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "cookiejar", nil), "add_cookie_header", nil), ϒpr)
					return λ.Cal(λ.GetAttr(ϒpr, "get_header", nil), λ.NewStr("Cookie"))
				})
			YoutubeDL_process_video_result = λ.NewFunction("process_video_result",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
					{Name: "download", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒambiguous_formats       λ.Object
						ϒautomatic_captions      λ.Object
						ϒcc                      λ.Object
						ϒcc_kind                 λ.Object
						ϒctx                     λ.Object
						ϒdownload                = λargs[2]
						ϒfield                   λ.Object
						ϒformat                  λ.Object
						ϒformat_id               λ.Object
						ϒformat_selector         λ.Object
						ϒformats                 λ.Object
						ϒformats_dict            λ.Object
						ϒformats_to_download     λ.Object
						ϒfull_format_info        λ.Object
						ϒi                       λ.Object
						ϒincomplete_formats      λ.Object
						ϒinfo_dict               = λargs[1]
						ϒis_wellformed           λ.Object
						ϒnew_info                λ.Object
						ϒreport_force_conversion λ.Object
						ϒreq_format              λ.Object
						ϒsanitize_numeric_fields λ.Object
						ϒsanitize_string_field   λ.Object
						ϒself                    = λargs[0]
						ϒsubtitle                λ.Object
						ϒsubtitle_format         λ.Object
						ϒsubtitles               λ.Object
						ϒt                       λ.Object
						ϒthumbnail               λ.Object
						ϒthumbnails              λ.Object
						τmp0                     λ.Object
						τmp1                     λ.Object
						τmp2                     λ.Object
						τmp3                     λ.Object
						τmp4                     λ.Object
						τmp5                     λ.Object
					)
					if !λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("_type"), λ.NewStr("video")), λ.NewStr("video"))) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒinfo_dict, λ.NewStr("id")))) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.NewStr("Missing \"id\" field in extractor result"))))
					}
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒinfo_dict, λ.NewStr("title")))) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.NewStr("Missing \"title\" field in extractor result"))))
					}
					ϒreport_force_conversion = λ.NewFunction("report_force_conversion",
						[]λ.Param{
							{Name: "field"},
							{Name: "field_not"},
							{Name: "conversion"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒconversion = λargs[2]
								ϒfield      = λargs[0]
								ϒfield_not  = λargs[1]
							)
							λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("\"%s\" field is not %s - forcing %s conversion, there is an error in extractor"), λ.NewTuple(
								ϒfield,
								ϒfield_not,
								ϒconversion,
							)))
							return λ.None
						})
					ϒsanitize_string_field = λ.NewFunction("sanitize_string_field",
						[]λ.Param{
							{Name: "info"},
							{Name: "string_field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield        λ.Object
								ϒinfo         = λargs[0]
								ϒstring_field = λargs[1]
							)
							ϒfield = λ.Cal(λ.GetAttr(ϒinfo, "get", nil), ϒstring_field)
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(ϒfield == λ.None); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.BuiltinIsInstance, ϒfield, ϒcompat_str)
								}
							}()) {
								return λ.None
							}
							λ.Cal(ϒreport_force_conversion, ϒstring_field, λ.NewStr("a string"), λ.NewStr("string"))
							λ.SetItem(ϒinfo, ϒstring_field, λ.Cal(ϒcompat_str, ϒfield))
							return λ.None
						})
					ϒsanitize_numeric_fields = λ.NewFunction("sanitize_numeric_fields",
						[]λ.Param{
							{Name: "info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield         λ.Object
								ϒinfo          = λargs[0]
								ϒnumeric_field λ.Object
								τmp0           λ.Object
								τmp1           λ.Object
							)
							τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_NUMERIC_FIELDS", nil))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒnumeric_field = τmp1
								ϒfield = λ.Cal(λ.GetAttr(ϒinfo, "get", nil), ϒnumeric_field)
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(ϒfield == λ.None); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.BuiltinIsInstance, ϒfield, ϒcompat_numeric_types)
									}
								}()) {
									continue
								}
								λ.Cal(ϒreport_force_conversion, ϒnumeric_field, λ.NewStr("numeric"), λ.NewStr("int"))
								λ.SetItem(ϒinfo, ϒnumeric_field, λ.Cal(ϒint_or_none, ϒfield))
							}
							return λ.None
						})
					λ.Cal(ϒsanitize_string_field, ϒinfo_dict, λ.NewStr("id"))
					λ.Cal(ϒsanitize_numeric_fields, ϒinfo_dict)
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒinfo_dict, λ.NewStr("playlist")))) {
						λ.SetItem(ϒinfo_dict, λ.NewStr("playlist"), λ.None)
						λ.SetItem(ϒinfo_dict, λ.NewStr("playlist_index"), λ.None)
					}
					ϒthumbnails = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("thumbnails"))
					if λ.IsTrue(λ.NewBool(ϒthumbnails == λ.None)) {
						ϒthumbnail = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("thumbnail"))
						if λ.IsTrue(ϒthumbnail) {
							τmp0 = λ.NewList(λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("url"): ϒthumbnail,
							}))
							λ.SetItem(ϒinfo_dict, λ.NewStr("thumbnails"), τmp0)
							ϒthumbnails = τmp0
						}
					}
					if λ.IsTrue(ϒthumbnails) {
						λ.Call(λ.GetAttr(ϒthumbnails, "sort", nil), nil, λ.KWArgs{
							{Name: "key", Value: λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "t"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒt = λargs[0]
									)
									return λ.NewTuple(
										func() λ.Object {
											if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("preference")) != λ.None)) {
												return λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("preference"))
											} else {
												return λ.Neg(λ.NewInt(1))
											}
										}(),
										func() λ.Object {
											if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("width")) != λ.None)) {
												return λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("width"))
											} else {
												return λ.Neg(λ.NewInt(1))
											}
										}(),
										func() λ.Object {
											if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("height")) != λ.None)) {
												return λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("height"))
											} else {
												return λ.Neg(λ.NewInt(1))
											}
										}(),
										func() λ.Object {
											if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("id")) != λ.None)) {
												return λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("id"))
											} else {
												return λ.NewStr("")
											}
										}(),
										λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("url")),
									)
								})},
						})
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒthumbnails))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒi = λ.GetItem(τmp2, λ.NewInt(0))
							ϒt = λ.GetItem(τmp2, λ.NewInt(1))
							λ.SetItem(ϒt, λ.NewStr("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒt, λ.NewStr("url"))))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("width")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("height"))
								}
							}()) {
								λ.SetItem(ϒt, λ.NewStr("resolution"), λ.Mod(λ.NewStr("%dx%d"), λ.NewTuple(
									λ.GetItem(ϒt, λ.NewStr("width")),
									λ.GetItem(ϒt, λ.NewStr("height")),
								)))
							}
							if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒt, "get", nil), λ.NewStr("id")) == λ.None)) {
								λ.SetItem(ϒt, λ.NewStr("id"), λ.Mod(λ.NewStr("%d"), ϒi))
							}
						}
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("list_thumbnails"))) {
						λ.Cal(λ.GetAttr(ϒself, "list_thumbnails", nil), ϒinfo_dict)
						return λ.None
					}
					ϒthumbnail = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("thumbnail"))
					if λ.IsTrue(ϒthumbnail) {
						λ.SetItem(ϒinfo_dict, λ.NewStr("thumbnail"), λ.Cal(ϒsanitize_url, ϒthumbnail))
					} else {
						if λ.IsTrue(ϒthumbnails) {
							λ.SetItem(ϒinfo_dict, λ.NewStr("thumbnail"), λ.GetItem(λ.GetItem(ϒthumbnails, λ.Neg(λ.NewInt(1))), λ.NewStr("url")))
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.Contains(ϒinfo_dict, λ.NewStr("display_id"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(ϒinfo_dict, λ.NewStr("id")))
						}
					}()) {
						λ.SetItem(ϒinfo_dict, λ.NewStr("display_id"), λ.GetItem(ϒinfo_dict, λ.NewStr("id")))
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.NewStr("chapter"),
						λ.NewStr("season"),
						λ.NewStr("episode"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒfield = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.Mod(λ.NewStr("%s_number"), ϒfield)) != λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), ϒfield)))
							}
						}()) {
							λ.SetItem(ϒinfo_dict, ϒfield, λ.Mod(λ.NewStr("%s %d"), λ.NewTuple(
								λ.Cal(λ.GetAttr(ϒfield, "capitalize", nil)),
								λ.GetItem(ϒinfo_dict, λ.Mod(λ.NewStr("%s_number"), ϒfield)),
							)))
						}
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.NewStr("subtitles"),
						λ.NewStr("automatic_captions"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒcc_kind = τmp1
						ϒcc = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), ϒcc_kind)
						if λ.IsTrue(ϒcc) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒcc, "items", nil)))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								τmp4 = τmp3
								_ = λ.GetItem(τmp4, λ.NewInt(0))
								ϒsubtitle = λ.GetItem(τmp4, λ.NewInt(1))
								τmp4 = λ.Cal(λ.BuiltinIter, ϒsubtitle)
								for {
									if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
										break
									}
									ϒsubtitle_format = τmp5
									if λ.IsTrue(λ.Cal(λ.GetAttr(ϒsubtitle_format, "get", nil), λ.NewStr("url"))) {
										λ.SetItem(ϒsubtitle_format, λ.NewStr("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒsubtitle_format, λ.NewStr("url"))))
									}
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒsubtitle_format, "get", nil), λ.NewStr("ext")) == λ.None)) {
										λ.SetItem(ϒsubtitle_format, λ.NewStr("ext"), λ.Cal(λ.GetAttr(λ.Cal(ϒdetermine_ext, λ.GetItem(ϒsubtitle_format, λ.NewStr("url"))), "lower", nil)))
									}
								}
							}
						}
					}
					ϒautomatic_captions = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("automatic_captions"))
					ϒsubtitles = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("subtitles"))
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("listsubtitles"), λ.False)) {
						if λ.IsTrue(λ.NewBool(λ.Contains(ϒinfo_dict, λ.NewStr("automatic_captions")))) {
							λ.Cal(λ.GetAttr(ϒself, "list_subtitles", nil), λ.GetItem(ϒinfo_dict, λ.NewStr("id")), ϒautomatic_captions, λ.NewStr("automatic captions"))
						}
						λ.Cal(λ.GetAttr(ϒself, "list_subtitles", nil), λ.GetItem(ϒinfo_dict, λ.NewStr("id")), ϒsubtitles, λ.NewStr("subtitles"))
						return λ.None
					}
					λ.SetItem(ϒinfo_dict, λ.NewStr("requested_subtitles"), λ.Cal(λ.GetAttr(ϒself, "process_subtitles", nil), λ.GetItem(ϒinfo_dict, λ.NewStr("id")), ϒsubtitles, ϒautomatic_captions))
					if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("formats")) == λ.None)) {
						ϒformats = λ.NewList(ϒinfo_dict)
					} else {
						ϒformats = λ.GetItem(ϒinfo_dict, λ.NewStr("formats"))
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒformats))) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.NewStr("No video formats found!"))))
					}
					ϒis_wellformed = λ.NewFunction("is_wellformed",
						[]λ.Param{
							{Name: "f"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒf   = λargs[0]
								ϒurl λ.Object
							)
							ϒurl = λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("url"))
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒurl))) {
								λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("\"url\" field is missing or empty - skipping format, there is an error in extractor"))
								return λ.False
							}
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl, λ.BytesType)) {
								λ.Cal(ϒsanitize_string_field, ϒf, λ.NewStr("url"))
							}
							return λ.True
						})
					ϒformats = λ.Cal(λ.ListType, λ.Cal(λ.FilterIteratorType, ϒis_wellformed, ϒformats))
					ϒformats_dict = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒformats))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒi = λ.GetItem(τmp2, λ.NewInt(0))
						ϒformat = λ.GetItem(τmp2, λ.NewInt(1))
						λ.Cal(ϒsanitize_string_field, ϒformat, λ.NewStr("format_id"))
						λ.Cal(ϒsanitize_numeric_fields, ϒformat)
						λ.SetItem(ϒformat, λ.NewStr("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒformat, λ.NewStr("url"))))
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("format_id"))))) {
							λ.SetItem(ϒformat, λ.NewStr("format_id"), λ.Cal(ϒcompat_str, ϒi))
						} else {
							λ.SetItem(ϒformat, λ.NewStr("format_id"), λ.Cal(Ωre.ϒsub, λ.NewStr("[\\s,/+\\[\\]()]"), λ.NewStr("_"), λ.GetItem(ϒformat, λ.NewStr("format_id"))))
						}
						ϒformat_id = λ.GetItem(ϒformat, λ.NewStr("format_id"))
						if λ.IsTrue(λ.NewBool(!λ.Contains(ϒformats_dict, ϒformat_id))) {
							λ.SetItem(ϒformats_dict, ϒformat_id, λ.NewList())
						}
						λ.Cal(λ.GetAttr(λ.GetItem(ϒformats_dict, ϒformat_id), "append", nil), ϒformat)
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒformats_dict, "items", nil)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒformat_id = λ.GetItem(τmp2, λ.NewInt(0))
						ϒambiguous_formats = λ.GetItem(τmp2, λ.NewInt(1))
						if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒambiguous_formats), λ.NewInt(1))) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒambiguous_formats))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								τmp4 = τmp3
								ϒi = λ.GetItem(τmp4, λ.NewInt(0))
								ϒformat = λ.GetItem(τmp4, λ.NewInt(1))
								λ.SetItem(ϒformat, λ.NewStr("format_id"), λ.Mod(λ.NewStr("%s-%d"), λ.NewTuple(
									ϒformat_id,
									ϒi,
								)))
							}
						}
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒformats))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒi = λ.GetItem(τmp2, λ.NewInt(0))
						ϒformat = λ.GetItem(τmp2, λ.NewInt(1))
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("format")) == λ.None)) {
							λ.SetItem(ϒformat, λ.NewStr("format"), λ.Call(λ.GetAttr(λ.NewStr("{id} - {res}{note}"), "format", nil), nil, λ.KWArgs{
								{Name: "id", Value: λ.GetItem(ϒformat, λ.NewStr("format_id"))},
								{Name: "res", Value: λ.Cal(λ.GetAttr(ϒself, "format_resolution", nil), ϒformat)},
								{Name: "note", Value: func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("format_note")) != λ.None)) {
										return λ.Cal(λ.GetAttr(λ.NewStr(" ({0})"), "format", nil), λ.GetItem(ϒformat, λ.NewStr("format_note")))
									} else {
										return λ.NewStr("")
									}
								}()},
							}))
						}
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("ext")) == λ.None)) {
							λ.SetItem(ϒformat, λ.NewStr("ext"), λ.Cal(λ.GetAttr(λ.Cal(ϒdetermine_ext, λ.GetItem(ϒformat, λ.NewStr("url"))), "lower", nil)))
						}
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("protocol")) == λ.None)) {
							λ.SetItem(ϒformat, λ.NewStr("protocol"), λ.Cal(ϒdetermine_protocol, ϒformat))
						}
						ϒfull_format_info = λ.Cal(λ.GetAttr(ϒinfo_dict, "copy", nil))
						λ.Cal(λ.GetAttr(ϒfull_format_info, "update", nil), ϒformat)
						λ.SetItem(ϒformat, λ.NewStr("http_headers"), λ.Cal(λ.GetAttr(ϒself, "_calc_headers", nil), ϒfull_format_info))
					}
					if λ.IsTrue(λ.NewBool(λ.Contains(ϒinfo_dict, λ.NewStr("__x_forwarded_for_ip")))) {
						λ.DelItem(ϒinfo_dict, λ.NewStr("__x_forwarded_for_ip"))
					}
					if λ.IsTrue(λ.NewBool(λ.GetItem(ϒformats, λ.NewInt(0)) != ϒinfo_dict)) {
						λ.SetItem(ϒinfo_dict, λ.NewStr("formats"), ϒformats)
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("listformats"))) {
						λ.Cal(λ.GetAttr(ϒself, "list_formats", nil), ϒinfo_dict)
						return λ.None
					}
					ϒreq_format = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("format"))
					if λ.IsTrue(λ.NewBool(ϒreq_format == λ.None)) {
						ϒreq_format = λ.Call(λ.GetAttr(ϒself, "_default_format_spec", nil), λ.NewArgs(ϒinfo_dict), λ.KWArgs{
							{Name: "download", Value: ϒdownload},
						})
						if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("verbose"))) {
							λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.Mod(λ.NewStr("[debug] Default format spec: %s"), ϒreq_format))
						}
					}
					ϒformat_selector = λ.Cal(λ.GetAttr(ϒself, "build_format_selector", nil), ϒreq_format)
					ϒincomplete_formats = func() λ.Object {
						if λv := λ.Cal(λ.BuiltinAll, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒf   λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒf = τmp1
										λgy.Yield(func() λ.Object {
											if λv := λ.Ne(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none")); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Eq(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("acodec")), λ.NewStr("none"))
											}
										}())
									}
									return λ.None
								})
							}))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.BuiltinAll, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
										var (
											ϒf   λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒf = τmp1
											λgy.Yield(func() λ.Object {
												if λv := λ.Eq(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none")); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Ne(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("acodec")), λ.NewStr("none"))
												}
											}())
										}
										return λ.None
									})
								})))
						}
					}()
					ϒctx = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("formats"):            ϒformats,
						λ.NewStr("incomplete_formats"): ϒincomplete_formats,
					})
					ϒformats_to_download = λ.Cal(λ.ListType, λ.Cal(ϒformat_selector, ϒctx))
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒformats_to_download))) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("requested format not available")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					if λ.IsTrue(ϒdownload) {
						if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒformats_to_download), λ.NewInt(1))) {
							λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[info] %s: downloading video in %s formats"), λ.NewTuple(
								λ.GetItem(ϒinfo_dict, λ.NewStr("id")),
								λ.Cal(λ.BuiltinLen, ϒformats_to_download),
							)))
						}
						τmp0 = λ.Cal(λ.BuiltinIter, ϒformats_to_download)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒformat = τmp1
							ϒnew_info = λ.Cal(λ.DictType, ϒinfo_dict)
							λ.Cal(λ.GetAttr(ϒnew_info, "update", nil), ϒformat)
							λ.Cal(λ.GetAttr(ϒself, "process_info", nil), ϒnew_info)
						}
					}
					λ.Cal(λ.GetAttr(ϒinfo_dict, "update", nil), λ.GetItem(ϒformats_to_download, λ.Neg(λ.NewInt(1))))
					return ϒinfo_dict
				})
			YoutubeDL_process_subtitles = λ.NewFunction("process_subtitles",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
					{Name: "normal_subtitles"},
					{Name: "automatic_captions"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒautomatic_captions = λargs[3]
						ϒavailable_subs     λ.Object
						ϒcap_info           λ.Object
						ϒext                λ.Object
						ϒf                  λ.Object
						ϒformats            λ.Object
						ϒformats_preference λ.Object
						ϒformats_query      λ.Object
						ϒlang               λ.Object
						ϒmatches            λ.Object
						ϒnormal_subtitles   = λargs[2]
						ϒrequested_langs    λ.Object
						ϒself               = λargs[0]
						ϒsubs               λ.Object
						ϒvideo_id           = λargs[1]
						τmp0                λ.Object
						τmp1                λ.Object
						τmp2                λ.Object
						τmp3                λ.Object
					)
					ϒavailable_subs = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					if λ.IsTrue(func() λ.Object {
						if λv := ϒnormal_subtitles; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writesubtitles"))
						}
					}()) {
						λ.Cal(λ.GetAttr(ϒavailable_subs, "update", nil), ϒnormal_subtitles)
					}
					if λ.IsTrue(func() λ.Object {
						if λv := ϒautomatic_captions; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writeautomaticsub"))
						}
					}()) {
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒautomatic_captions, "items", nil)))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒlang = λ.GetItem(τmp2, λ.NewInt(0))
							ϒcap_info = λ.GetItem(τmp2, λ.NewInt(1))
							if λ.IsTrue(λ.NewBool(!λ.Contains(ϒavailable_subs, ϒlang))) {
								λ.SetItem(ϒavailable_subs, ϒlang, ϒcap_info)
							}
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writesubtitles")))); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writeautomaticsub"))))
							}
						}(); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒavailable_subs))
						}
					}()) {
						return λ.None
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("allsubtitles"), λ.False)) {
						ϒrequested_langs = λ.Cal(λ.GetAttr(ϒavailable_subs, "keys", nil))
					} else {
						if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("subtitleslangs"), λ.False)) {
							ϒrequested_langs = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("subtitleslangs"))
						} else {
							if λ.IsTrue(λ.NewBool(λ.Contains(ϒavailable_subs, λ.NewStr("en")))) {
								ϒrequested_langs = λ.NewList(λ.NewStr("en"))
							} else {
								ϒrequested_langs = λ.NewList(λ.GetItem(λ.Cal(λ.ListType, λ.Cal(λ.GetAttr(ϒavailable_subs, "keys", nil))), λ.NewInt(0)))
							}
						}
					}
					ϒformats_query = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("subtitlesformat"), λ.NewStr("best"))
					ϒformats_preference = func() λ.Object {
						if λ.IsTrue(ϒformats_query) {
							return λ.Cal(λ.GetAttr(ϒformats_query, "split", nil), λ.NewStr("/"))
						} else {
							return λ.NewList()
						}
					}()
					ϒsubs = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, ϒrequested_langs)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒlang = τmp1
						ϒformats = λ.Cal(λ.GetAttr(ϒavailable_subs, "get", nil), ϒlang)
						if λ.IsTrue(λ.NewBool(ϒformats == λ.None)) {
							λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s subtitles not available for %s"), λ.NewTuple(
								ϒlang,
								ϒvideo_id,
							)))
							continue
						}
						τmp2 = λ.Cal(λ.BuiltinIter, ϒformats_preference)
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒext = τmp3
							if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("best"))) {
								ϒf = λ.GetItem(ϒformats, λ.Neg(λ.NewInt(1)))
								break
							}
							ϒmatches = λ.Cal(λ.ListType, λ.Cal(λ.FilterIteratorType, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "f"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒf = λargs[0]
									)
									return λ.Eq(λ.GetItem(ϒf, λ.NewStr("ext")), ϒext)
								}), ϒformats))
							if λ.IsTrue(ϒmatches) {
								ϒf = λ.GetItem(ϒmatches, λ.Neg(λ.NewInt(1)))
								break
							}
						}
						if τmp3 == λ.AfterLast {
							ϒf = λ.GetItem(ϒformats, λ.Neg(λ.NewInt(1)))
							λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("No subtitle format found matching \"%s\" for language %s, using %s"), λ.NewTuple(
								ϒformats_query,
								ϒlang,
								λ.GetItem(ϒf, λ.NewStr("ext")),
							)))
						}
						λ.SetItem(ϒsubs, ϒlang, ϒf)
					}
					return ϒsubs
				})
			YoutubeDL___forced_printings = λ.NewFunction("__forced_printings",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
					{Name: "filename"},
					{Name: "incomplete"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf               λ.Object
						ϒfilename        = λargs[2]
						ϒincomplete      = λargs[3]
						ϒinfo_dict       = λargs[1]
						ϒprint_mandatory λ.Object
						ϒprint_optional  λ.Object
						ϒself            = λargs[0]
						τmp0             λ.Object
						τmp1             λ.Object
					)
					ϒprint_mandatory = λ.NewFunction("print_mandatory",
						[]λ.Param{
							{Name: "field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield = λargs[0]
							)
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.Mod(λ.NewStr("force%s"), ϒfield), λ.False); !λ.IsTrue(λv) {
									return λv
								} else {
									return func() λ.Object {
										if λv := λ.NewBool(!λ.IsTrue(ϒincomplete)); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), ϒfield) != λ.None)
										}
									}()
								}
							}()) {
								λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.GetItem(ϒinfo_dict, ϒfield))
							}
							return λ.None
						})
					ϒprint_optional = λ.NewFunction("print_optional",
						[]λ.Param{
							{Name: "field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield = λargs[0]
							)
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.Mod(λ.NewStr("force%s"), ϒfield), λ.False); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), ϒfield) != λ.None)
								}
							}()) {
								λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.GetItem(ϒinfo_dict, ϒfield))
							}
							return λ.None
						})
					λ.Cal(ϒprint_mandatory, λ.NewStr("title"))
					λ.Cal(ϒprint_mandatory, λ.NewStr("id"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("forceurl"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒincomplete))
						}
					}()) {
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("requested_formats")) != λ.None)) {
							τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒinfo_dict, λ.NewStr("requested_formats")))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒf = τmp1
								λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.Add(λ.GetItem(ϒf, λ.NewStr("url")), λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("play_path"), λ.NewStr(""))))
							}
						} else {
							λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.Add(λ.GetItem(ϒinfo_dict, λ.NewStr("url")), λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("play_path"), λ.NewStr(""))))
						}
					}
					λ.Cal(ϒprint_optional, λ.NewStr("thumbnail"))
					λ.Cal(ϒprint_optional, λ.NewStr("description"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("forcefilename"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(ϒfilename != λ.None)
						}
					}()) {
						λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), ϒfilename)
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("forceduration"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("duration")) != λ.None)
						}
					}()) {
						λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.Cal(λ.None, λ.GetItem(ϒinfo_dict, λ.NewStr("duration"))))
					}
					λ.Cal(ϒprint_mandatory, λ.NewStr("format"))
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("forcejson"), λ.False)) {
						λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.Cal(Ωjson.ϒdumps, ϒinfo_dict))
					}
					return λ.None
				})
			YoutubeDL_process_info = λ.NewFunction("process_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						INSTALL_FFMPEG_MESSAGE   λ.Object
						ϒannofile                λ.Object
						ϒannofn                  λ.Object
						ϒcompatible_formats      λ.Object
						ϒdescfile                λ.Object
						ϒdescfn                  λ.Object
						ϒdl                      λ.Object
						ϒdownloaded              λ.Object
						ϒensure_dir_exists       λ.Object
						ϒf                       λ.Object
						ϒfilename                λ.Object
						ϒfilename_real_ext       λ.Object
						ϒfilename_wo_ext         λ.Object
						ϒfixup_policy            λ.Object
						ϒfixup_pp                λ.Object
						ϒfname                   λ.Object
						ϒie                      λ.Object
						ϒinfo_dict               = λargs[1]
						ϒinfofn                  λ.Object
						ϒmax_downloads           λ.Object
						ϒmerger                  λ.Object
						ϒnew_info                λ.Object
						ϒpartial_success         λ.Object
						ϒpostprocessors          λ.Object
						ϒreason                  λ.Object
						ϒrequested_formats       λ.Object
						ϒself                    = λargs[0]
						ϒstretched_pp            λ.Object
						ϒstretched_ratio         λ.Object
						ϒsub_data                λ.Object
						ϒsub_filename            λ.Object
						ϒsub_format              λ.Object
						ϒsub_info                λ.Object
						ϒsub_lang                λ.Object
						ϒsubfile                 λ.Object
						ϒsubtitles               λ.Object
						ϒsubtitles_are_requested λ.Object
						ϒsuccess                 λ.Object
						τmp0                     λ.Object
						τmp1                     λ.Object
						τmp2                     λ.Object
						τmp3                     λ.Object
						τmp4                     λ.Object
						τmp5                     λ.Object
						τmp6                     λ.Object
						τmp7                     λ.Object
					)
					_ = τmp6
					_ = τmp7
					if !λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("_type"), λ.NewStr("video")), λ.NewStr("video"))) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					ϒmax_downloads = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("max_downloads"))
					if λ.IsTrue(λ.NewBool(ϒmax_downloads != λ.None)) {
						if λ.IsTrue(λ.Ge(λ.GetAttr(ϒself, "_num_downloads", nil), λ.Cal(λ.IntType, ϒmax_downloads))) {
							panic(λ.Raise(λ.Cal(MaxDownloadsReached)))
						}
					}
					λ.SetItem(ϒinfo_dict, λ.NewStr("fulltitle"), λ.GetItem(ϒinfo_dict, λ.NewStr("title")))
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒinfo_dict, λ.NewStr("format")))) {
						λ.SetItem(ϒinfo_dict, λ.NewStr("format"), λ.GetItem(ϒinfo_dict, λ.NewStr("ext")))
					}
					ϒreason = λ.Call(λ.GetAttr(ϒself, "_match_entry", nil), λ.NewArgs(ϒinfo_dict), λ.KWArgs{
						{Name: "incomplete", Value: λ.False},
					})
					if λ.IsTrue(λ.NewBool(ϒreason != λ.None)) {
						λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("[download] "), ϒreason))
						return λ.None
					}
					τmp0 = λ.IAdd(λ.GetAttr(ϒself, "_num_downloads", nil), λ.NewInt(1))
					λ.SetAttr(ϒself, "_num_downloads", τmp0)
					τmp0 = λ.Cal(λ.GetAttr(ϒself, "prepare_filename", nil), ϒinfo_dict)
					λ.SetItem(ϒinfo_dict, λ.NewStr("_filename"), τmp0)
					ϒfilename = τmp0
					λ.Call(λ.GetAttr(ϒself, "__forced_printings", nil), λ.NewArgs(
						ϒinfo_dict,
						ϒfilename,
					), λ.KWArgs{
						{Name: "incomplete", Value: λ.False},
					})
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("simulate"), λ.False)) {
						return λ.None
					}
					if λ.IsTrue(λ.NewBool(ϒfilename == λ.None)) {
						return λ.None
					}
					ϒensure_dir_exists = λ.NewFunction("ensure_dir_exists",
						[]λ.Param{
							{Name: "path"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdn   λ.Object
								ϒpath = λargs[0]
								τmp0  λ.Object
								τmp1  λ.Object
							)
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{λ.NewTuple(
										λ.OSErrorType,
										λ.OSErrorType,
									), func(λex λ.BaseException) {
										var ϒerr λ.Object = λex
										λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Add(λ.NewStr("unable to create directory "), λ.Cal(ϒerror_to_compat_str, ϒerr)))
										λexit, λret = λ.BlockExitReturn, λ.False
										return
									}},
								)
								ϒdn = λ.Cal(λ.None, ϒpath)
								if λ.IsTrue(func() λ.Object {
									if λv := ϒdn; !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(λ.None, ϒdn)))
									}
								}()) {
									λ.Cal(λ.None, ϒdn)
								}
								λexit, λret = λ.BlockExitReturn, λ.True
								return
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
							return λ.None
						})
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(ϒensure_dir_exists, λ.Cal(ϒsanitize_path, λ.Cal(λ.None, ϒfilename)))))) {
						return λ.None
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writedescription"), λ.False)) {
						ϒdescfn = λ.Cal(λ.None, ϒfilename, λ.NewStr("description"), λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("ext")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("nooverwrites"), λ.False); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.None, λ.Cal(λ.None, ϒdescfn))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.NewStr("[info] Video description is already present"))
						} else {
							if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("description")) == λ.None)) {
								λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("There's no description to write."))
							} else {
								τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.NewTuple(
											λ.OSErrorType,
											λ.OSErrorType,
										), func(λex λ.BaseException) {
											λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Add(λ.NewStr("Cannot write description file "), ϒdescfn))
											λexit, λret = λ.BlockExitReturn, λ.None
											return
										}},
									)
									λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("[info] Writing video description to: "), ϒdescfn))
									τmp2 = λ.Call(λ.None, λ.NewArgs(
										λ.Cal(λ.None, ϒdescfn),
										λ.NewStr("w"),
									), λ.KWArgs{
										{Name: "encoding", Value: λ.NewStr("utf-8")},
									})
									τmp3 = λ.GetAttr(τmp2, "__exit__", nil)
									ϒdescfile = λ.Cal(λ.GetAttr(τmp2, "__enter__", nil))
									τmp4, τmp5 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
											if ret := λ.Cal(τmp3, λex.Type(), λex, λ.NewStr("..todo..traceback..")); λ.IsTrue(ret) {
												panic(λ.Raise(λex))
											}
										}, func() {
											λ.Cal(τmp3, λ.None, λ.None, λ.None)
										})
										λ.Cal(λ.GetAttr(ϒdescfile, "write", nil), λ.GetItem(ϒinfo_dict, λ.NewStr("description")))
										return λ.BlockExitNormally, nil
									}()
									return λ.BlockExitNormally, nil
								}()
								if τmp0 == λ.BlockExitReturn {
									return τmp1
								}
							}
						}
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writeannotations"), λ.False)) {
						ϒannofn = λ.Cal(λ.None, ϒfilename, λ.NewStr("annotations.xml"), λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("ext")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("nooverwrites"), λ.False); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.None, λ.Cal(λ.None, ϒannofn))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.NewStr("[info] Video annotations are already present"))
						} else {
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("annotations"))))) {
								λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("There are no annotations to write."))
							} else {
								τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.NewTuple(
											λ.KeyErrorType,
											λ.TypeErrorType,
										), func(λex λ.BaseException) {
											λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("There are no annotations to write."))
										}},
										&λ.Catcher{λ.NewTuple(
											λ.OSErrorType,
											λ.OSErrorType,
										), func(λex λ.BaseException) {
											λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Add(λ.NewStr("Cannot write annotations file: "), ϒannofn))
											λexit, λret = λ.BlockExitReturn, λ.None
											return
										}},
									)
									λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("[info] Writing video annotations to: "), ϒannofn))
									τmp3 = λ.Call(λ.None, λ.NewArgs(
										λ.Cal(λ.None, ϒannofn),
										λ.NewStr("w"),
									), λ.KWArgs{
										{Name: "encoding", Value: λ.NewStr("utf-8")},
									})
									τmp2 = λ.GetAttr(τmp3, "__exit__", nil)
									ϒannofile = λ.Cal(λ.GetAttr(τmp3, "__enter__", nil))
									τmp5, τmp4 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
											if ret := λ.Cal(τmp2, λex.Type(), λex, λ.NewStr("..todo..traceback..")); λ.IsTrue(ret) {
												panic(λ.Raise(λex))
											}
										}, func() {
											λ.Cal(τmp2, λ.None, λ.None, λ.None)
										})
										λ.Cal(λ.GetAttr(ϒannofile, "write", nil), λ.GetItem(ϒinfo_dict, λ.NewStr("annotations")))
										return λ.BlockExitNormally, nil
									}()
									return λ.BlockExitNormally, nil
								}()
								if τmp1 == λ.BlockExitReturn {
									return τmp0
								}
							}
						}
					}
					ϒsubtitles_are_requested = λ.Cal(λ.BuiltinAny, λ.NewList(
						λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writesubtitles"), λ.False),
						λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writeautomaticsub")),
					))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒsubtitles_are_requested; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("requested_subtitles"))
						}
					}()) {
						ϒsubtitles = λ.GetItem(ϒinfo_dict, λ.NewStr("requested_subtitles"))
						ϒie = λ.Cal(λ.GetAttr(ϒself, "get_info_extractor", nil), λ.GetItem(ϒinfo_dict, λ.NewStr("extractor_key")))
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒsubtitles, "items", nil)))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒsub_lang = λ.GetItem(τmp2, λ.NewInt(0))
							ϒsub_info = λ.GetItem(τmp2, λ.NewInt(1))
							ϒsub_format = λ.GetItem(ϒsub_info, λ.NewStr("ext"))
							ϒsub_filename = λ.Cal(λ.None, ϒfilename, ϒsub_lang, ϒsub_format, λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("ext")))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("nooverwrites"), λ.False); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.None, λ.Cal(λ.None, ϒsub_filename))
								}
							}()) {
								λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[info] Video subtitle %s.%s is already present"), λ.NewTuple(
									ϒsub_lang,
									ϒsub_format,
								)))
							} else {
								λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("[info] Writing video subtitles to: "), ϒsub_filename))
								if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒsub_info, "get", nil), λ.NewStr("data")) != λ.None)) {
									τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.CatchMulti(
											nil,
											&λ.Catcher{λ.NewTuple(
												λ.OSErrorType,
												λ.OSErrorType,
											), func(λex λ.BaseException) {
												λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Add(λ.NewStr("Cannot write subtitles file "), ϒsub_filename))
												λexit, λret = λ.BlockExitReturn, λ.None
												return
											}},
										)
										τmp4 = λ.Call(λ.None, λ.NewArgs(
											λ.Cal(λ.None, ϒsub_filename),
											λ.NewStr("w"),
										), λ.KWArgs{
											{Name: "encoding", Value: λ.NewStr("utf-8")},
											{Name: "newline", Value: λ.NewStr("")},
										})
										τmp5 = λ.GetAttr(τmp4, "__exit__", nil)
										ϒsubfile = λ.Cal(λ.GetAttr(τmp4, "__enter__", nil))
										τmp6, τmp7 = func() (λexit λ.Object, λret λ.Object) {
											defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
												if ret := λ.Cal(τmp5, λex.Type(), λex, λ.NewStr("..todo..traceback..")); λ.IsTrue(ret) {
													panic(λ.Raise(λex))
												}
											}, func() {
												λ.Cal(τmp5, λ.None, λ.None, λ.None)
											})
											λ.Cal(λ.GetAttr(ϒsubfile, "write", nil), λ.GetItem(ϒsub_info, λ.NewStr("data")))
											return λ.BlockExitNormally, nil
										}()
										return λ.BlockExitNormally, nil
									}()
									if τmp2 == λ.BlockExitReturn {
										return τmp3
									}
								} else {
									τmp3, τmp2 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.CatchMulti(
											nil,
											&λ.Catcher{λ.NewTuple(
												ExtractorError,
												λ.OSErrorType,
												λ.OSErrorType,
												λ.ValueErrorType,
											), func(λex λ.BaseException) {
												var ϒerr λ.Object = λex
												λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("Unable to download subtitle for \"%s\": %s"), λ.NewTuple(
													ϒsub_lang,
													λ.Cal(ϒerror_to_compat_str, ϒerr),
												)))
												λexit = λ.BlockExitContinue
												return
											}},
										)
										ϒsub_data = λ.Cal(λ.GetAttr(λ.Call(λ.GetAttr(ϒie, "_request_webpage", nil), λ.NewArgs(
											λ.GetItem(ϒsub_info, λ.NewStr("url")),
											λ.GetItem(ϒinfo_dict, λ.NewStr("id")),
										), λ.KWArgs{
											{Name: "note", Value: λ.False},
										}), "read", nil))
										τmp5 = λ.Cal(λ.None, λ.Cal(λ.None, ϒsub_filename), λ.NewStr("wb"))
										τmp4 = λ.GetAttr(τmp5, "__exit__", nil)
										ϒsubfile = λ.Cal(λ.GetAttr(τmp5, "__enter__", nil))
										τmp7, τmp6 = func() (λexit λ.Object, λret λ.Object) {
											defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
												if ret := λ.Cal(τmp4, λex.Type(), λex, λ.NewStr("..todo..traceback..")); λ.IsTrue(ret) {
													panic(λ.Raise(λex))
												}
											}, func() {
												λ.Cal(τmp4, λ.None, λ.None, λ.None)
											})
											λ.Cal(λ.GetAttr(ϒsubfile, "write", nil), ϒsub_data)
											return λ.BlockExitNormally, nil
										}()
										return λ.BlockExitNormally, nil
									}()
									if τmp3 == λ.BlockExitContinue {
										continue
									}
								}
							}
						}
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("writeinfojson"), λ.False)) {
						ϒinfofn = λ.Cal(λ.None, ϒfilename, λ.NewStr("info.json"), λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("ext")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("nooverwrites"), λ.False); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.None, λ.Cal(λ.None, ϒinfofn))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.NewStr("[info] Video description metadata is already present"))
						} else {
							λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("[info] Writing video description metadata as JSON to: "), ϒinfofn))
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{λ.NewTuple(
										λ.OSErrorType,
										λ.OSErrorType,
									), func(λex λ.BaseException) {
										λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Add(λ.NewStr("Cannot write metadata to JSON file "), ϒinfofn))
										λexit, λret = λ.BlockExitReturn, λ.None
										return
									}},
								)
								λ.Cal(λ.None, λ.Cal(λ.GetAttr(ϒself, "filter_requested_info", nil), ϒinfo_dict), ϒinfofn)
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
						}
					}
					λ.Cal(λ.GetAttr(ϒself, "_write_thumbnails", nil), ϒinfo_dict, ϒfilename)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("skip_download"), λ.False)))) {
						τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.NewTuple(
									Ωerror.URLError,
									λ.GetAttr(ϒcompat_http_client, "HTTPException", nil),
									Ωsocket.ϒerror,
								), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Mod(λ.NewStr("unable to download video data: %s"), λ.Cal(ϒerror_to_compat_str, ϒerr)))
									λexit, λret = λ.BlockExitReturn, λ.None
									return
								}},
								&λ.Catcher{λ.NewTuple(
									λ.OSErrorType,
									λ.OSErrorType,
								), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									panic(λ.Raise(λ.Cal(UnavailableVideoError, ϒerr)))
								}},
								&λ.Catcher{λ.NewTuple(λ.None), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Mod(λ.NewStr("content too short (expected %s bytes and served %s)"), λ.NewTuple(
										λ.GetAttr(ϒerr, "expected", nil),
										λ.GetAttr(ϒerr, "downloaded", nil),
									)))
									λexit, λret = λ.BlockExitReturn, λ.None
									return
								}},
							)
							ϒdl = λ.NewFunction("dl",
								[]λ.Param{
									{Name: "name"},
									{Name: "info"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒfd   λ.Object
										ϒinfo = λargs[1]
										ϒname = λargs[0]
										ϒph   λ.Object
										τmp0  λ.Object
										τmp1  λ.Object
									)
									ϒfd = λ.Cal(λ.Cal(λ.None, ϒinfo, λ.GetAttr(ϒself, "params", nil)), ϒself, λ.GetAttr(ϒself, "params", nil))
									τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_progress_hooks", nil))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒph = τmp1
										λ.Cal(λ.GetAttr(ϒfd, "add_progress_hook", nil), ϒph)
									}
									if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("verbose"))) {
										λ.Cal(λ.GetAttr(ϒself, "to_stdout", nil), λ.Mod(λ.NewStr("[debug] Invoking downloader on %r"), λ.Cal(λ.GetAttr(ϒinfo, "get", nil), λ.NewStr("url"))))
									}
									return λ.Cal(λ.GetAttr(ϒfd, "download", nil), ϒname, ϒinfo)
								})
							if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("requested_formats")) != λ.None)) {
								ϒdownloaded = λ.NewList()
								ϒsuccess = λ.True
								ϒmerger = λ.Cal(λ.None, ϒself)
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.GetAttr(ϒmerger, "available", nil)))) {
									ϒpostprocessors = λ.NewList()
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("You have requested multiple formats but ffmpeg or avconv are not installed. The formats won't be merged."))
								} else {
									ϒpostprocessors = λ.NewList(ϒmerger)
								}
								ϒcompatible_formats = λ.NewFunction("compatible_formats",
									[]λ.Param{
										{Name: "formats"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											COMPATIBLE_EXTS λ.Object
											ϒaudio          λ.Object
											ϒaudio_ext      λ.Object
											ϒexts           λ.Object
											ϒformats        = λargs[0]
											ϒvideo          λ.Object
											ϒvideo_ext      λ.Object
											τmp0            λ.Object
											τmp1            λ.Object
										)
										τmp0 = ϒformats
										ϒvideo = λ.GetItem(τmp0, λ.NewInt(0))
										ϒaudio = λ.GetItem(τmp0, λ.NewInt(1))
										τmp0 = λ.NewTuple(
											λ.Cal(λ.GetAttr(ϒvideo, "get", nil), λ.NewStr("ext")),
											λ.Cal(λ.GetAttr(ϒaudio, "get", nil), λ.NewStr("ext")),
										)
										ϒvideo_ext = λ.GetItem(τmp0, λ.NewInt(0))
										ϒaudio_ext = λ.GetItem(τmp0, λ.NewInt(1))
										if λ.IsTrue(func() λ.Object {
											if λv := ϒvideo_ext; !λ.IsTrue(λv) {
												return λv
											} else {
												return ϒaudio_ext
											}
										}()) {
											COMPATIBLE_EXTS = λ.NewTuple(
												λ.NewTuple(
													λ.NewStr("mp3"),
													λ.NewStr("mp4"),
													λ.NewStr("m4a"),
													λ.NewStr("m4p"),
													λ.NewStr("m4b"),
													λ.NewStr("m4r"),
													λ.NewStr("m4v"),
													λ.NewStr("ismv"),
													λ.NewStr("isma"),
												),
												λ.NewStr("webm"),
											)
											τmp0 = λ.Cal(λ.BuiltinIter, COMPATIBLE_EXTS)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒexts = τmp1
												if λ.IsTrue(func() λ.Object {
													if λv := λ.NewBool(λ.Contains(ϒexts, ϒvideo_ext)); !λ.IsTrue(λv) {
														return λv
													} else {
														return λ.NewBool(λ.Contains(ϒexts, ϒaudio_ext))
													}
												}()) {
													return λ.True
												}
											}
										}
										return λ.False
									})
								ϒfilename_real_ext = λ.GetItem(λ.GetItem(λ.Cal(λ.None, ϒfilename), λ.NewInt(1)), λ.NewSlice(λ.NewInt(1), λ.None, λ.None))
								ϒfilename_wo_ext = func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒfilename_real_ext, λ.GetItem(ϒinfo_dict, λ.NewStr("ext")))) {
										return λ.GetItem(λ.Cal(λ.None, ϒfilename), λ.NewInt(0))
									} else {
										return ϒfilename
									}
								}()
								ϒrequested_formats = λ.GetItem(ϒinfo_dict, λ.NewStr("requested_formats"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("merge_output_format")) == λ.None); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(ϒcompatible_formats, ϒrequested_formats)))
									}
								}()) {
									λ.SetItem(ϒinfo_dict, λ.NewStr("ext"), λ.NewStr("mkv"))
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.NewStr("Requested formats are incompatible for merge and will be merged into mkv."))
								}
								ϒfilename = λ.Mod(λ.NewStr("%s.%s"), λ.NewTuple(
									ϒfilename_wo_ext,
									λ.GetItem(ϒinfo_dict, λ.NewStr("ext")),
								))
								if λ.IsTrue(λ.Cal(λ.None, λ.Cal(λ.None, ϒfilename))) {
									λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("[download] %s has already been downloaded and merged"), ϒfilename))
								} else {
									τmp2 = λ.Cal(λ.BuiltinIter, ϒrequested_formats)
									for {
										if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
											break
										}
										ϒf = τmp3
										ϒnew_info = λ.Cal(λ.DictType, ϒinfo_dict)
										λ.Cal(λ.GetAttr(ϒnew_info, "update", nil), ϒf)
										ϒfname = λ.Cal(λ.None, λ.Cal(λ.GetAttr(ϒself, "prepare_filename", nil), ϒnew_info), λ.Mod(λ.NewStr("f%s"), λ.GetItem(ϒf, λ.NewStr("format_id"))), λ.GetItem(ϒnew_info, λ.NewStr("ext")))
										if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(ϒensure_dir_exists, ϒfname)))) {
											λexit, λret = λ.BlockExitReturn, λ.None
											return
										}
										λ.Cal(λ.GetAttr(ϒdownloaded, "append", nil), ϒfname)
										ϒpartial_success = λ.Cal(ϒdl, ϒfname, ϒnew_info)
										ϒsuccess = func() λ.Object {
											if λv := ϒsuccess; !λ.IsTrue(λv) {
												return λv
											} else {
												return ϒpartial_success
											}
										}()
									}
									λ.SetItem(ϒinfo_dict, λ.NewStr("__postprocessors"), ϒpostprocessors)
									λ.SetItem(ϒinfo_dict, λ.NewStr("__files_to_merge"), ϒdownloaded)
								}
							} else {
								ϒsuccess = λ.Cal(ϒdl, ϒfilename, ϒinfo_dict)
							}
							return λ.BlockExitNormally, nil
						}()
						if τmp1 == λ.BlockExitReturn {
							return τmp0
						}
						if λ.IsTrue(func() λ.Object {
							if λv := ϒsuccess; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Ne(ϒfilename, λ.NewStr("-"))
							}
						}()) {
							ϒfixup_policy = λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("fixup"))
							if λ.IsTrue(λ.NewBool(ϒfixup_policy == λ.None)) {
								ϒfixup_policy = λ.NewStr("detect_or_warn")
							}
							INSTALL_FFMPEG_MESSAGE = λ.NewStr("Install ffmpeg or avconv to fix this automatically.")
							ϒstretched_ratio = λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("stretched_ratio"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(ϒstretched_ratio != λ.None); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Ne(ϒstretched_ratio, λ.NewInt(1))
								}
							}()) {
								if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.NewStr("warn"))) {
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s: Non-uniform pixel ratio (%s)"), λ.NewTuple(
										λ.GetItem(ϒinfo_dict, λ.NewStr("id")),
										ϒstretched_ratio,
									)))
								} else {
									if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.NewStr("detect_or_warn"))) {
										ϒstretched_pp = λ.Cal(λ.None, ϒself)
										if λ.IsTrue(λ.GetAttr(ϒstretched_pp, "available", nil)) {
											λ.Cal(λ.GetAttr(ϒinfo_dict, "setdefault", nil), λ.NewStr("__postprocessors"), λ.NewList())
											λ.Cal(λ.GetAttr(λ.GetItem(ϒinfo_dict, λ.NewStr("__postprocessors")), "append", nil), ϒstretched_pp)
										} else {
											λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s: Non-uniform pixel ratio (%s). %s"), λ.NewTuple(
												λ.GetItem(ϒinfo_dict, λ.NewStr("id")),
												ϒstretched_ratio,
												INSTALL_FFMPEG_MESSAGE,
											)))
										}
									} else {
										if !λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("ignore"),
											λ.NewStr("never"),
										), ϒfixup_policy))) {
											panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
										}
									}
								}
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("requested_formats")) == λ.None); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("container")), λ.NewStr("m4a_dash"))
								}
							}()) {
								if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.NewStr("warn"))) {
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s: writing DASH m4a. Only some players support this container."), λ.GetItem(ϒinfo_dict, λ.NewStr("id"))))
								} else {
									if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.NewStr("detect_or_warn"))) {
										ϒfixup_pp = λ.Cal(λ.None, ϒself)
										if λ.IsTrue(λ.GetAttr(ϒfixup_pp, "available", nil)) {
											λ.Cal(λ.GetAttr(ϒinfo_dict, "setdefault", nil), λ.NewStr("__postprocessors"), λ.NewList())
											λ.Cal(λ.GetAttr(λ.GetItem(ϒinfo_dict, λ.NewStr("__postprocessors")), "append", nil), ϒfixup_pp)
										} else {
											λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s: writing DASH m4a. Only some players support this container. %s"), λ.NewTuple(
												λ.GetItem(ϒinfo_dict, λ.NewStr("id")),
												INSTALL_FFMPEG_MESSAGE,
											)))
										}
									} else {
										if !λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("ignore"),
											λ.NewStr("never"),
										), ϒfixup_policy))) {
											panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
										}
									}
								}
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("protocol")), λ.NewStr("m3u8_native")); λ.IsTrue(λv) {
									return λv
								} else {
									return func() λ.Object {
										if λv := λ.Eq(λ.Cal(λ.GetAttr(ϒinfo_dict, "get", nil), λ.NewStr("protocol")), λ.NewStr("m3u8")); !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "params", nil), "get", nil), λ.NewStr("hls_prefer_native"))
										}
									}()
								}
							}()) {
								if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.NewStr("warn"))) {
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s: malformed AAC bitstream detected."), λ.GetItem(ϒinfo_dict, λ.NewStr("id"))))
								} else {
									if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.NewStr("detect_or_warn"))) {
										ϒfixup_pp = λ.Cal(λ.None, ϒself)
										if λ.IsTrue(λ.GetAttr(ϒfixup_pp, "available", nil)) {
											λ.Cal(λ.GetAttr(ϒinfo_dict, "setdefault", nil), λ.NewStr("__postprocessors"), λ.NewList())
											λ.Cal(λ.GetAttr(λ.GetItem(ϒinfo_dict, λ.NewStr("__postprocessors")), "append", nil), ϒfixup_pp)
										} else {
											λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s: malformed AAC bitstream detected. %s"), λ.NewTuple(
												λ.GetItem(ϒinfo_dict, λ.NewStr("id")),
												INSTALL_FFMPEG_MESSAGE,
											)))
										}
									} else {
										if !λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("ignore"),
											λ.NewStr("never"),
										), ϒfixup_policy))) {
											panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
										}
									}
								}
							}
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{PostProcessingError, func(λex λ.BaseException) {
										var ϒerr λ.Object = λex
										λ.Cal(λ.GetAttr(ϒself, "report_error", nil), λ.Mod(λ.NewStr("postprocessing: %s"), λ.Cal(λ.StrType, ϒerr)))
										λexit, λret = λ.BlockExitReturn, λ.None
										return
									}},
								)
								λ.Cal(λ.GetAttr(ϒself, "post_process", nil), ϒfilename, ϒinfo_dict)
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
							λ.Cal(λ.GetAttr(ϒself, "record_download_archive", nil), ϒinfo_dict)
						}
					}
					return λ.None
				})
			YoutubeDL_format_resolution = λ.NewFunction("format_resolution",
				[]λ.Param{
					{Name: "format"},
					{Name: "default", Def: λ.NewStr("unknown")},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdefault = λargs[1]
						ϒformat  = λargs[0]
						ϒres     λ.Object
					)
					if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none"))) {
						return λ.NewStr("audio only")
					}
					if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("resolution")) != λ.None)) {
						return λ.GetItem(ϒformat, λ.NewStr("resolution"))
					}
					if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("height")) != λ.None)) {
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("width")) != λ.None)) {
							ϒres = λ.Mod(λ.NewStr("%sx%s"), λ.NewTuple(
								λ.GetItem(ϒformat, λ.NewStr("width")),
								λ.GetItem(ϒformat, λ.NewStr("height")),
							))
						} else {
							ϒres = λ.Mod(λ.NewStr("%sp"), λ.GetItem(ϒformat, λ.NewStr("height")))
						}
					} else {
						if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒformat, "get", nil), λ.NewStr("width")) != λ.None)) {
							ϒres = λ.Mod(λ.NewStr("%dx?"), λ.GetItem(ϒformat, λ.NewStr("width")))
						} else {
							ϒres = ϒdefault
						}
					}
					return ϒres
				})
			YoutubeDL_format_resolution = λ.Cal(λ.StaticMethodType, YoutubeDL_format_resolution)
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_NUMERIC_FIELDS"):             YoutubeDL__NUMERIC_FIELDS,
				λ.NewStr("__forced_printings"):          YoutubeDL___forced_printings,
				λ.NewStr("_bidi_workaround"):            YoutubeDL__bidi_workaround,
				λ.NewStr("_calc_cookies"):               YoutubeDL__calc_cookies,
				λ.NewStr("_calc_headers"):               YoutubeDL__calc_headers,
				λ.NewStr("_default_format_spec"):        YoutubeDL__default_format_spec,
				λ.NewStr("_ies"):                        YoutubeDL__ies,
				λ.NewStr("_num_downloads"):              YoutubeDL__num_downloads,
				λ.NewStr("_screen_file"):                YoutubeDL__screen_file,
				λ.NewStr("add_default_extra_info"):      YoutubeDL_add_default_extra_info,
				λ.NewStr("add_default_info_extractors"): YoutubeDL_add_default_info_extractors,
				λ.NewStr("add_extra_info"):              YoutubeDL_add_extra_info,
				λ.NewStr("add_info_extractor"):          YoutubeDL_add_info_extractor,
				λ.NewStr("extract_info"):                YoutubeDL_extract_info,
				λ.NewStr("format_resolution"):           YoutubeDL_format_resolution,
				λ.NewStr("get_info_extractor"):          YoutubeDL_get_info_extractor,
				λ.NewStr("params"):                      YoutubeDL_params,
				λ.NewStr("prepare_filename"):            YoutubeDL_prepare_filename,
				λ.NewStr("process_ie_result"):           YoutubeDL_process_ie_result,
				λ.NewStr("process_info"):                YoutubeDL_process_info,
				λ.NewStr("process_subtitles"):           YoutubeDL_process_subtitles,
				λ.NewStr("process_video_result"):        YoutubeDL_process_video_result,
				λ.NewStr("report_error"):                YoutubeDL_report_error,
				λ.NewStr("report_warning"):              YoutubeDL_report_warning,
				λ.NewStr("to_screen"):                   YoutubeDL_to_screen,
				λ.NewStr("to_stderr"):                   YoutubeDL_to_stderr,
				λ.NewStr("to_stdout"):                   YoutubeDL_to_stdout,
				λ.NewStr("trouble"):                     YoutubeDL_trouble,
			})
		}())
	})
}

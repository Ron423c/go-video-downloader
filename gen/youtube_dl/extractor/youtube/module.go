// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2018 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * youtube/module.go: transpiled from https://github.com/rg3/youtube-dl/blob/master/youtube_dl/extractor/youtube.py
 */

package youtube

import (
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωtime "github.com/tenta-browser/go-video-downloader/gen/time"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError                    λ.Object
	InfoExtractor                     λ.Object
	SearchInfoExtractor               λ.Object
	YoutubeBaseInfoExtractor          λ.Object
	YoutubeChannelIE                  λ.Object
	YoutubeEntryListBaseInfoExtractor λ.Object
	YoutubeFavouritesIE               λ.Object
	YoutubeFeedsInfoExtractor         λ.Object
	YoutubeHistoryIE                  λ.Object
	YoutubeIE                         λ.Object
	YoutubeLiveIE                     λ.Object
	YoutubePlaylistBaseInfoExtractor  λ.Object
	YoutubePlaylistIE                 λ.Object
	YoutubePlaylistsBaseInfoExtractor λ.Object
	YoutubePlaylistsIE                λ.Object
	YoutubeRecommendedIE              λ.Object
	YoutubeSearchBaseInfoExtractor    λ.Object
	YoutubeSearchIE                   λ.Object
	YoutubeSearchURLIE                λ.Object
	YoutubeShowIE                     λ.Object
	YoutubeSubscriptionsIE            λ.Object
	YoutubeTruncatedIDIE              λ.Object
	YoutubeTruncatedURLIE             λ.Object
	YoutubeUserIE                     λ.Object
	YoutubeWatchLaterIE               λ.Object
	ϒclean_html                       λ.Object
	ϒcompat_chr                       λ.Object
	ϒcompat_kwargs                    λ.Object
	ϒcompat_parse_qs                  λ.Object
	ϒcompat_str                       λ.Object
	ϒcompat_urllib_parse_unquote      λ.Object
	ϒcompat_urllib_parse_unquote_plus λ.Object
	ϒcompat_urllib_parse_urlencode    λ.Object
	ϒcompat_urllib_parse_urlparse     λ.Object
	ϒerror_to_compat_str              λ.Object
	ϒfloat_or_none                    λ.Object
	ϒget_element_by_attribute         λ.Object
	ϒget_element_by_id                λ.Object
	ϒint_or_none                      λ.Object
	ϒmimetype2ext                     λ.Object
	ϒorderedSet                       λ.Object
	ϒparse_codecs                     λ.Object
	ϒparse_duration                   λ.Object
	ϒqualities                        λ.Object
	ϒremove_start                     λ.Object
	ϒsmuggle_url                      λ.Object
	ϒstr_or_none                      λ.Object
	ϒstr_to_int                       λ.Object
	ϒtry_get                          λ.Object
	ϒunescapeHTML                     λ.Object
	ϒunified_strdate                  λ.Object
	ϒunsmuggle_url                    λ.Object
	ϒuppercase_escape                 λ.Object
	ϒurl_or_none                      λ.Object
	ϒurlencode_postdata               λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		SearchInfoExtractor = Ωcommon.SearchInfoExtractor
		ϒcompat_chr = Ωcompat.ϒcompat_chr
		ϒcompat_kwargs = Ωcompat.ϒcompat_kwargs
		ϒcompat_parse_qs = Ωcompat.ϒcompat_parse_qs
		ϒcompat_urllib_parse_unquote = Ωcompat.ϒcompat_urllib_parse_unquote
		ϒcompat_urllib_parse_unquote_plus = Ωcompat.ϒcompat_urllib_parse_unquote_plus
		ϒcompat_urllib_parse_urlencode = Ωcompat.ϒcompat_urllib_parse_urlencode
		ϒcompat_urllib_parse_urlparse = Ωcompat.ϒcompat_urllib_parse_urlparse
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒclean_html = Ωutils.ϒclean_html
		ϒerror_to_compat_str = Ωutils.ϒerror_to_compat_str
		ExtractorError = Ωutils.ExtractorError
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		ϒget_element_by_attribute = Ωutils.ϒget_element_by_attribute
		ϒget_element_by_id = Ωutils.ϒget_element_by_id
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒmimetype2ext = Ωutils.ϒmimetype2ext
		ϒorderedSet = Ωutils.ϒorderedSet
		ϒparse_codecs = Ωutils.ϒparse_codecs
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒqualities = Ωutils.ϒqualities
		ϒremove_start = Ωutils.ϒremove_start
		ϒsmuggle_url = Ωutils.ϒsmuggle_url
		ϒstr_or_none = Ωutils.ϒstr_or_none
		ϒstr_to_int = Ωutils.ϒstr_to_int
		ϒtry_get = Ωutils.ϒtry_get
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunsmuggle_url = Ωutils.ϒunsmuggle_url
		ϒuppercase_escape = Ωutils.ϒuppercase_escape
		ϒurl_or_none = Ωutils.ϒurl_or_none
		ϒurlencode_postdata = Ωutils.ϒurlencode_postdata
		YoutubeBaseInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("YoutubeBaseInfoExtractor"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				YoutubeBaseInfoExtractor__LOGIN_REQUIRED          λ.Object
				YoutubeBaseInfoExtractor__NETRC_MACHINE           λ.Object
				YoutubeBaseInfoExtractor__PLAYLIST_ID_RE          λ.Object
				YoutubeBaseInfoExtractor__download_webpage_handle λ.Object
				YoutubeBaseInfoExtractor__login                   λ.Object
				YoutubeBaseInfoExtractor__real_initialize         λ.Object
				YoutubeBaseInfoExtractor__set_language            λ.Object
			)
			λ.NewStr("Provide base functions for Youtube extractors")
			YoutubeBaseInfoExtractor__NETRC_MACHINE = λ.NewStr("youtube")
			YoutubeBaseInfoExtractor__LOGIN_REQUIRED = λ.False
			YoutubeBaseInfoExtractor__PLAYLIST_ID_RE = λ.NewStr("(?:PL|LL|EC|UU|FL|RD|UL|TL|OLAK5uy_)[0-9A-Za-z-_]{10,}")
			YoutubeBaseInfoExtractor__set_language = λ.NewFunction("_set_language",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.Call(λ.GetAttr(ϒself, "_set_cookie", nil), λ.NewArgs(
						λ.NewStr(".youtube.com"),
						λ.NewStr("PREF"),
						λ.NewStr("f1=50000000&hl=en"),
					), λ.KWArgs{
						{Name: "expire_time", Value: λ.Add(λ.Cal(Ωtime.ϒtime), λ.Mul(λ.Mul(λ.Mul(λ.NewInt(2), λ.NewInt(30)), λ.NewInt(24)), λ.NewInt(3600)))},
					})
					return λ.None
				})
			YoutubeBaseInfoExtractor__login = λ.NewFunction("_login",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						CHALLENGES            λ.Object
						ϒchallenge            λ.Object
						ϒchallenge_req        λ.Object
						ϒchallenge_results    λ.Object
						ϒchallenge_str        λ.Object
						ϒcheck_cookie_results λ.Object
						ϒcheck_cookie_url     λ.Object
						ϒlogin_challenge      λ.Object
						ϒlogin_form           λ.Object
						ϒlogin_msg            λ.Object
						ϒlogin_page           λ.Object
						ϒlogin_res            λ.Object
						ϒlookup_req           λ.Object
						ϒlookup_results       λ.Object
						ϒpassword             λ.Object
						ϒreq                  λ.Object
						ϒres                  λ.Object
						ϒself                 = λargs[0]
						ϒstatus               λ.Object
						ϒtfa_code             λ.Object
						ϒtfa_msg              λ.Object
						ϒtfa_req              λ.Object
						ϒtfa_res              λ.Object
						ϒtfa_results          λ.Object
						ϒtl                   λ.Object
						ϒuser_hash            λ.Object
						ϒusername             λ.Object
						ϒwarn                 λ.Object
						τmp0                  λ.Object
					)
					λ.NewStr("\n        Attempt to log in to YouTube.\n        True is returned if successful or skipped.\n        False is returned if login failed.\n\n        If _LOGIN_REQUIRED is set and no authentication was provided, an error is raised.\n        ")
					τmp0 = λ.Cal(λ.GetAttr(ϒself, "_get_login_info", nil))
					ϒusername = λ.GetItem(τmp0, λ.NewInt(0))
					ϒpassword = λ.GetItem(τmp0, λ.NewInt(1))
					if λ.IsTrue(λ.NewBool(ϒusername == λ.None)) {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.GetAttr(ϒself, "_LOGIN_REQUIRED", nil); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("cookiefile")) == λ.None)
							}
						}()) {
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Mod(λ.NewStr("No login info available, needed for using %s."), λ.GetAttr(ϒself, "IE_NAME", nil))), λ.KWArgs{
								{Name: "expected", Value: λ.True},
							})))
						}
						return λ.True
					}
					ϒlogin_page = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
						λ.GetAttr(ϒself, "_LOGIN_URL", nil),
						λ.None,
					), λ.KWArgs{
						{Name: "note", Value: λ.NewStr("Downloading login page")},
						{Name: "errnote", Value: λ.NewStr("unable to fetch login page")},
						{Name: "fatal", Value: λ.False},
					})
					if λ.IsTrue(λ.NewBool(ϒlogin_page == λ.False)) {
						return λ.None
					}
					ϒlogin_form = λ.Cal(λ.GetAttr(ϒself, "_hidden_inputs", nil), ϒlogin_page)
					ϒreq = λ.NewFunction("req",
						[]λ.Param{
							{Name: "url"},
							{Name: "f_req"},
							{Name: "note"},
							{Name: "errnote"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdata    λ.Object
								ϒerrnote = λargs[3]
								ϒf_req   = λargs[1]
								ϒnote    = λargs[2]
								ϒurl     = λargs[0]
							)
							ϒdata = λ.Cal(λ.GetAttr(ϒlogin_form, "copy", nil))
							λ.Cal(λ.GetAttr(ϒdata, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("pstMsg"):          λ.NewInt(1),
								λ.NewStr("checkConnection"): λ.NewStr("youtube"),
								λ.NewStr("checkedDomains"):  λ.NewStr("youtube"),
								λ.NewStr("hl"):              λ.NewStr("en"),
								λ.NewStr("deviceinfo"):      λ.NewStr("[null,null,null,[],null,\"US\",null,null,[],\"GlifWebSignIn\",null,[null,null,[]]]"),
								λ.NewStr("f.req"):           λ.Cal(Ωjson.ϒdumps, ϒf_req),
								λ.NewStr("flowName"):        λ.NewStr("GlifWebSignIn"),
								λ.NewStr("flowEntry"):       λ.NewStr("ServiceLogin"),
							}))
							return λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
								ϒurl,
								λ.None,
							), λ.KWArgs{
								{Name: "note", Value: ϒnote},
								{Name: "errnote", Value: ϒerrnote},
								{Name: "transform_source", Value: λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "s"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒs = λargs[0]
										)
										return λ.Cal(Ωre.ϒsub, λ.NewStr("^[^[]*"), λ.NewStr(""), ϒs)
									})},
								{Name: "fatal", Value: λ.False},
								{Name: "data", Value: λ.Cal(ϒurlencode_postdata, ϒdata)},
								{Name: "headers", Value: λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("Content-Type"):         λ.NewStr("application/x-www-form-urlencoded;charset=utf-8"),
									λ.NewStr("Google-Accounts-XSRF"): λ.NewInt(1),
								})},
							})
						})
					ϒwarn = λ.NewFunction("warn",
						[]λ.Param{
							{Name: "message"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒmessage = λargs[0]
							)
							λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), ϒmessage)
							return λ.None
						})
					ϒlookup_req = λ.NewList(
						ϒusername,
						λ.None,
						λ.NewList(),
						λ.None,
						λ.NewStr("US"),
						λ.None,
						λ.None,
						λ.NewInt(2),
						λ.False,
						λ.True,
						λ.NewList(
							λ.None,
							λ.None,
							λ.NewList(
								λ.NewInt(2),
								λ.NewInt(1),
								λ.None,
								λ.NewInt(1),
								λ.NewStr("https://accounts.google.com/ServiceLogin?passive=true&continue=https%3A%2F%2Fwww.youtube.com%2Fsignin%3Fnext%3D%252F%26action_handle_signin%3Dtrue%26hl%3Den%26app%3Ddesktop%26feature%3Dsign_in_button&hl=en&service=youtube&uilel=3&requestPath=%2FServiceLogin&Page=PasswordSeparationSignIn"),
								λ.None,
								λ.NewList(),
								λ.NewInt(4),
							),
							λ.NewInt(1),
							λ.NewList(
								λ.None,
								λ.None,
								λ.NewList(),
							),
							λ.None,
							λ.None,
							λ.None,
							λ.True,
						),
						ϒusername,
					)
					ϒlookup_results = λ.Cal(ϒreq, λ.GetAttr(ϒself, "_LOOKUP_URL", nil), ϒlookup_req, λ.NewStr("Looking up account info"), λ.NewStr("Unable to look up account info"))
					if λ.IsTrue(λ.NewBool(ϒlookup_results == λ.False)) {
						return λ.False
					}
					ϒuser_hash = λ.Cal(ϒtry_get, ϒlookup_results, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.NewInt(0)), λ.NewInt(2))
						}), ϒcompat_str)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒuser_hash))) {
						λ.Cal(ϒwarn, λ.NewStr("Unable to extract user hash"))
						return λ.False
					}
					ϒchallenge_req = λ.NewList(
						ϒuser_hash,
						λ.None,
						λ.NewInt(1),
						λ.None,
						λ.NewList(
							λ.NewInt(1),
							λ.None,
							λ.None,
							λ.None,
							λ.NewList(
								ϒpassword,
								λ.None,
								λ.True,
							),
						),
						λ.NewList(
							λ.None,
							λ.None,
							λ.NewList(
								λ.NewInt(2),
								λ.NewInt(1),
								λ.None,
								λ.NewInt(1),
								λ.NewStr("https://accounts.google.com/ServiceLogin?passive=true&continue=https%3A%2F%2Fwww.youtube.com%2Fsignin%3Fnext%3D%252F%26action_handle_signin%3Dtrue%26hl%3Den%26app%3Ddesktop%26feature%3Dsign_in_button&hl=en&service=youtube&uilel=3&requestPath=%2FServiceLogin&Page=PasswordSeparationSignIn"),
								λ.None,
								λ.NewList(),
								λ.NewInt(4),
							),
							λ.NewInt(1),
							λ.NewList(
								λ.None,
								λ.None,
								λ.NewList(),
							),
							λ.None,
							λ.None,
							λ.None,
							λ.True,
						),
					)
					ϒchallenge_results = λ.Cal(ϒreq, λ.GetAttr(ϒself, "_CHALLENGE_URL", nil), ϒchallenge_req, λ.NewStr("Logging in"), λ.NewStr("Unable to log in"))
					if λ.IsTrue(λ.NewBool(ϒchallenge_results == λ.False)) {
						return λ.None
					}
					ϒlogin_res = λ.Cal(ϒtry_get, ϒchallenge_results, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.NewInt(0)), λ.NewInt(5))
						}), λ.ListType)
					if λ.IsTrue(ϒlogin_res) {
						ϒlogin_msg = λ.Cal(ϒtry_get, ϒlogin_res, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.NewInt(5))
							}), ϒcompat_str)
						λ.Cal(ϒwarn, func() λ.Object {
							if λ.IsTrue(λ.Eq(ϒlogin_msg, λ.NewStr("INCORRECT_ANSWER_ENTERED"))) {
								return λ.Mod(λ.NewStr("Unable to login: %s"), λ.NewStr("Invalid password"))
							} else {
								return ϒlogin_msg
							}
						}())
						return λ.False
					}
					ϒres = λ.Cal(ϒtry_get, ϒchallenge_results, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.NewInt(0)), λ.Neg(λ.NewInt(1)))
						}), λ.ListType)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒres))) {
						λ.Cal(ϒwarn, λ.NewStr("Unable to extract result entry"))
						return λ.False
					}
					ϒlogin_challenge = λ.Cal(ϒtry_get, ϒres, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.NewInt(0)), λ.NewInt(0))
						}), λ.ListType)
					if λ.IsTrue(ϒlogin_challenge) {
						ϒchallenge_str = λ.Cal(ϒtry_get, ϒlogin_challenge, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.NewInt(2))
							}), ϒcompat_str)
						if λ.IsTrue(λ.Eq(ϒchallenge_str, λ.NewStr("TWO_STEP_VERIFICATION"))) {
							ϒstatus = λ.Cal(ϒtry_get, ϒlogin_challenge, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(ϒx, λ.NewInt(5))
								}), ϒcompat_str)
							if λ.IsTrue(λ.Eq(ϒstatus, λ.NewStr("QUOTA_EXCEEDED"))) {
								λ.Cal(ϒwarn, λ.NewStr("Exceeded the limit of TFA codes, try later"))
								return λ.False
							}
							ϒtl = λ.Cal(ϒtry_get, ϒchallenge_results, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewInt(1)), λ.NewInt(2))
								}), ϒcompat_str)
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒtl))) {
								λ.Cal(ϒwarn, λ.NewStr("Unable to extract TL"))
								return λ.False
							}
							ϒtfa_code = λ.Cal(λ.GetAttr(ϒself, "_get_tfa_info", nil), λ.NewStr("2-step verification code"))
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒtfa_code))) {
								λ.Cal(ϒwarn, λ.NewStr("Two-factor authentication required. Provide it either interactively or with --twofactor <code>(Note that only TOTP (Google Authenticator App) codes work at this time.)"))
								return λ.False
							}
							ϒtfa_code = λ.Cal(ϒremove_start, ϒtfa_code, λ.NewStr("G-"))
							ϒtfa_req = λ.NewList(
								ϒuser_hash,
								λ.None,
								λ.NewInt(2),
								λ.None,
								λ.NewList(
									λ.NewInt(9),
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.NewList(
										λ.None,
										ϒtfa_code,
										λ.True,
										λ.NewInt(2),
									),
								),
							)
							ϒtfa_results = λ.Cal(ϒreq, λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_TFA_URL", nil), "format", nil), ϒtl), ϒtfa_req, λ.NewStr("Submitting TFA code"), λ.NewStr("Unable to submit TFA code"))
							if λ.IsTrue(λ.NewBool(ϒtfa_results == λ.False)) {
								return λ.False
							}
							ϒtfa_res = λ.Cal(ϒtry_get, ϒtfa_results, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewInt(0)), λ.NewInt(5))
								}), λ.ListType)
							if λ.IsTrue(ϒtfa_res) {
								ϒtfa_msg = λ.Cal(ϒtry_get, ϒtfa_res, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(ϒx, λ.NewInt(5))
									}), ϒcompat_str)
								λ.Cal(ϒwarn, func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒtfa_msg, λ.NewStr("INCORRECT_ANSWER_ENTERED"))) {
										return λ.Mod(λ.NewStr("Unable to finish TFA: %s"), λ.NewStr("Invalid TFA code"))
									} else {
										return ϒtfa_msg
									}
								}())
								return λ.False
							}
							ϒcheck_cookie_url = λ.Cal(ϒtry_get, ϒtfa_results, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.NewInt(0)), λ.Neg(λ.NewInt(1))), λ.NewInt(2))
								}), ϒcompat_str)
						} else {
							CHALLENGES = λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("LOGIN_CHALLENGE"):   λ.NewStr("This device isn't recognized. For your security, Google wants to make sure it's really you."),
								λ.NewStr("USERNAME_RECOVERY"): λ.NewStr("Please provide additional information to aid in the recovery process."),
								λ.NewStr("REAUTH"):            λ.NewStr("There is something unusual about your activity. For your security, Google wants to make sure it's really you."),
							})
							ϒchallenge = λ.Cal(λ.GetAttr(CHALLENGES, "get", nil), ϒchallenge_str, λ.Mod(λ.NewStr("%s returned error %s."), λ.NewTuple(
								λ.GetAttr(ϒself, "IE_NAME", nil),
								ϒchallenge_str,
							)))
							λ.Cal(ϒwarn, λ.Mod(λ.NewStr("%s\nGo to https://accounts.google.com/, login and solve a challenge."), ϒchallenge))
							return λ.False
						}
					} else {
						ϒcheck_cookie_url = λ.Cal(ϒtry_get, ϒres, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.NewInt(2))
							}), ϒcompat_str)
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒcheck_cookie_url))) {
						λ.Cal(ϒwarn, λ.NewStr("Unable to extract CheckCookie URL"))
						return λ.False
					}
					ϒcheck_cookie_results = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
						ϒcheck_cookie_url,
						λ.None,
						λ.NewStr("Checking cookie"),
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					if λ.IsTrue(λ.NewBool(ϒcheck_cookie_results == λ.False)) {
						return λ.False
					}
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒcheck_cookie_results, λ.NewStr("https://myaccount.google.com/")))) {
						λ.Cal(ϒwarn, λ.NewStr("Unable to log in"))
						return λ.False
					}
					return λ.True
				})
			YoutubeBaseInfoExtractor__download_webpage_handle = λ.NewFunction("_download_webpage_handle",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒquery  λ.Object
						ϒself   = λargs[0]
					)
					ϒquery = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒkwargs, "get", nil), λ.NewStr("query"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), "copy", nil))
					λ.SetItem(ϒquery, λ.NewStr("disable_polymer"), λ.NewStr("true"))
					λ.SetItem(ϒkwargs, λ.NewStr("query"), ϒquery)
					return λ.Call(λ.GetAttr(λ.Cal(λ.SuperType, YoutubeBaseInfoExtractor, ϒself), "_download_webpage_handle", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
						{Name: "", Value: λ.Cal(ϒcompat_kwargs, ϒkwargs)},
					})
				})
			YoutubeBaseInfoExtractor__real_initialize = λ.NewFunction("_real_initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					if λ.IsTrue(λ.NewBool(λ.GetAttr(ϒself, "_downloader", nil) == λ.None)) {
						return λ.None
					}
					λ.Cal(λ.GetAttr(ϒself, "_set_language", nil))
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒself, "_login", nil))))) {
						return λ.None
					}
					return λ.None
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_LOGIN_REQUIRED"):          YoutubeBaseInfoExtractor__LOGIN_REQUIRED,
				λ.NewStr("_NETRC_MACHINE"):           YoutubeBaseInfoExtractor__NETRC_MACHINE,
				λ.NewStr("_PLAYLIST_ID_RE"):          YoutubeBaseInfoExtractor__PLAYLIST_ID_RE,
				λ.NewStr("_download_webpage_handle"): YoutubeBaseInfoExtractor__download_webpage_handle,
				λ.NewStr("_login"):                   YoutubeBaseInfoExtractor__login,
				λ.NewStr("_real_initialize"):         YoutubeBaseInfoExtractor__real_initialize,
				λ.NewStr("_set_language"):            YoutubeBaseInfoExtractor__set_language,
			})
		}())
		YoutubeEntryListBaseInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("YoutubeEntryListBaseInfoExtractor"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubePlaylistBaseInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("YoutubePlaylistBaseInfoExtractor"), λ.NewTuple(YoutubeEntryListBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubePlaylistsBaseInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("YoutubePlaylistsBaseInfoExtractor"), λ.NewTuple(YoutubeEntryListBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeIE"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubeIE_IE_NAME              λ.Object
				YoutubeIE__GEO_BYPASS          λ.Object
				YoutubeIE__NEXT_URL_RE         λ.Object
				YoutubeIE__VALID_URL           λ.Object
				YoutubeIE___init__             λ.Object
				YoutubeIE__extract_url         λ.Object
				YoutubeIE__extract_urls        λ.Object
				YoutubeIE__get_ytplayer_config λ.Object
				YoutubeIE__real_extract        λ.Object
				YoutubeIE_extract_id           λ.Object
			)
			YoutubeIE__VALID_URL = λ.Mod(λ.NewStr("(?x)^\n                     (\n                         (?:https?://|//)                                    # http(s):// or protocol-independent URL\n                         (?:(?:(?:(?:\\w+\\.)?[yY][oO][uU][tT][uU][bB][eE](?:-nocookie)?\\.com/|\n                            (?:www\\.)?deturl\\.com/www\\.youtube\\.com/|\n                            (?:www\\.)?pwnyoutube\\.com/|\n                            (?:www\\.)?hooktube\\.com/|\n                            (?:www\\.)?yourepeat\\.com/|\n                            tube\\.majestyc\\.net/|\n                            (?:www\\.)?invidio\\.us/|\n                            (?:www\\.)?invidious\\.snopyta\\.org/|\n                            (?:www\\.)?invidious\\.kabi\\.tk/|\n                            (?:www\\.)?vid\\.wxzm\\.sx/|\n                            youtube\\.googleapis\\.com/)                        # the various hostnames, with wildcard subdomains\n                         (?:.*?\\#/)?                                          # handle anchor (#/) redirect urls\n                         (?:                                                  # the various things that can precede the ID:\n                             (?:(?:v|embed|e)/(?!videoseries))                # v/ or embed/ or e/\n                             |(?:                                             # or the v= param in all its forms\n                                 (?:(?:watch|movie)(?:_popup)?(?:\\.php)?/?)?  # preceding watch(_popup|.php) or nothing (like /?v=xxxx)\n                                 (?:\\?|\\#!?)                                  # the params delimiter ? or # or #!\n                                 (?:.*?[&;])??                                # any other preceding param (like /?s=tuff&v=xxxx or ?s=tuff&amp;v=V36LpHqtcDY)\n                                 v=\n                             )\n                         ))\n                         |(?:\n                            youtu\\.be|                                        # just youtu.be/xxxx\n                            vid\\.plus|                                        # or vid.plus/xxxx\n                            zwearz\\.com/watch|                                # or zwearz.com/watch/xxxx\n                         )/\n                         |(?:www\\.)?cleanvideosearch\\.com/media/action/yt/watch\\?videoId=\n                         )\n                     )?                                                       # all until now is optional -> you can pass the naked ID\n                     ([0-9A-Za-z_-]{11})                                      # here is it! the YouTube video ID\n                     (?!.*?\\blist=\n                        (?:\n                            %(playlist_id)s|                                  # combined list/video URLs are handled by the playlist IE\n                            WL                                                # WL are handled by the watch later IE\n                        )\n                     )\n                     (?(1).+)?                                                # if we found the ID, everything can follow\n                     $"), λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("playlist_id"): λ.GetAttr(YoutubeBaseInfoExtractor, "_PLAYLIST_ID_RE", nil),
			}))
			YoutubeIE__NEXT_URL_RE = λ.NewStr("[\\?&]next_url=([^&]+)")
			YoutubeIE__GEO_BYPASS = λ.False
			YoutubeIE_IE_NAME = λ.NewStr("youtube")
			YoutubeIE___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒself   = λargs[0]
					)
					λ.Call(λ.GetAttr(λ.Cal(λ.SuperType, YoutubeIE, ϒself), "__init__", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
						{Name: "", Value: ϒkwargs},
					})
					λ.SetAttr(ϒself, "_player_cache", λ.NewDictWithTable(map[λ.Object]λ.Object{}))
					return λ.None
				})
			YoutubeIE__get_ytplayer_config = λ.NewFunction("_get_ytplayer_config",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
					{Name: "webpage"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒconfig   λ.Object
						ϒpatterns λ.Object
						ϒself     = λargs[0]
						ϒvideo_id = λargs[1]
						ϒwebpage  = λargs[2]
					)
					ϒpatterns = λ.NewTuple(
						λ.NewStr(";ytplayer\\.config\\s*=\\s*({.+?});ytplayer"),
						λ.NewStr(";ytplayer\\.config\\s*=\\s*({.+?});"),
					)
					ϒconfig = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						ϒpatterns,
						ϒwebpage,
						λ.NewStr("ytplayer.config"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒconfig) {
						return λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Cal(ϒuppercase_escape, ϒconfig),
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "fatal", Value: λ.False},
						})
					}
					return λ.None
				})
			YoutubeIE__extract_urls = λ.NewFunction("_extract_urls",
				[]λ.Param{
					{Name: "webpage"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒentries λ.Object
						ϒmatches λ.Object
						ϒwebpage = λargs[0]
					)
					ϒentries = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
								var (
									ϒmobj λ.Object
									τmp0  λ.Object
									τmp1  λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.NewStr("(?x)\n            (?:\n                <iframe[^>]+?src=|\n                data-video-url=|\n                <embed[^>]+?src=|\n                embedSWF\\(?:\\s*|\n                <object[^>]+data=|\n                new\\s+SWFObject\\(\n            )\n            ([\"\\'])\n                (?P<url>(?:https?:)?//(?:www\\.)?youtube(?:-nocookie)?\\.com/\n                (?:embed|v|p)/[0-9A-Za-z_-]{11}.*?)\n            \\1"), ϒwebpage))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒmobj = τmp1
									λgen.Yield(λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("url"))))
								}
								return λ.None
							})
						})))
					λ.Cal(λ.GetAttr(ϒentries, "extend", nil), λ.Cal(λ.ListType, λ.Cal(λ.MapIteratorType, ϒunescapeHTML, λ.Cal(Ωre.ϒfindall, λ.NewStr("class=\"lazyYT\" data-youtube-id=\"([^\"]+)\""), ϒwebpage))))
					ϒmatches = λ.Cal(Ωre.ϒfindall, λ.NewStr("(?x)<div[^>]+\n            class=(?P<q1>[\\'\"])[^\\'\"]*\\byvii_single_video_player\\b[^\\'\"]*(?P=q1)[^>]+\n            data-video_id=(?P<q2>[\\'\"])([^\\'\"]+)(?P=q2)"), ϒwebpage)
					λ.Cal(λ.GetAttr(ϒentries, "extend", nil), λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
								var (
									ϒm   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, ϒmatches)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒm = τmp1
									λgen.Yield(λ.GetItem(ϒm, λ.Neg(λ.NewInt(1))))
								}
								return λ.None
							})
						})))
					return ϒentries
				})
			YoutubeIE__extract_urls = λ.Cal(λ.StaticMethodType, YoutubeIE__extract_urls)
			YoutubeIE__extract_url = λ.NewFunction("_extract_url",
				[]λ.Param{
					{Name: "webpage"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒurls    λ.Object
						ϒwebpage = λargs[0]
					)
					ϒurls = λ.Cal(λ.GetAttr(YoutubeIE, "_extract_urls", nil), ϒwebpage)
					return func() λ.Object {
						if λ.IsTrue(ϒurls) {
							return λ.GetItem(ϒurls, λ.NewInt(0))
						} else {
							return λ.None
						}
					}()
				})
			YoutubeIE__extract_url = λ.Cal(λ.StaticMethodType, YoutubeIE__extract_url)
			YoutubeIE_extract_id = λ.NewFunction("extract_id",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls      = λargs[0]
						ϒmobj     λ.Object
						ϒurl      = λargs[1]
						ϒvideo_id λ.Object
					)
					ϒmobj = λ.Cal(Ωre.ϒmatch, λ.GetAttr(ϒcls, "_VALID_URL", nil), ϒurl, Ωre.VERBOSE)
					if λ.IsTrue(λ.NewBool(ϒmobj == λ.None)) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.NewStr("Invalid URL: %s"), ϒurl))))
					}
					ϒvideo_id = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(2))
					return ϒvideo_id
				})
			YoutubeIE_extract_id = λ.Cal(λ.ClassMethodType, YoutubeIE_extract_id)
			YoutubeIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ASSETS_RE                    λ.Object
						ϒ_extract_count              λ.Object
						ϒ_extract_filesize           λ.Object
						ϒa_format                    λ.Object
						ϒadd_dash_mpd                λ.Object
						ϒadd_dash_mpd_pr             λ.Object
						ϒage_gate                    λ.Object
						ϒargs                        λ.Object
						ϒartist                      λ.Object
						ϒautomatic_captions          λ.Object
						ϒcategory                    λ.Object
						ϒchannel_id                  λ.Object
						ϒchannel_url                 λ.Object
						ϒchapters                    λ.Object
						ϒcodecs                      λ.Object
						ϒcomponent                   λ.Object
						ϒcountries                   λ.Object
						ϒdash_formats                λ.Object
						ϒdash_mpd_fatal              λ.Object
						ϒdash_mpds                   λ.Object
						ϒdata                        λ.Object
						ϒdct                         λ.Object
						ϒdecrypt_sig                 λ.Object
						ϒdescription_original        λ.Object
						ϒdf                          λ.Object
						ϒdislike_count               λ.Object
						ϒel                          λ.Object
						ϒembed_url                   λ.Object
						ϒembed_webpage               λ.Object
						ϒencoded_url_map             λ.Object
						ϒencrypted_sig               λ.Object
						ϒend_time                    λ.Object
						ϒentries                     λ.Object
						ϒepisode_number              λ.Object
						ϒerror_message               λ.Object
						ϒextract_meta                λ.Object
						ϒextract_unavailable_message λ.Object
						ϒextract_view_count          λ.Object
						ϒf                           λ.Object
						ϒfd_mobj                     λ.Object
						ϒfeed                        λ.Object
						ϒfeed_data                   λ.Object
						ϒfeed_ids                    λ.Object
						ϒfilesize                    λ.Object
						ϒfmt                         λ.Object
						ϒfmt_list                    λ.Object
						ϒformat_id                   λ.Object
						ϒformats                     λ.Object
						ϒformats_spec                λ.Object
						ϒget_video_info              λ.Object
						ϒh                           λ.Object
						ϒheight                      λ.Object
						ϒis_live                     λ.Object
						ϒitag                        λ.Object
						ϒjsplayer_url_json           λ.Object
						ϒkey                         λ.Object
						ϒkind                        λ.Object
						ϒkind_ext                    λ.Object
						ϒlike_count                  λ.Object
						ϒm3u8_formats                λ.Object
						ϒm_cat_container             λ.Object
						ϒm_episode                   λ.Object
						ϒm_music                     λ.Object
						ϒm_thumb                     λ.Object
						ϒmanifest_url                λ.Object
						ϒmobj                        λ.Object
						ϒmore_fields                 λ.Object
						ϒmpd_url                     λ.Object
						ϒmultifeed_metadata_list     λ.Object
						ϒparsed_url                  λ.Object
						ϒparts_sizes                 λ.Object
						ϒpl_response                 λ.Object
						ϒplayer_desc                 λ.Object
						ϒplayer_response             λ.Object
						ϒplayer_url                  λ.Object
						ϒplayer_url_json             λ.Object
						ϒplayer_version              λ.Object
						ϒproto                       λ.Object
						ϒq                           λ.Object
						ϒquality                     λ.Object
						ϒquality_label               λ.Object
						ϒquery                       λ.Object
						ϒratio                       λ.Object
						ϒreason                      λ.Object
						ϒregions_allowed             λ.Object
						ϒreplace_url                 λ.Object
						ϒseason_number               λ.Object
						ϒself                        = λargs[0]
						ϒseries                      λ.Object
						ϒsignature                   λ.Object
						ϒsmuggled_data               λ.Object
						ϒspec                        λ.Object
						ϒstart_time                  λ.Object
						ϒstream_type                 λ.Object
						ϒstreaming_formats           λ.Object
						ϒstretched_m                 λ.Object
						ϒsts                         λ.Object
						ϒtrack                       λ.Object
						ϒtype_                       λ.Object
						ϒtype_split                  λ.Object
						ϒunavailable_message         λ.Object
						ϒupload_date                 λ.Object
						ϒurl                         = λargs[1]
						ϒurl_data                    λ.Object
						ϒurl_data_str                λ.Object
						ϒvalue                       λ.Object
						ϒvideo_alt_title             λ.Object
						ϒvideo_annotations           λ.Object
						ϒvideo_categories            λ.Object
						ϒvideo_creator               λ.Object
						ϒvideo_description           λ.Object
						ϒvideo_details               λ.Object
						ϒvideo_duration              λ.Object
						ϒvideo_id                    λ.Object
						ϒvideo_info                  λ.Object
						ϒvideo_info_url              λ.Object
						ϒvideo_info_webpage          λ.Object
						ϒvideo_license               λ.Object
						ϒvideo_subtitles             λ.Object
						ϒvideo_tags                  λ.Object
						ϒvideo_thumbnail             λ.Object
						ϒvideo_title                 λ.Object
						ϒvideo_uploader              λ.Object
						ϒvideo_uploader_id           λ.Object
						ϒvideo_uploader_url          λ.Object
						ϒvideo_webpage               λ.Object
						ϒview_count                  λ.Object
						ϒw                           λ.Object
						ϒwidth                       λ.Object
						ϒwidth_height                λ.Object
						ϒytplayer_config             λ.Object
						τmp0                         λ.Object
						τmp1                         λ.Object
						τmp2                         λ.Object
						τmp3                         λ.Object
						τmp4                         λ.Object
						τmp5                         λ.Object
					)
					_ = τmp2
					_ = τmp3
					τmp0 = λ.Cal(ϒunsmuggle_url, ϒurl, λ.NewDictWithTable(map[λ.Object]λ.Object{}))
					ϒurl = λ.GetItem(τmp0, λ.NewInt(0))
					ϒsmuggled_data = λ.GetItem(τmp0, λ.NewInt(1))
					ϒproto = func() λ.Object {
						if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("prefer_insecure"), λ.False)) {
							return λ.NewStr("http")
						} else {
							return λ.NewStr("https")
						}
					}()
					ϒstart_time = λ.None
					ϒend_time = λ.None
					ϒparsed_url = λ.Cal(ϒcompat_urllib_parse_urlparse, ϒurl)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewList(
						λ.GetAttr(ϒparsed_url, "fragment", nil),
						λ.GetAttr(ϒparsed_url, "query", nil),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒcomponent = τmp1
						ϒquery = λ.Cal(ϒcompat_parse_qs, ϒcomponent)
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒstart_time == λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒquery, λ.NewStr("t")))
							}
						}()) {
							ϒstart_time = λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒquery, λ.NewStr("t")), λ.NewInt(0)))
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒstart_time == λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒquery, λ.NewStr("start")))
							}
						}()) {
							ϒstart_time = λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒquery, λ.NewStr("start")), λ.NewInt(0)))
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒend_time == λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒquery, λ.NewStr("end")))
							}
						}()) {
							ϒend_time = λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒquery, λ.NewStr("end")), λ.NewInt(0)))
						}
					}
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.GetAttr(ϒself, "_NEXT_URL_RE", nil), ϒurl)
					if λ.IsTrue(ϒmobj) {
						ϒurl = λ.Add(λ.Add(ϒproto, λ.NewStr("://www.youtube.com/")), λ.Cal(λ.GetAttr(λ.Cal(ϒcompat_urllib_parse_unquote, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1))), "lstrip", nil), λ.NewStr("/")))
					}
					ϒvideo_id = λ.Cal(λ.GetAttr(ϒself, "extract_id", nil), ϒurl)
					ϒurl = λ.Add(ϒproto, λ.Mod(λ.NewStr("://www.youtube.com/watch?v=%s&gl=US&hl=en&has_verified=1&bpctr=9999999999"), ϒvideo_id))
					ϒvideo_webpage = λ.Cal(λ.GetAttr(ϒself, "_download_webpage", nil), ϒurl, ϒvideo_id)
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("swfConfig.*?\"(https?:\\\\/\\\\/.*?watch.*?-.*?\\.swf)\""), ϒvideo_webpage)
					if λ.IsTrue(λ.NewBool(ϒmobj != λ.None)) {
						ϒplayer_url = λ.Cal(Ωre.ϒsub, λ.NewStr("\\\\(.)"), λ.NewStr("\\1"), λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1)))
					} else {
						ϒplayer_url = λ.None
					}
					ϒdash_mpds = λ.NewList()
					ϒadd_dash_mpd = λ.NewFunction("add_dash_mpd",
						[]λ.Param{
							{Name: "video_info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdash_mpd   λ.Object
								ϒvideo_info = λargs[0]
							)
							ϒdash_mpd = λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("dashmpd"))
							if λ.IsTrue(func() λ.Object {
								if λv := ϒdash_mpd; !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(!λ.Contains(ϒdash_mpds, λ.GetItem(ϒdash_mpd, λ.NewInt(0))))
								}
							}()) {
								λ.Cal(λ.GetAttr(ϒdash_mpds, "append", nil), λ.GetItem(ϒdash_mpd, λ.NewInt(0)))
							}
							return λ.None
						})
					ϒadd_dash_mpd_pr = λ.NewFunction("add_dash_mpd_pr",
						[]λ.Param{
							{Name: "pl_response"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdash_mpd    λ.Object
								ϒpl_response = λargs[0]
							)
							ϒdash_mpd = λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒpl_response, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("streamingData")), λ.NewStr("dashManifestUrl"))
								}), ϒcompat_str))
							if λ.IsTrue(func() λ.Object {
								if λv := ϒdash_mpd; !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(!λ.Contains(ϒdash_mpds, ϒdash_mpd))
								}
							}()) {
								λ.Cal(λ.GetAttr(ϒdash_mpds, "append", nil), ϒdash_mpd)
							}
							return λ.None
						})
					ϒis_live = λ.None
					ϒview_count = λ.None
					ϒextract_view_count = λ.NewFunction("extract_view_count",
						[]λ.Param{
							{Name: "v_info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒv_info = λargs[0]
							)
							return λ.Cal(ϒint_or_none, λ.Cal(ϒtry_get, ϒv_info, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("view_count")), λ.NewInt(0))
								})))
						})
					ϒplayer_response = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					ϒembed_webpage = λ.None
					if λ.IsTrue(λ.NewBool(λ.Cal(Ωre.ϒsearch, λ.NewStr("player-age-gate-content\">"), ϒvideo_webpage) != λ.None)) {
						ϒage_gate = λ.True
						ϒurl = λ.Add(ϒproto, λ.Mod(λ.NewStr("://www.youtube.com/embed/%s"), ϒvideo_id))
						ϒembed_webpage = λ.Cal(λ.GetAttr(ϒself, "_download_webpage", nil), ϒurl, ϒvideo_id, λ.NewStr("Downloading embed webpage"))
						ϒdata = λ.Cal(ϒcompat_urllib_parse_urlencode, λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("video_id"): ϒvideo_id,
							λ.NewStr("eurl"):     λ.Add(λ.NewStr("https://youtube.googleapis.com/v/"), ϒvideo_id),
							λ.NewStr("sts"): λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.NewStr("\"sts\"\\s*:\\s*(\\d+)"),
								ϒembed_webpage,
								λ.NewStr("sts"),
							), λ.KWArgs{
								{Name: "default", Value: λ.NewStr("")},
							}),
						}))
						ϒvideo_info_url = λ.Add(λ.Add(ϒproto, λ.NewStr("://www.youtube.com/get_video_info?")), ϒdata)
						ϒvideo_info_webpage = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
							ϒvideo_info_url,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "note", Value: λ.NewStr("Refetching age-gated info webpage")},
							{Name: "errnote", Value: λ.NewStr("unable to download video info webpage")},
						})
						ϒvideo_info = λ.Cal(ϒcompat_parse_qs, ϒvideo_info_webpage)
						λ.Cal(ϒadd_dash_mpd, ϒvideo_info)
					} else {
						ϒage_gate = λ.False
						ϒvideo_info = λ.None
						ϒsts = λ.None
						ϒytplayer_config = λ.Cal(λ.GetAttr(ϒself, "_get_ytplayer_config", nil), ϒvideo_id, ϒvideo_webpage)
						if λ.IsTrue(ϒytplayer_config) {
							ϒargs = λ.GetItem(ϒytplayer_config, λ.NewStr("args"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒargs, "get", nil), λ.NewStr("url_encoded_fmt_stream_map")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒargs, "get", nil), λ.NewStr("hlsvp"))
								}
							}()) {
								ϒvideo_info = λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
											var (
												ϒk   λ.Object
												ϒv   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
												τmp2 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒargs, "items", nil)))
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												τmp2 = τmp1
												ϒk = λ.GetItem(τmp2, λ.NewInt(0))
												ϒv = λ.GetItem(τmp2, λ.NewInt(1))
												λgen.Yield(λ.NewTuple(
													ϒk,
													λ.NewList(ϒv),
												))
											}
											return λ.None
										})
									})))
								λ.Cal(ϒadd_dash_mpd, ϒvideo_info)
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(!λ.IsTrue(ϒvideo_info)); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒargs, "get", nil), λ.NewStr("ypc_vid"))
								}
							}()) {
								return λ.Call(λ.GetAttr(ϒself, "url_result", nil), λ.NewArgs(
									λ.GetItem(ϒargs, λ.NewStr("ypc_vid")),
									λ.Cal(λ.GetAttr(YoutubeIE, "ie_key", nil)),
								), λ.KWArgs{
									{Name: "video_id", Value: λ.GetItem(ϒargs, λ.NewStr("ypc_vid"))},
								})
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(λ.Cal(λ.GetAttr(ϒargs, "get", nil), λ.NewStr("livestream")), λ.NewStr("1")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(λ.Cal(λ.GetAttr(ϒargs, "get", nil), λ.NewStr("live_playback")), λ.NewInt(1))
								}
							}()) {
								ϒis_live = λ.True
							}
							ϒsts = λ.Cal(λ.GetAttr(ϒytplayer_config, "get", nil), λ.NewStr("sts"))
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒplayer_response))) {
								ϒpl_response = λ.Cal(ϒstr_or_none, λ.Cal(λ.GetAttr(ϒargs, "get", nil), λ.NewStr("player_response")))
								if λ.IsTrue(ϒpl_response) {
									ϒpl_response = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
										ϒpl_response,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "fatal", Value: λ.False},
									})
									if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpl_response, λ.DictType)) {
										ϒplayer_response = ϒpl_response
									}
								}
							}
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒvideo_info)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("youtube_include_dash_manifest"), λ.True)
							}
						}()) {
							λ.Cal(ϒadd_dash_mpd_pr, ϒplayer_response)
							λ.Cal(λ.GetAttr(ϒself, "report_video_info_webpage_download", nil), ϒvideo_id)
							τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
								λ.NewStr("info"),
								λ.NewStr("embedded"),
								λ.NewStr("detailpage"),
								λ.NewStr("vevo"),
								λ.NewStr(""),
							))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒel = τmp1
								ϒquery = λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("video_id"): ϒvideo_id,
									λ.NewStr("ps"):       λ.NewStr("default"),
									λ.NewStr("eurl"):     λ.NewStr(""),
									λ.NewStr("gl"):       λ.NewStr("US"),
									λ.NewStr("hl"):       λ.NewStr("en"),
								})
								if λ.IsTrue(ϒel) {
									λ.SetItem(ϒquery, λ.NewStr("el"), ϒel)
								}
								if λ.IsTrue(ϒsts) {
									λ.SetItem(ϒquery, λ.NewStr("sts"), ϒsts)
								}
								ϒvideo_info_webpage = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
									λ.Mod(λ.NewStr("%s://www.youtube.com/get_video_info"), ϒproto),
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "note", Value: λ.False},
									{Name: "errnote", Value: λ.NewStr("unable to download video info webpage")},
									{Name: "fatal", Value: λ.False},
									{Name: "query", Value: ϒquery},
								})
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒvideo_info_webpage))) {
									continue
								}
								ϒget_video_info = λ.Cal(ϒcompat_parse_qs, ϒvideo_info_webpage)
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒplayer_response))) {
									ϒpl_response = λ.GetItem(λ.Cal(λ.GetAttr(ϒget_video_info, "get", nil), λ.NewStr("player_response"), λ.NewList(λ.None)), λ.NewInt(0))
									if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpl_response, λ.DictType)) {
										ϒplayer_response = ϒpl_response
										λ.Cal(ϒadd_dash_mpd_pr, ϒplayer_response)
									}
								}
								λ.Cal(ϒadd_dash_mpd, ϒget_video_info)
								if λ.IsTrue(λ.NewBool(ϒview_count == λ.None)) {
									ϒview_count = λ.Cal(ϒextract_view_count, ϒget_video_info)
								}
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒvideo_info))) {
									ϒvideo_info = ϒget_video_info
								}
								if λ.IsTrue(λ.NewBool(λ.Contains(ϒget_video_info, λ.NewStr("token")))) {
									if λ.IsTrue(λ.NewBool(!λ.Contains(ϒvideo_info, λ.NewStr("token")))) {
										ϒvideo_info = ϒget_video_info
									}
									break
								}
							}
						}
					}
					ϒextract_unavailable_message = λ.NewFunction("extract_unavailable_message",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
								λ.NewStr("(?s)<h1[^>]+id=\"unavailable-message\"[^>]*>(.+?)</h1>"),
								ϒvideo_webpage,
								λ.NewStr("unavailable message"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							})
						})
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒvideo_info, λ.NewStr("token")))) {
						if λ.IsTrue(λ.NewBool(λ.Contains(ϒvideo_info, λ.NewStr("reason")))) {
							if λ.IsTrue(λ.NewBool(λ.Contains(λ.GetItem(ϒvideo_info, λ.NewStr("reason")), λ.NewStr("The uploader has not made this video available in your country.")))) {
								ϒregions_allowed = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
									λ.NewStr("regionsAllowed"),
									ϒvideo_webpage,
								), λ.KWArgs{
									{Name: "default", Value: λ.None},
								})
								ϒcountries = func() λ.Object {
									if λ.IsTrue(ϒregions_allowed) {
										return λ.Cal(λ.GetAttr(ϒregions_allowed, "split", nil), λ.NewStr(","))
									} else {
										return λ.None
									}
								}()
								λ.Call(λ.GetAttr(ϒself, "raise_geo_restricted", nil), nil, λ.KWArgs{
									{Name: "msg", Value: λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("reason")), λ.NewInt(0))},
									{Name: "countries", Value: ϒcountries},
								})
							}
							ϒreason = λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("reason")), λ.NewInt(0))
							if λ.IsTrue(λ.NewBool(λ.Contains(ϒreason, λ.NewStr("Invalid parameters")))) {
								ϒunavailable_message = λ.Cal(ϒextract_unavailable_message)
								if λ.IsTrue(ϒunavailable_message) {
									ϒreason = ϒunavailable_message
								}
							}
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Mod(λ.NewStr("YouTube said: %s"), ϒreason)), λ.KWArgs{
								{Name: "expected", Value: λ.True},
								{Name: "video_id", Value: ϒvideo_id},
							})))
						} else {
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("\"token\" parameter not in video info for unknown reason")), λ.KWArgs{
								{Name: "video_id", Value: ϒvideo_id},
							})))
						}
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("license_info"))) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("This video is DRM protected.")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					ϒvideo_details = func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.NewStr("videoDetails"))
							}), λ.DictType); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewDictWithTable(map[λ.Object]λ.Object{})
						}
					}()
					if λ.IsTrue(λ.NewBool(λ.Contains(ϒvideo_info, λ.NewStr("title")))) {
						ϒvideo_title = λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("title")), λ.NewInt(0))
					} else {
						if λ.IsTrue(λ.NewBool(λ.Contains(ϒplayer_response, λ.NewStr("title")))) {
							ϒvideo_title = λ.GetItem(ϒvideo_details, λ.NewStr("title"))
						} else {
							λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.NewStr("Unable to extract video title"))
							ϒvideo_title = λ.NewStr("_")
						}
					}
					τmp0 = λ.Cal(ϒget_element_by_id, λ.NewStr("eow-description"), ϒvideo_webpage)
					ϒdescription_original = τmp0
					ϒvideo_description = τmp0
					if λ.IsTrue(ϒvideo_description) {
						ϒreplace_url = λ.NewFunction("replace_url",
							[]λ.Param{
								{Name: "m"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒm                = λargs[0]
									ϒparsed_redir_url λ.Object
									ϒq                λ.Object
									ϒqs               λ.Object
									ϒredir_url        λ.Object
								)
								ϒredir_url = λ.Cal(Ωparse.ϒurljoin, ϒurl, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(1)))
								ϒparsed_redir_url = λ.Cal(ϒcompat_urllib_parse_urlparse, ϒredir_url)
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(Ωre.ϒsearch, λ.NewStr("^(?:www\\.)?(?:youtube(?:-nocookie)?\\.com|youtu\\.be)$"), λ.GetAttr(ϒparsed_redir_url, "netloc", nil)); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Eq(λ.GetAttr(ϒparsed_redir_url, "path", nil), λ.NewStr("/redirect"))
									}
								}()) {
									ϒqs = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(ϒparsed_redir_url, "query", nil))
									ϒq = λ.Cal(λ.GetAttr(ϒqs, "get", nil), λ.NewStr("q"))
									if λ.IsTrue(func() λ.Object {
										if λv := ϒq; !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.GetItem(ϒq, λ.NewInt(0))
										}
									}()) {
										return λ.GetItem(ϒq, λ.NewInt(0))
									}
								}
								return ϒredir_url
							})
						τmp0 = λ.Cal(Ωre.ϒsub, λ.NewStr("(?x)\n                <a\\s+\n                    (?:[a-zA-Z-]+=\"[^\"]*\"\\s+)*?\n                    (?:title|href)=\"([^\"]+)\"\\s+\n                    (?:[a-zA-Z-]+=\"[^\"]*\"\\s+)*?\n                    class=\"[^\"]*\"[^>]*>\n                [^<]+\\.{3}\\s*\n                </a>\n            "), ϒreplace_url, ϒvideo_description)
						ϒdescription_original = τmp0
						ϒvideo_description = τmp0
						ϒvideo_description = λ.Cal(ϒclean_html, ϒvideo_description)
					} else {
						ϒfd_mobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("<meta name=\"description\" content=\"([^\"]+)\""), ϒvideo_webpage)
						if λ.IsTrue(ϒfd_mobj) {
							ϒvideo_description = λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒfd_mobj, "group", nil), λ.NewInt(1)))
						} else {
							ϒvideo_description = λ.NewStr("")
						}
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒsmuggled_data, "get", nil), λ.NewStr("force_singlefeed"), λ.False)))) {
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("noplaylist"))))) {
							ϒmultifeed_metadata_list = func() λ.Object {
								if λv := λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.NewStr("multicamera")), λ.NewStr("playerLegacyMulticameraRenderer")), λ.NewStr("metadataList"))
									}), ϒcompat_str); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("multifeed_metadata_list")), λ.NewInt(0))
										}), ϒcompat_str)
								}
							}()
							if λ.IsTrue(ϒmultifeed_metadata_list) {
								ϒentries = λ.NewList()
								ϒfeed_ids = λ.NewList()
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒmultifeed_metadata_list, "split", nil), λ.NewStr(",")))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒfeed = τmp1
									ϒfeed_data = λ.Cal(ϒcompat_parse_qs, λ.Cal(ϒcompat_urllib_parse_unquote_plus, ϒfeed))
									λ.Cal(λ.GetAttr(ϒentries, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("_type"):  λ.NewStr("url_transparent"),
										λ.NewStr("ie_key"): λ.NewStr("Youtube"),
										λ.NewStr("url"): λ.Cal(ϒsmuggle_url, λ.Mod(λ.NewStr("%s://www.youtube.com/watch?v=%s"), λ.NewTuple(
											ϒproto,
											λ.GetItem(λ.GetItem(ϒfeed_data, λ.NewStr("id")), λ.NewInt(0)),
										)), λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("force_singlefeed"): λ.True,
										})),
										λ.NewStr("title"): λ.Mod(λ.NewStr("%s (%s)"), λ.NewTuple(
											ϒvideo_title,
											λ.GetItem(λ.GetItem(ϒfeed_data, λ.NewStr("title")), λ.NewInt(0)),
										)),
									}))
									λ.Cal(λ.GetAttr(ϒfeed_ids, "append", nil), λ.GetItem(λ.GetItem(ϒfeed_data, λ.NewStr("id")), λ.NewInt(0)))
								}
								λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("Downloading multifeed video (%s) - add --no-playlist to just download video %s"), λ.NewTuple(
									λ.Cal(λ.GetAttr(λ.NewStr(", "), "join", nil), ϒfeed_ids),
									ϒvideo_id,
								)))
								return λ.Cal(λ.GetAttr(ϒself, "playlist_result", nil), ϒentries, ϒvideo_id, ϒvideo_title, ϒvideo_description)
							}
						} else {
							λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("Downloading just video %s because of --no-playlist"), ϒvideo_id))
						}
					}
					if λ.IsTrue(λ.NewBool(ϒview_count == λ.None)) {
						ϒview_count = λ.Cal(ϒextract_view_count, ϒvideo_info)
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(ϒview_count == λ.None); !λ.IsTrue(λv) {
							return λv
						} else {
							return ϒvideo_details
						}
					}()) {
						ϒview_count = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒvideo_details, "get", nil), λ.NewStr("viewCount")))
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒvideo_info, λ.NewStr("ypc_video_rental_bar_text"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.Contains(ϒvideo_info, λ.NewStr("author")))
						}
					}()) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("\"rental\" videos not supported. See https://github.com/rg3/youtube-dl/issues/359 for more information.")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					ϒ_extract_filesize = λ.NewFunction("_extract_filesize",
						[]λ.Param{
							{Name: "media_url"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒmedia_url = λargs[0]
							)
							return λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.NewStr("\\bclen[=/](\\d+)"),
								ϒmedia_url,
								λ.NewStr("filesize"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						})
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒvideo_info, λ.NewStr("conn"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("conn")), λ.NewInt(0)), "startswith", nil), λ.NewStr("rtmp"))
						}
					}()) {
						λ.Cal(λ.GetAttr(ϒself, "report_rtmp_download", nil))
						ϒformats = λ.NewList(λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("format_id"):  λ.NewStr("_rtmp"),
							λ.NewStr("protocol"):   λ.NewStr("rtmp"),
							λ.NewStr("url"):        λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("conn")), λ.NewInt(0)),
							λ.NewStr("player_url"): ϒplayer_url,
						}))
					} else {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒis_live)); !λ.IsTrue(λv) {
								return λv
							} else {
								return func() λ.Object {
									if λv := λ.Ge(λ.Cal(λ.BuiltinLen, λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("url_encoded_fmt_stream_map"), λ.NewList(λ.NewStr(""))), λ.NewInt(0))), λ.NewInt(1)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Ge(λ.Cal(λ.BuiltinLen, λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("adaptive_fmts"), λ.NewList(λ.NewStr(""))), λ.NewInt(0))), λ.NewInt(1))
									}
								}()
							}
						}()) {
							ϒencoded_url_map = λ.Add(λ.Add(λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("url_encoded_fmt_stream_map"), λ.NewList(λ.NewStr(""))), λ.NewInt(0)), λ.NewStr(",")), λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("adaptive_fmts"), λ.NewList(λ.NewStr(""))), λ.NewInt(0)))
							if λ.IsTrue(λ.NewBool(λ.Contains(ϒencoded_url_map, λ.NewStr("rtmpe%3Dyes")))) {
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("rtmpe downloads are not supported, see https://github.com/rg3/youtube-dl/issues/343 for more information.")), λ.KWArgs{
									{Name: "expected", Value: λ.True},
								})))
							}
							ϒformats_spec = λ.NewDictWithTable(map[λ.Object]λ.Object{})
							ϒfmt_list = λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("fmt_list"), λ.NewList(λ.NewStr(""))), λ.NewInt(0))
							if λ.IsTrue(ϒfmt_list) {
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒfmt_list, "split", nil), λ.NewStr(",")))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒfmt = τmp1
									ϒspec = λ.Cal(λ.GetAttr(ϒfmt, "split", nil), λ.NewStr("/"))
									if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒspec), λ.NewInt(1))) {
										ϒwidth_height = λ.Cal(λ.GetAttr(λ.GetItem(ϒspec, λ.NewInt(1)), "split", nil), λ.NewStr("x"))
										if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒwidth_height), λ.NewInt(2))) {
											λ.SetItem(ϒformats_spec, λ.GetItem(ϒspec, λ.NewInt(0)), λ.NewDictWithTable(map[λ.Object]λ.Object{
												λ.NewStr("resolution"): λ.GetItem(ϒspec, λ.NewInt(1)),
												λ.NewStr("width"):      λ.Cal(ϒint_or_none, λ.GetItem(ϒwidth_height, λ.NewInt(0))),
												λ.NewStr("height"):     λ.Cal(ϒint_or_none, λ.GetItem(ϒwidth_height, λ.NewInt(1))),
											}))
										}
									}
								}
							}
							ϒq = λ.Cal(ϒqualities, λ.NewList(
								λ.NewStr("small"),
								λ.NewStr("medium"),
								λ.NewStr("hd720"),
							))
							ϒstreaming_formats = λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("streamingData")), λ.NewStr("formats"))
								}), λ.ListType)
							if λ.IsTrue(ϒstreaming_formats) {
								τmp0 = λ.Cal(λ.BuiltinIter, ϒstreaming_formats)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒfmt = τmp1
									ϒitag = λ.Cal(ϒstr_or_none, λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("itag")))
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒitag))) {
										continue
									}
									ϒquality = λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("quality"))
									ϒquality_label = func() λ.Object {
										if λv := λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("qualityLabel")); λ.IsTrue(λv) {
											return λv
										} else {
											return ϒquality
										}
									}()
									λ.SetItem(ϒformats_spec, ϒitag, λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("asr"):         λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("audioSampleRate"))),
										λ.NewStr("filesize"):    λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("contentLength"))),
										λ.NewStr("format_note"): ϒquality_label,
										λ.NewStr("fps"):         λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("fps"))),
										λ.NewStr("height"):      λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("height"))),
										λ.NewStr("quality"):     λ.Cal(ϒq, ϒquality),
										λ.NewStr("tbr"): func() λ.Object {
											if λ.IsTrue(λ.Ne(ϒitag, λ.NewStr("43"))) {
												return λ.Cal(ϒfloat_or_none, func() λ.Object {
													if λv := λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("averageBitrate")); λ.IsTrue(λv) {
														return λv
													} else {
														return λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("bitrate"))
													}
												}(), λ.NewInt(1000))
											} else {
												return λ.None
											}
										}(),
										λ.NewStr("width"): λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒfmt, "get", nil), λ.NewStr("width"))),
									}))
								}
							}
							ϒformats = λ.NewList()
							τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒencoded_url_map, "split", nil), λ.NewStr(",")))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒurl_data_str = τmp1
								ϒurl_data = λ.Cal(ϒcompat_parse_qs, ϒurl_data_str)
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.Contains(ϒurl_data, λ.NewStr("itag"))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.Contains(ϒurl_data, λ.NewStr("url")))
									}
								}()) {
									continue
								}
								ϒstream_type = λ.Cal(ϒint_or_none, λ.Cal(ϒtry_get, ϒurl_data, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("stream_type")), λ.NewInt(0))
									})))
								if λ.IsTrue(λ.Eq(ϒstream_type, λ.NewInt(3))) {
									continue
								}
								ϒformat_id = λ.GetItem(λ.GetItem(ϒurl_data, λ.NewStr("itag")), λ.NewInt(0))
								ϒurl = λ.GetItem(λ.GetItem(ϒurl_data, λ.NewStr("url")), λ.NewInt(0))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(λ.Contains(ϒurl_data, λ.NewStr("s"))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("youtube_include_dash_manifest"), λ.True)
									}
								}()) {
									ASSETS_RE = λ.NewStr("\"assets\":.+?\"js\":\\s*(\"[^\"]+\")")
									ϒjsplayer_url_json = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
										ASSETS_RE,
										func() λ.Object {
											if λ.IsTrue(ϒage_gate) {
												return ϒembed_webpage
											} else {
												return ϒvideo_webpage
											}
										}(),
										λ.NewStr("JS player URL (1)"),
									), λ.KWArgs{
										{Name: "default", Value: λ.None},
									})
									if λ.IsTrue(func() λ.Object {
										if λv := λ.NewBool(!λ.IsTrue(ϒjsplayer_url_json)); !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewBool(!λ.IsTrue(ϒage_gate))
										}
									}()) {
										if λ.IsTrue(λ.NewBool(ϒembed_webpage == λ.None)) {
											ϒembed_url = λ.Add(ϒproto, λ.Mod(λ.NewStr("://www.youtube.com/embed/%s"), ϒvideo_id))
											ϒembed_webpage = λ.Cal(λ.GetAttr(ϒself, "_download_webpage", nil), ϒembed_url, ϒvideo_id, λ.NewStr("Downloading embed webpage"))
										}
										ϒjsplayer_url_json = λ.Cal(λ.GetAttr(ϒself, "_search_regex", nil), ASSETS_RE, ϒembed_webpage, λ.NewStr("JS player URL"))
									}
									ϒplayer_url = λ.Cal(Ωjson.ϒloads, ϒjsplayer_url_json)
									if λ.IsTrue(λ.NewBool(ϒplayer_url == λ.None)) {
										ϒplayer_url_json = λ.Cal(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewStr("ytplayer\\.config.*?\"url\"\\s*:\\s*(\"[^\"]+\")"), ϒvideo_webpage, λ.NewStr("age gate player URL"))
										ϒplayer_url = λ.Cal(Ωjson.ϒloads, ϒplayer_url_json)
									}
								}
								if λ.IsTrue(λ.NewBool(λ.Contains(ϒurl_data, λ.NewStr("sig")))) {
									τmp2 = λ.IAdd(ϒurl, λ.Add(λ.NewStr("&signature="), λ.GetItem(λ.GetItem(ϒurl_data, λ.NewStr("sig")), λ.NewInt(0))))
									ϒurl = τmp2
								} else {
									if λ.IsTrue(λ.NewBool(λ.Contains(ϒurl_data, λ.NewStr("s")))) {
										ϒencrypted_sig = λ.GetItem(λ.GetItem(ϒurl_data, λ.NewStr("s")), λ.NewInt(0))
										if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("verbose"))) {
											if λ.IsTrue(λ.NewBool(ϒplayer_url == λ.None)) {
												ϒplayer_version = λ.NewStr("unknown")
												ϒplayer_desc = λ.NewStr("unknown")
											} else {
												if λ.IsTrue(λ.Cal(λ.GetAttr(ϒplayer_url, "endswith", nil), λ.NewStr("swf"))) {
													ϒplayer_version = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
														λ.NewStr("-(.+?)(?:/watch_as3)?\\.swf$"),
														ϒplayer_url,
														λ.NewStr("flash player"),
													), λ.KWArgs{
														{Name: "fatal", Value: λ.False},
													})
													ϒplayer_desc = λ.Mod(λ.NewStr("flash player %s"), ϒplayer_version)
												} else {
													ϒplayer_version = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
														λ.NewList(
															λ.NewStr("html5player-([^/]+?)(?:/html5player(?:-new)?)?\\.js"),
															λ.NewStr("(?:www|player(?:_ias)?)-([^/]+)(?:/[a-z]{2,3}_[A-Z]{2})?/base\\.js"),
														),
														ϒplayer_url,
														λ.NewStr("html5 player"),
													), λ.KWArgs{
														{Name: "fatal", Value: λ.False},
													})
													ϒplayer_desc = λ.Mod(λ.NewStr("html5 player %s"), ϒplayer_version)
												}
											}
											ϒparts_sizes = λ.Cal(λ.GetAttr(ϒself, "_signature_cache_id", nil), ϒencrypted_sig)
											λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("{%s} signature length %s, %s"), λ.NewTuple(
												ϒformat_id,
												ϒparts_sizes,
												ϒplayer_desc,
											)))
										}
										ϒsignature = λ.Cal(λ.GetAttr(ϒself, "_decrypt_signature", nil), ϒencrypted_sig, ϒvideo_id, ϒplayer_url, ϒage_gate)
										τmp2 = λ.IAdd(ϒurl, λ.Add(λ.NewStr("&signature="), ϒsignature))
										ϒurl = τmp2
									}
								}
								if λ.IsTrue(λ.NewBool(!λ.Contains(ϒurl, λ.NewStr("ratebypass")))) {
									τmp2 = λ.IAdd(ϒurl, λ.NewStr("&ratebypass=yes"))
									ϒurl = τmp2
								}
								ϒdct = λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("format_id"):  ϒformat_id,
									λ.NewStr("url"):        ϒurl,
									λ.NewStr("player_url"): ϒplayer_url,
								})
								if λ.IsTrue(λ.NewBool(λ.Contains(λ.GetAttr(ϒself, "_formats", nil), ϒformat_id))) {
									λ.Cal(λ.GetAttr(ϒdct, "update", nil), λ.GetItem(λ.GetAttr(ϒself, "_formats", nil), ϒformat_id))
								}
								if λ.IsTrue(λ.NewBool(λ.Contains(ϒformats_spec, ϒformat_id))) {
									λ.Cal(λ.GetAttr(ϒdct, "update", nil), λ.GetItem(ϒformats_spec, ϒformat_id))
								}
								ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("^(?P<width>\\d+)[xX](?P<height>\\d+)$"), λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("size"), λ.NewList(λ.NewStr(""))), λ.NewInt(0)))
								τmp2 = func() λ.Object {
									if λ.IsTrue(ϒmobj) {
										return λ.NewTuple(
											λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("width"))),
											λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("height"))),
										)
									} else {
										return λ.NewTuple(
											λ.None,
											λ.None,
										)
									}
								}()
								ϒwidth = λ.GetItem(τmp2, λ.NewInt(0))
								ϒheight = λ.GetItem(τmp2, λ.NewInt(1))
								ϒfilesize = func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("clen"), λ.NewList(λ.None)), λ.NewInt(0))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(ϒ_extract_filesize, ϒurl)
									}
								}()
								ϒquality = λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("quality"), λ.NewList(λ.None)), λ.NewInt(0))
								ϒmore_fields = λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("filesize"): ϒfilesize,
									λ.NewStr("tbr"):      λ.Cal(ϒfloat_or_none, λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("bitrate"), λ.NewList(λ.None)), λ.NewInt(0)), λ.NewInt(1000)),
									λ.NewStr("width"):    ϒwidth,
									λ.NewStr("height"):   ϒheight,
									λ.NewStr("fps"):      λ.Cal(ϒint_or_none, λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("fps"), λ.NewList(λ.None)), λ.NewInt(0))),
									λ.NewStr("format_note"): func() λ.Object {
										if λv := λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("quality_label"), λ.NewList(λ.None)), λ.NewInt(0)); λ.IsTrue(λv) {
											return λv
										} else {
											return ϒquality
										}
									}(),
									λ.NewStr("quality"): λ.Cal(ϒq, ϒquality),
								})
								τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒmore_fields, "items", nil)))
								for {
									if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
										break
									}
									τmp4 = τmp3
									ϒkey = λ.GetItem(τmp4, λ.NewInt(0))
									ϒvalue = λ.GetItem(τmp4, λ.NewInt(1))
									if λ.IsTrue(ϒvalue) {
										λ.SetItem(ϒdct, ϒkey, ϒvalue)
									}
								}
								ϒtype_ = λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_data, "get", nil), λ.NewStr("type"), λ.NewList(λ.None)), λ.NewInt(0))
								if λ.IsTrue(ϒtype_) {
									ϒtype_split = λ.Cal(λ.GetAttr(ϒtype_, "split", nil), λ.NewStr(";"))
									ϒkind_ext = λ.Cal(λ.GetAttr(λ.GetItem(ϒtype_split, λ.NewInt(0)), "split", nil), λ.NewStr("/"))
									if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒkind_ext), λ.NewInt(2))) {
										τmp2 = ϒkind_ext
										ϒkind = λ.GetItem(τmp2, λ.NewInt(0))
										_ = λ.GetItem(τmp2, λ.NewInt(1))
										λ.SetItem(ϒdct, λ.NewStr("ext"), λ.Cal(ϒmimetype2ext, λ.GetItem(ϒtype_split, λ.NewInt(0))))
										if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("audio"),
											λ.NewStr("video"),
										), ϒkind))) {
											ϒcodecs = λ.None
											τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.NewStr("(?P<key>[a-zA-Z_-]+)=(?P<quote>[\"\\']?)(?P<val>.+?)(?P=quote)(?:;|$)"), ϒtype_))
											for {
												if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
													break
												}
												ϒmobj = τmp3
												if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("key")), λ.NewStr("codecs"))) {
													ϒcodecs = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("val"))
													break
												}
											}
											if λ.IsTrue(ϒcodecs) {
												λ.Cal(λ.GetAttr(ϒdct, "update", nil), λ.Cal(ϒparse_codecs, ϒcodecs))
											}
										}
									}
								}
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Eq(λ.Cal(λ.GetAttr(ϒdct, "get", nil), λ.NewStr("acodec")), λ.NewStr("none")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Eq(λ.Cal(λ.GetAttr(ϒdct, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none"))
									}
								}()) {
									λ.SetItem(ϒdct, λ.NewStr("downloader_options"), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("http_chunk_size"): λ.NewInt(10485760),
									}))
								}
								λ.Cal(λ.GetAttr(ϒformats, "append", nil), ϒdct)
							}
						} else {
							ϒmanifest_url = func() λ.Object {
								if λv := λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("streamingData")), λ.NewStr("hlsManifestUrl"))
									}), ϒcompat_str)); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("hlsvp")), λ.NewInt(0))
										}), ϒcompat_str))
								}
							}()
							if λ.IsTrue(ϒmanifest_url) {
								ϒformats = λ.NewList()
								ϒm3u8_formats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
									ϒmanifest_url,
									ϒvideo_id,
									λ.NewStr("mp4"),
								), λ.KWArgs{
									{Name: "fatal", Value: λ.False},
								})
								τmp0 = λ.Cal(λ.BuiltinIter, ϒm3u8_formats)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒa_format = τmp1
									ϒitag = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
										λ.NewStr("/itag/(\\d+)/"),
										λ.GetItem(ϒa_format, λ.NewStr("url")),
										λ.NewStr("itag"),
									), λ.KWArgs{
										{Name: "default", Value: λ.None},
									})
									if λ.IsTrue(ϒitag) {
										λ.SetItem(ϒa_format, λ.NewStr("format_id"), ϒitag)
										if λ.IsTrue(λ.NewBool(λ.Contains(λ.GetAttr(ϒself, "_formats", nil), ϒitag))) {
											ϒdct = λ.Cal(λ.GetAttr(λ.GetItem(λ.GetAttr(ϒself, "_formats", nil), ϒitag), "copy", nil))
											λ.Cal(λ.GetAttr(ϒdct, "update", nil), ϒa_format)
											ϒa_format = ϒdct
										}
									}
									λ.SetItem(ϒa_format, λ.NewStr("player_url"), ϒplayer_url)
									λ.SetItem(λ.Cal(λ.GetAttr(ϒa_format, "setdefault", nil), λ.NewStr("http_headers"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), λ.NewStr("Youtubedl-no-compression"), λ.NewStr("True"))
									λ.Cal(λ.GetAttr(ϒformats, "append", nil), ϒa_format)
								}
							} else {
								ϒerror_message = λ.Cal(ϒclean_html, λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("reason"), λ.NewList(λ.None)), λ.NewInt(0)))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒerror_message))) {
									ϒerror_message = λ.Cal(ϒextract_unavailable_message)
								}
								if λ.IsTrue(ϒerror_message) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerror_message), λ.KWArgs{
										{Name: "expected", Value: λ.True},
									})))
								}
								panic(λ.Raise(λ.Cal(ExtractorError, λ.NewStr("no conn, hlsvp, hlsManifestUrl or url_encoded_fmt_stream_map information found in video info"))))
							}
						}
					}
					ϒvideo_uploader = func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("author")), λ.NewInt(0))
							}), ϒcompat_str); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒstr_or_none, λ.Cal(λ.GetAttr(ϒvideo_details, "get", nil), λ.NewStr("author")))
						}
					}()
					if λ.IsTrue(ϒvideo_uploader) {
						ϒvideo_uploader = λ.Cal(ϒcompat_urllib_parse_unquote_plus, ϒvideo_uploader)
					} else {
						λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.NewStr("unable to extract uploader name"))
					}
					ϒvideo_uploader_id = λ.None
					ϒvideo_uploader_url = λ.None
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("<link itemprop=\"url\" href=\"(?P<uploader_url>https?://www\\.youtube\\.com/(?:user|channel)/(?P<uploader_id>[^\"]+))\">"), ϒvideo_webpage)
					if λ.IsTrue(λ.NewBool(ϒmobj != λ.None)) {
						ϒvideo_uploader_id = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("uploader_id"))
						ϒvideo_uploader_url = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("uploader_url"))
					} else {
						λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.NewStr("unable to extract uploader nickname"))
					}
					ϒchannel_id = λ.Cal(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewStr("channelId"), ϒvideo_webpage, λ.NewStr("channel id"))
					ϒchannel_url = func() λ.Object {
						if λ.IsTrue(ϒchannel_id) {
							return λ.Mod(λ.NewStr("http://www.youtube.com/channel/%s"), ϒchannel_id)
						} else {
							return λ.None
						}
					}()
					ϒm_thumb = λ.Cal(Ωre.ϒsearch, λ.NewStr("<span itemprop=\"thumbnail\".*?href=\"(.*?)\">"), ϒvideo_webpage, Ωre.DOTALL)
					if λ.IsTrue(λ.NewBool(ϒm_thumb != λ.None)) {
						ϒvideo_thumbnail = λ.Cal(λ.GetAttr(ϒm_thumb, "group", nil), λ.NewInt(1))
					} else {
						if λ.IsTrue(λ.NewBool(!λ.Contains(ϒvideo_info, λ.NewStr("thumbnail_url")))) {
							λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.NewStr("unable to extract video thumbnail"))
							ϒvideo_thumbnail = λ.None
						} else {
							ϒvideo_thumbnail = λ.Cal(ϒcompat_urllib_parse_unquote_plus, λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("thumbnail_url")), λ.NewInt(0)))
						}
					}
					ϒupload_date = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
						λ.NewStr("datePublished"),
						ϒvideo_webpage,
						λ.NewStr("upload date"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒupload_date))) {
						ϒupload_date = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.NewList(
								λ.NewStr("(?s)id=\"eow-date.*?>(.*?)</span>"),
								λ.NewStr("(?:id=\"watch-uploader-info\".*?>.*?|[\"\\']simpleText[\"\\']\\s*:\\s*[\"\\'])(?:Published|Uploaded|Streamed live|Started) on (.+?)[<\"\\']"),
							),
							ϒvideo_webpage,
							λ.NewStr("upload date"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
					}
					ϒupload_date = λ.Cal(ϒunified_strdate, ϒupload_date)
					ϒvideo_license = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.NewStr("<h4[^>]+class=\"title\"[^>]*>\\s*License\\s*</h4>\\s*<ul[^>]*>\\s*<li>(.+?)</li"),
						ϒvideo_webpage,
						λ.NewStr("license"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒm_music = λ.Cal(Ωre.ϒsearch, λ.NewStr("(?x)\n                <h4[^>]+class=\"title\"[^>]*>\\s*Music\\s*</h4>\\s*\n                <ul[^>]*>\\s*\n                <li>(?P<title>.+?)\n                by (?P<creator>.+?)\n                (?:\n                    \\(.+?\\)|\n                    <a[^>]*\n                        (?:\n                            \\bhref=[\"\\']/red[^>]*>|             # drop possible\n                            >\\s*Listen ad-free with YouTube Red # YouTube Red ad\n                        )\n                    .*?\n                )?</li\n            "), ϒvideo_webpage)
					if λ.IsTrue(ϒm_music) {
						ϒvideo_alt_title = λ.Cal(λ.None, λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒm_music, "group", nil), λ.NewStr("title"))))
						ϒvideo_creator = λ.Cal(ϒclean_html, λ.Cal(λ.GetAttr(ϒm_music, "group", nil), λ.NewStr("creator")))
					} else {
						τmp0 = λ.None
						ϒvideo_alt_title = τmp0
						ϒvideo_creator = τmp0
					}
					ϒextract_meta = λ.NewFunction("extract_meta",
						[]λ.Param{
							{Name: "field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield = λargs[0]
							)
							return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
								λ.Mod(λ.NewStr("<h4[^>]+class=\"title\"[^>]*>\\s*%s\\s*</h4>\\s*<ul[^>]*>\\s*<li>(.+?)</li>\\s*"), ϒfield),
								ϒvideo_webpage,
								ϒfield,
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							})
						})
					ϒtrack = λ.Cal(ϒextract_meta, λ.NewStr("Song"))
					ϒartist = λ.Cal(ϒextract_meta, λ.NewStr("Artist"))
					ϒm_episode = λ.Cal(Ωre.ϒsearch, λ.NewStr("<div[^>]+id=\"watch7-headline\"[^>]*>\\s*<span[^>]*>.*?>(?P<series>[^<]+)</a></b>\\s*S(?P<season>\\d+)\\s*•\\s*E(?P<episode>\\d+)</span>"), ϒvideo_webpage)
					if λ.IsTrue(ϒm_episode) {
						ϒseries = λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒm_episode, "group", nil), λ.NewStr("series")))
						ϒseason_number = λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒm_episode, "group", nil), λ.NewStr("season")))
						ϒepisode_number = λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒm_episode, "group", nil), λ.NewStr("episode")))
					} else {
						τmp0 = λ.None
						ϒseries = τmp0
						ϒseason_number = τmp0
						ϒepisode_number = τmp0
					}
					ϒm_cat_container = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewStr("(?s)<h4[^>]*>\\s*Category\\s*</h4>\\s*<ul[^>]*>(.*?)</ul>"),
						ϒvideo_webpage,
						λ.NewStr("categories"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒm_cat_container) {
						ϒcategory = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.NewStr("(?s)<a[^<]+>(.*?)</a>"),
							ϒm_cat_container,
							λ.NewStr("category"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						ϒvideo_categories = func() λ.Object {
							if λ.IsTrue(λ.NewBool(ϒcategory == λ.None)) {
								return λ.None
							} else {
								return λ.NewList(ϒcategory)
							}
						}()
					} else {
						ϒvideo_categories = λ.None
					}
					ϒvideo_tags = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
								var (
									ϒm   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.Cal(λ.GetAttr(ϒself, "_meta_regex", nil), λ.NewStr("og:video:tag")), ϒvideo_webpage))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒm = τmp1
									λgen.Yield(λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewStr("content"))))
								}
								return λ.None
							})
						})))
					ϒ_extract_count = λ.NewFunction("_extract_count",
						[]λ.Param{
							{Name: "count_name"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcount_name = λargs[0]
							)
							return λ.Cal(ϒstr_to_int, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.Mod(λ.NewStr("-%s-button[^>]+><span[^>]+class=\"yt-uix-button-content\"[^>]*>([\\d,]+)</span>"), λ.Cal(Ωre.ϒescape, ϒcount_name)),
								ϒvideo_webpage,
								ϒcount_name,
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						})
					ϒlike_count = λ.Cal(ϒ_extract_count, λ.NewStr("like"))
					ϒdislike_count = λ.Cal(ϒ_extract_count, λ.NewStr("dislike"))
					if λ.IsTrue(λ.NewBool(ϒview_count == λ.None)) {
						ϒview_count = λ.Cal(ϒstr_to_int, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.NewStr("<[^>]+class=[\"\\']watch-view-count[^>]+>\\s*([\\d,\\s]+)"),
							ϒvideo_webpage,
							λ.NewStr("view count"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}))
					}
					ϒvideo_subtitles = λ.Cal(λ.GetAttr(ϒself, "extract_subtitles", nil), ϒvideo_id, ϒvideo_webpage)
					ϒautomatic_captions = λ.Cal(λ.GetAttr(ϒself, "extract_automatic_captions", nil), ϒvideo_id, ϒvideo_webpage)
					ϒvideo_duration = λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.Cal(ϒint_or_none, λ.GetItem(λ.GetItem(ϒx, λ.NewStr("length_seconds")), λ.NewInt(0)))
						}))
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒvideo_duration))) {
						ϒvideo_duration = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒvideo_details, "get", nil), λ.NewStr("lengthSeconds")))
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒvideo_duration))) {
						ϒvideo_duration = λ.Cal(ϒparse_duration, λ.Cal(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewStr("duration"), ϒvideo_webpage, λ.NewStr("video duration")))
					}
					ϒvideo_annotations = λ.None
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("writeannotations"), λ.False)) {
						ϒvideo_annotations = λ.Cal(λ.GetAttr(ϒself, "_extract_annotations", nil), ϒvideo_id)
					}
					ϒchapters = λ.Cal(λ.GetAttr(ϒself, "_extract_chapters", nil), ϒdescription_original, ϒvideo_duration)
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("youtube_include_dash_manifest"), λ.True)) {
						ϒdash_mpd_fatal = λ.True
						τmp0 = λ.Cal(λ.BuiltinIter, ϒdash_mpds)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒmpd_url = τmp1
							ϒdash_formats = λ.NewDictWithTable(map[λ.Object]λ.Object{})
							τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{λ.NewTuple(
										ExtractorError,
										λ.KeyErrorType,
									), func(λex λ.BaseException) {
										ϒe := λex
										λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("Skipping DASH manifest: %r"), ϒe), ϒvideo_id)
									}},
								)
								ϒdecrypt_sig = λ.NewFunction("decrypt_sig",
									[]λ.Param{
										{Name: "mobj"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒdec_s λ.Object
											ϒmobj  = λargs[0]
											ϒs     λ.Object
										)
										ϒs = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewInt(1))
										ϒdec_s = λ.Cal(λ.GetAttr(ϒself, "_decrypt_signature", nil), ϒs, ϒvideo_id, ϒplayer_url, ϒage_gate)
										return λ.Mod(λ.NewStr("/signature/%s"), ϒdec_s)
									})
								ϒmpd_url = λ.Cal(Ωre.ϒsub, λ.NewStr("/s/([a-fA-F0-9\\.]+)"), ϒdecrypt_sig, ϒmpd_url)
								τmp4 = λ.Cal(λ.BuiltinIter, λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
									ϒmpd_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "fatal", Value: ϒdash_mpd_fatal},
									{Name: "formats_dict", Value: λ.GetAttr(ϒself, "_formats", nil)},
								}))
								for {
									if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
										break
									}
									ϒdf = τmp5
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒdf, "get", nil), λ.NewStr("filesize"))))) {
										λ.SetItem(ϒdf, λ.NewStr("filesize"), λ.Cal(ϒ_extract_filesize, λ.GetItem(ϒdf, λ.NewStr("url"))))
									}
									if λ.IsTrue(λ.NewBool(!λ.Contains(ϒdash_formats, λ.GetItem(ϒdf, λ.NewStr("format_id"))))) {
										λ.SetItem(ϒdash_formats, λ.GetItem(ϒdf, λ.NewStr("format_id")), ϒdf)
									}
									ϒdash_mpd_fatal = λ.False
								}
								return λ.BlockExitNormally, nil
							}()
							if λ.IsTrue(ϒdash_formats) {
								ϒformats = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
											var (
												ϒf   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒf = τmp1
												if λ.IsTrue(λ.NewBool(!λ.Contains(λ.Cal(λ.GetAttr(ϒdash_formats, "keys", nil)), λ.GetItem(ϒf, λ.NewStr("format_id"))))) {
													λgen.Yield(ϒf)
												}
											}
											return λ.None
										})
									})))
								λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Cal(λ.GetAttr(ϒdash_formats, "values", nil)))
							}
						}
					}
					ϒstretched_m = λ.Cal(Ωre.ϒsearch, λ.NewStr("<meta\\s+property=\"og:video:tag\".*?content=\"yt:stretch=(?P<w>[0-9]+):(?P<h>[0-9]+)\">"), ϒvideo_webpage)
					if λ.IsTrue(ϒstretched_m) {
						ϒw = λ.Cal(λ.FloatType, λ.Cal(λ.GetAttr(ϒstretched_m, "group", nil), λ.NewStr("w")))
						ϒh = λ.Cal(λ.FloatType, λ.Cal(λ.GetAttr(ϒstretched_m, "group", nil), λ.NewStr("h")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Gt(ϒw, λ.NewInt(0)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Gt(ϒh, λ.NewInt(0))
							}
						}()) {
							ϒratio = λ.TrueDiv(ϒw, ϒh)
							τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒf = τmp1
								if λ.IsTrue(λ.Ne(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none"))) {
									λ.SetItem(ϒf, λ.NewStr("stretched_ratio"), ϒratio)
								}
							}
						}
					}
					λ.Cal(λ.GetAttr(ϒself, "_sort_formats", nil), ϒformats)
					λ.Cal(λ.GetAttr(ϒself, "mark_watched", nil), ϒvideo_id, ϒvideo_info, ϒplayer_response)
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):           ϒvideo_id,
						λ.NewStr("uploader"):     ϒvideo_uploader,
						λ.NewStr("uploader_id"):  ϒvideo_uploader_id,
						λ.NewStr("uploader_url"): ϒvideo_uploader_url,
						λ.NewStr("channel_id"):   ϒchannel_id,
						λ.NewStr("channel_url"):  ϒchannel_url,
						λ.NewStr("upload_date"):  ϒupload_date,
						λ.NewStr("license"):      ϒvideo_license,
						λ.NewStr("creator"): func() λ.Object {
							if λv := ϒvideo_creator; λ.IsTrue(λv) {
								return λv
							} else {
								return ϒartist
							}
						}(),
						λ.NewStr("title"): ϒvideo_title,
						λ.NewStr("alt_title"): func() λ.Object {
							if λv := ϒvideo_alt_title; λ.IsTrue(λv) {
								return λv
							} else {
								return ϒtrack
							}
						}(),
						λ.NewStr("thumbnail"):          ϒvideo_thumbnail,
						λ.NewStr("description"):        ϒvideo_description,
						λ.NewStr("categories"):         ϒvideo_categories,
						λ.NewStr("tags"):               ϒvideo_tags,
						λ.NewStr("subtitles"):          ϒvideo_subtitles,
						λ.NewStr("automatic_captions"): ϒautomatic_captions,
						λ.NewStr("duration"):           ϒvideo_duration,
						λ.NewStr("age_limit"): func() λ.Object {
							if λ.IsTrue(ϒage_gate) {
								return λ.NewInt(18)
							} else {
								return λ.NewInt(0)
							}
						}(),
						λ.NewStr("annotations"):    ϒvideo_annotations,
						λ.NewStr("chapters"):       ϒchapters,
						λ.NewStr("webpage_url"):    λ.Add(ϒproto, λ.Mod(λ.NewStr("://www.youtube.com/watch?v=%s"), ϒvideo_id)),
						λ.NewStr("view_count"):     ϒview_count,
						λ.NewStr("like_count"):     ϒlike_count,
						λ.NewStr("dislike_count"):  ϒdislike_count,
						λ.NewStr("average_rating"): λ.Cal(ϒfloat_or_none, λ.GetItem(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("avg_rating"), λ.NewList(λ.None)), λ.NewInt(0))),
						λ.NewStr("formats"):        ϒformats,
						λ.NewStr("is_live"):        ϒis_live,
						λ.NewStr("start_time"):     ϒstart_time,
						λ.NewStr("end_time"):       ϒend_time,
						λ.NewStr("series"):         ϒseries,
						λ.NewStr("season_number"):  ϒseason_number,
						λ.NewStr("episode_number"): ϒepisode_number,
						λ.NewStr("track"):          ϒtrack,
						λ.NewStr("artist"):         ϒartist,
					})
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("IE_NAME"):              YoutubeIE_IE_NAME,
				λ.NewStr("_GEO_BYPASS"):          YoutubeIE__GEO_BYPASS,
				λ.NewStr("_NEXT_URL_RE"):         YoutubeIE__NEXT_URL_RE,
				λ.NewStr("_VALID_URL"):           YoutubeIE__VALID_URL,
				λ.NewStr("__init__"):             YoutubeIE___init__,
				λ.NewStr("_extract_url"):         YoutubeIE__extract_url,
				λ.NewStr("_extract_urls"):        YoutubeIE__extract_urls,
				λ.NewStr("_get_ytplayer_config"): YoutubeIE__get_ytplayer_config,
				λ.NewStr("_real_extract"):        YoutubeIE__real_extract,
				λ.NewStr("extract_id"):           YoutubeIE_extract_id,
			})
		}())
		YoutubePlaylistIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubePlaylistIE"), λ.NewTuple(YoutubePlaylistBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeChannelIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeChannelIE"), λ.NewTuple(YoutubePlaylistBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeUserIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeUserIE"), λ.NewTuple(YoutubeChannelIE), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeLiveIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeLiveIE"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubePlaylistsIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubePlaylistsIE"), λ.NewTuple(YoutubePlaylistsBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeSearchBaseInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("YoutubeSearchBaseInfoExtractor"), λ.NewTuple(YoutubePlaylistBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeSearchIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeSearchIE"), λ.NewTuple(
			SearchInfoExtractor,
			YoutubeSearchBaseInfoExtractor,
		), func() λ.Dict {
			var (
				YoutubeSearchIE_IE_NAME λ.Object
			)
			YoutubeSearchIE_IE_NAME = λ.NewStr("youtube:search")
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("IE_NAME"): YoutubeSearchIE_IE_NAME,
			})
		}())
		YoutubeSearchURLIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeSearchURLIE"), λ.NewTuple(YoutubeSearchBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeShowIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeShowIE"), λ.NewTuple(YoutubePlaylistsBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeFeedsInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("YoutubeFeedsInfoExtractor"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {
			λ.NewStr("\n    Base class for feed extractors\n    Subclasses must define the _FEED_NAME and _PLAYLIST_TITLE properties.\n    ")
			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeWatchLaterIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeWatchLaterIE"), λ.NewTuple(YoutubePlaylistIE), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeFavouritesIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeFavouritesIE"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeRecommendedIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeRecommendedIE"), λ.NewTuple(YoutubeFeedsInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeSubscriptionsIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeSubscriptionsIE"), λ.NewTuple(YoutubeFeedsInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeHistoryIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeHistoryIE"), λ.NewTuple(YoutubeFeedsInfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeTruncatedURLIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeTruncatedURLIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
		YoutubeTruncatedIDIE = λ.Cal(λ.TypeType, λ.NewStr("YoutubeTruncatedIDIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {

			return λ.NewDictWithTable(map[λ.Object]λ.Object{})
		}())
	})
}

// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * bandcamp/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/bandcamp.py
 */

package bandcamp

import (
	Ωrandom "github.com/tenta-browser/go-video-downloader/gen/random"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωtime "github.com/tenta-browser/go-video-downloader/gen/time"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	BandcampAlbumIE    λ.Object
	BandcampIE         λ.Object
	BandcampWeeklyIE   λ.Object
	ExtractorError     λ.Object
	InfoExtractor      λ.Object
	KNOWN_EXTENSIONS   λ.Object
	ϒcompat_str        λ.Object
	ϒfloat_or_none     λ.Object
	ϒint_or_none       λ.Object
	ϒparse_filesize    λ.Object
	ϒstr_or_none       λ.Object
	ϒtry_get           λ.Object
	ϒunescapeHTML      λ.Object
	ϒunified_strdate   λ.Object
	ϒunified_timestamp λ.Object
	ϒupdate_url_query  λ.Object
	ϒurl_or_none       λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_str = Ωcompat.ϒcompat_str
		ExtractorError = Ωutils.ExtractorError
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		ϒint_or_none = Ωutils.ϒint_or_none
		KNOWN_EXTENSIONS = Ωutils.KNOWN_EXTENSIONS
		ϒparse_filesize = Ωutils.ϒparse_filesize
		ϒstr_or_none = Ωutils.ϒstr_or_none
		ϒtry_get = Ωutils.ϒtry_get
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒupdate_url_query = Ωutils.ϒupdate_url_query
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		ϒurl_or_none = Ωutils.ϒurl_or_none
		BandcampIE = λ.Cal(λ.TypeType, λ.StrLiteral("BandcampIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BandcampIE__VALID_URL    λ.Object
				BandcampIE__real_extract λ.Object
			)
			BandcampIE__VALID_URL = λ.StrLiteral("https?://[^/]+\\.bandcamp\\.com/track/(?P<title>[^/?#&]+)")
			BandcampIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabr_str               λ.Object
						ϒalbum                 λ.Object
						ϒartist                λ.Object
						ϒblob                  λ.Object
						ϒdownload_formats      λ.Object
						ϒdownload_formats_list λ.Object
						ϒdownload_link         λ.Object
						ϒdownload_webpage      λ.Object
						ϒdownloads             λ.Object
						ϒduration              λ.Object
						ϒext                   λ.Object
						ϒextract               λ.Object
						ϒf                     λ.Object
						ϒfile_                 λ.Object
						ϒformat_id             λ.Object
						ϒformat_url            λ.Object
						ϒformats               λ.Object
						ϒinfo                  λ.Object
						ϒmobj                  λ.Object
						ϒname                  λ.Object
						ϒrelease_date          λ.Object
						ϒretry_url             λ.Object
						ϒself                  = λargs[0]
						ϒstat                  λ.Object
						ϒstat_url              λ.Object
						ϒthumbnail             λ.Object
						ϒtimestamp             λ.Object
						ϒtitle                 λ.Object
						ϒtrack                 λ.Object
						ϒtrack_id              λ.Object
						ϒtrack_info            λ.Object
						ϒtrack_number          λ.Object
						ϒurl                   = λargs[1]
						ϒwebpage               λ.Object
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
					)
					ϒmobj = λ.Cal(Ωre.ϒmatch, λ.GetAttr(ϒself, "_VALID_URL", nil), ϒurl)
					ϒtitle = λ.Calm(ϒmobj, "group", λ.StrLiteral("title"))
					ϒwebpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒtitle)
					ϒthumbnail = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
						λ.StrLiteral("og:image"),
						ϒwebpage,
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒtrack_id = λ.None
					ϒtrack = λ.None
					ϒtrack_number = λ.None
					ϒduration = λ.None
					ϒformats = λ.NewList()
					ϒtrack_info = λ.Calm(ϒself, "_parse_json", λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("trackinfo\\s*:\\s*\\[\\s*({.+?})\\s*\\]\\s*,\\s*?\\n"),
						ϒwebpage,
						λ.StrLiteral("track info"),
					), λ.KWArgs{
						{Name: "default", Value: λ.StrLiteral("{}")},
					}), ϒtitle)
					if λ.IsTrue(ϒtrack_info) {
						ϒfile_ = λ.Calm(ϒtrack_info, "get", λ.StrLiteral("file"))
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒfile_, λ.DictType)) {
							τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒfile_, "items"))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								τmp2 = τmp1
								ϒformat_id = λ.GetItem(τmp2, λ.IntLiteral(0))
								ϒformat_url = λ.GetItem(τmp2, λ.IntLiteral(1))
								if !λ.IsTrue(λ.Cal(ϒurl_or_none, ϒformat_url)) {
									continue
								}
								τmp2 = λ.Calm(ϒformat_id, "split", λ.StrLiteral("-"), λ.IntLiteral(1))
								ϒext = λ.GetItem(τmp2, λ.IntLiteral(0))
								ϒabr_str = λ.GetItem(τmp2, λ.IntLiteral(1))
								λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
									"format_id": ϒformat_id,
									"url":       λ.Calm(ϒself, "_proto_relative_url", ϒformat_url, λ.StrLiteral("http:")),
									"ext":       ϒext,
									"vcodec":    λ.StrLiteral("none"),
									"acodec":    ϒext,
									"abr":       λ.Cal(ϒint_or_none, ϒabr_str),
								}))
							}
						}
						ϒtrack = λ.Calm(ϒtrack_info, "get", λ.StrLiteral("title"))
						ϒtrack_id = λ.Cal(ϒstr_or_none, func() λ.Object {
							if λv := λ.Calm(ϒtrack_info, "get", λ.StrLiteral("track_id")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒtrack_info, "get", λ.StrLiteral("id"))
							}
						}())
						ϒtrack_number = λ.Cal(ϒint_or_none, λ.Calm(ϒtrack_info, "get", λ.StrLiteral("track_num")))
						ϒduration = λ.Cal(ϒfloat_or_none, λ.Calm(ϒtrack_info, "get", λ.StrLiteral("duration")))
					}
					ϒextract = λ.NewFunction("extract",
						[]λ.Param{
							{Name: "key"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒkey = λargs[0]
							)
							return λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.Mod(λ.StrLiteral("\\b%s\\s*[\"\\']?\\s*:\\s*([\"\\'])(?P<value>(?:(?!\\1).)+)\\1"), ϒkey),
								ϒwebpage,
								ϒkey,
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
								{Name: "group", Value: λ.StrLiteral("value")},
							})
						})
					ϒartist = λ.Cal(ϒextract, λ.StrLiteral("artist"))
					ϒalbum = λ.Cal(ϒextract, λ.StrLiteral("album_title"))
					ϒtimestamp = λ.Cal(ϒunified_timestamp, func() λ.Object {
						if λv := λ.Cal(ϒextract, λ.StrLiteral("publish_date")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒextract, λ.StrLiteral("album_publish_date"))
						}
					}())
					ϒrelease_date = λ.Cal(ϒunified_strdate, λ.Cal(ϒextract, λ.StrLiteral("album_release_date")))
					ϒdownload_link = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("freeDownloadPage\\s*:\\s*([\"\\'])(?P<url>(?:(?!\\1).)+)\\1"),
						ϒwebpage,
						λ.StrLiteral("download link"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
						{Name: "group", Value: λ.StrLiteral("url")},
					})
					if λ.IsTrue(ϒdownload_link) {
						ϒtrack_id = λ.Calm(ϒself, "_search_regex", λ.StrLiteral("(?ms)var TralbumData = .*?[{,]\\s*id: (?P<id>\\d+),?$"), ϒwebpage, λ.StrLiteral("track id"))
						ϒdownload_webpage = λ.Calm(ϒself, "_download_webpage", ϒdownload_link, ϒtrack_id, λ.StrLiteral("Downloading free downloads page"))
						ϒblob = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("data-blob=([\"\\'])(?P<blob>{.+?})\\1"),
								ϒdownload_webpage,
								λ.StrLiteral("blob"),
							), λ.KWArgs{
								{Name: "group", Value: λ.StrLiteral("blob")},
							}),
							ϒtrack_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒunescapeHTML},
						})
						ϒinfo = λ.Cal(ϒtry_get, ϒblob, λ.NewTuple(
							λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("digital_items")), λ.IntLiteral(0))
								}),
							λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("download_items")), λ.IntLiteral(0))
								}),
						), λ.DictType)
						if λ.IsTrue(ϒinfo) {
							ϒdownloads = λ.Calm(ϒinfo, "get", λ.StrLiteral("downloads"))
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒdownloads, λ.DictType)) {
								if !λ.IsTrue(ϒtrack) {
									ϒtrack = λ.Calm(ϒinfo, "get", λ.StrLiteral("title"))
								}
								if !λ.IsTrue(ϒartist) {
									ϒartist = λ.Calm(ϒinfo, "get", λ.StrLiteral("artist"))
								}
								if !λ.IsTrue(ϒthumbnail) {
									ϒthumbnail = λ.Calm(ϒinfo, "get", λ.StrLiteral("thumb_url"))
								}
								ϒdownload_formats = λ.DictLiteral(map[λ.Object]λ.Object{})
								ϒdownload_formats_list = λ.Calm(ϒblob, "get", λ.StrLiteral("download_formats"))
								if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒdownload_formats_list, λ.ListType)) {
									τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒblob, λ.StrLiteral("download_formats")))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒf = τmp1
										τmp2 = λ.NewTuple(
											λ.Calm(ϒf, "get", λ.StrLiteral("name")),
											λ.Calm(ϒf, "get", λ.StrLiteral("file_extension")),
										)
										ϒname = λ.GetItem(τmp2, λ.IntLiteral(0))
										ϒext = λ.GetItem(τmp2, λ.IntLiteral(1))
										if λ.IsTrue(λ.Cal(λ.BuiltinAll, λ.Cal(λ.NewFunction("<generator>",
											nil,
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
													var (
														ϒx   λ.Object
														τmp0 λ.Object
														τmp1 λ.Object
													)
													τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
														ϒname,
														ϒext,
													))
													for {
														if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
															break
														}
														ϒx = τmp1
														λgy.Yield(λ.Cal(λ.BuiltinIsInstance, ϒx, ϒcompat_str))
													}
													return λ.None
												})
											})))) {
											λ.SetItem(ϒdownload_formats, ϒname, λ.Calm(ϒext, "strip", λ.StrLiteral(".")))
										}
									}
								}
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒdownloads, "items"))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒformat_id = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒf = λ.GetItem(τmp2, λ.IntLiteral(1))
									ϒformat_url = λ.Calm(ϒf, "get", λ.StrLiteral("url"))
									if !λ.IsTrue(ϒformat_url) {
										continue
									}
									ϒstat_url = λ.Cal(ϒupdate_url_query, λ.Calm(ϒformat_url, "replace", λ.StrLiteral("/download/"), λ.StrLiteral("/statdownload/")), λ.DictLiteral(map[string]λ.Object{
										".rand": λ.Cal(λ.IntType, λ.Mul(λ.Mul(λ.Cal(Ωtime.ϒtime), λ.IntLiteral(1000)), λ.Cal(Ωrandom.ϒrandom))),
									}))
									ϒformat_id = func() λ.Object {
										if λv := λ.Calm(ϒf, "get", λ.StrLiteral("encoding_name")); λ.IsTrue(λv) {
											return λv
										} else {
											return ϒformat_id
										}
									}()
									ϒstat = λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
										ϒstat_url,
										ϒtrack_id,
										λ.Mod(λ.StrLiteral("Downloading %s JSON"), ϒformat_id),
									), λ.KWArgs{
										{Name: "transform_source", Value: λ.NewFunction("<lambda>",
											[]λ.Param{
												{Name: "s"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒs = λargs[0]
												)
												return λ.GetItem(ϒs, λ.NewSlice(λ.Calm(ϒs, "index", λ.StrLiteral("{")), λ.Add(λ.Calm(ϒs, "rindex", λ.StrLiteral("}")), λ.IntLiteral(1)), λ.None))
											})},
										{Name: "fatal", Value: λ.False},
									})
									if !λ.IsTrue(ϒstat) {
										continue
									}
									ϒretry_url = λ.Cal(ϒurl_or_none, λ.Calm(ϒstat, "get", λ.StrLiteral("retry_url")))
									if !λ.IsTrue(ϒretry_url) {
										continue
									}
									λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
										"url":         λ.Calm(ϒself, "_proto_relative_url", ϒretry_url, λ.StrLiteral("http:")),
										"ext":         λ.Calm(ϒdownload_formats, "get", ϒformat_id),
										"format_id":   ϒformat_id,
										"format_note": λ.Calm(ϒf, "get", λ.StrLiteral("description")),
										"filesize":    λ.Cal(ϒparse_filesize, λ.Calm(ϒf, "get", λ.StrLiteral("size_mb"))),
										"vcodec":      λ.StrLiteral("none"),
									}))
								}
							}
						}
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					ϒtitle = func() λ.Object {
						if λ.IsTrue(ϒartist) {
							return λ.Mod(λ.StrLiteral("%s - %s"), λ.NewTuple(
								ϒartist,
								ϒtrack,
							))
						} else {
							return ϒtrack
						}
					}()
					if !λ.IsTrue(ϒduration) {
						ϒduration = λ.Cal(ϒfloat_or_none, λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
							λ.StrLiteral("duration"),
							ϒwebpage,
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}))
					}
					return λ.DictLiteral(map[string]λ.Object{
						"id":           ϒtrack_id,
						"title":        ϒtitle,
						"thumbnail":    ϒthumbnail,
						"uploader":     ϒartist,
						"timestamp":    ϒtimestamp,
						"release_date": ϒrelease_date,
						"duration":     ϒduration,
						"track":        ϒtrack,
						"track_number": ϒtrack_number,
						"track_id":     ϒtrack_id,
						"artist":       ϒartist,
						"album":        ϒalbum,
						"formats":      ϒformats,
					})
				})
			return λ.DictLiteral(map[string]λ.Object{
				"_VALID_URL":    BandcampIE__VALID_URL,
				"_real_extract": BandcampIE__real_extract,
			})
		}())
		BandcampAlbumIE = λ.Cal(λ.TypeType, λ.StrLiteral("BandcampAlbumIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BandcampAlbumIE__VALID_URL λ.Object
				BandcampAlbumIE_suitable   λ.Object
			)
			BandcampAlbumIE__VALID_URL = λ.StrLiteral("https?://(?:(?P<subdomain>[^.]+)\\.)?bandcamp\\.com(?:/album/(?P<album_id>[^/?#&]+))?")
			BandcampAlbumIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(BandcampWeeklyIE, "suitable", ϒurl); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(BandcampIE, "suitable", ϒurl)
							}
						}()) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, BandcampAlbumIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			BandcampAlbumIE_suitable = λ.Cal(λ.ClassMethodType, BandcampAlbumIE_suitable)
			return λ.DictLiteral(map[string]λ.Object{
				"_VALID_URL": BandcampAlbumIE__VALID_URL,
				"suitable":   BandcampAlbumIE_suitable,
			})
		}())
		BandcampWeeklyIE = λ.Cal(λ.TypeType, λ.StrLiteral("BandcampWeeklyIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BandcampWeeklyIE_IE_NAME       λ.Object
				BandcampWeeklyIE__VALID_URL    λ.Object
				BandcampWeeklyIE__real_extract λ.Object
			)
			BandcampWeeklyIE_IE_NAME = λ.StrLiteral("Bandcamp:weekly")
			BandcampWeeklyIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?bandcamp\\.com/?\\?(?:.*?&)?show=(?P<id>\\d+)")
			BandcampWeeklyIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒblob           λ.Object
						ϒepisode_number λ.Object
						ϒext            λ.Object
						ϒformat_id      λ.Object
						ϒformat_url     λ.Object
						ϒformats        λ.Object
						ϒknown_ext      λ.Object
						ϒself           = λargs[0]
						ϒseq            λ.Object
						ϒshow           λ.Object
						ϒshow_id        λ.Object
						ϒsubtitle       λ.Object
						ϒtitle          λ.Object
						ϒurl            = λargs[1]
						ϒvideo_id       λ.Object
						ϒwebpage        λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
						τmp3            λ.Object
					)
					_ = τmp0
					_ = τmp1
					ϒvideo_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒwebpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒvideo_id)
					ϒblob = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
						λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("data-blob=([\"\\'])(?P<blob>{.+?})\\1"),
							ϒwebpage,
							λ.StrLiteral("blob"),
						), λ.KWArgs{
							{Name: "group", Value: λ.StrLiteral("blob")},
						}),
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "transform_source", Value: ϒunescapeHTML},
					})
					ϒshow = λ.GetItem(ϒblob, λ.StrLiteral("bcw_show"))
					ϒshow_id = func() λ.Object {
						if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒshow, "get", λ.StrLiteral("show_id"))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒint_or_none, ϒvideo_id)
						}
					}()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(λ.GetItem(ϒshow, λ.StrLiteral("audio_stream")), "items"))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒformat_id = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒformat_url = λ.GetItem(τmp2, λ.IntLiteral(1))
						if !λ.IsTrue(λ.Cal(ϒurl_or_none, ϒformat_url)) {
							continue
						}
						τmp2 = λ.Cal(λ.BuiltinIter, KNOWN_EXTENSIONS)
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒknown_ext = τmp3
							if λ.Contains(ϒformat_id, ϒknown_ext) {
								ϒext = ϒknown_ext
								break
							}
						}
						if τmp3 == λ.AfterLast {
							ϒext = λ.None
						}
						λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
							"format_id": ϒformat_id,
							"url":       ϒformat_url,
							"ext":       ϒext,
							"vcodec":    λ.StrLiteral("none"),
						}))
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					ϒtitle = func() λ.Object {
						if λv := λ.Calm(ϒshow, "get", λ.StrLiteral("audio_title")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.StrLiteral("Bandcamp Weekly")
						}
					}()
					ϒsubtitle = λ.Calm(ϒshow, "get", λ.StrLiteral("subtitle"))
					if λ.IsTrue(ϒsubtitle) {
						τmp0 = λ.IAdd(ϒtitle, λ.Mod(λ.StrLiteral(" - %s"), ϒsubtitle))
						ϒtitle = τmp0
					}
					ϒepisode_number = λ.None
					ϒseq = λ.Calm(ϒblob, "get", λ.StrLiteral("bcw_seq"))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒseq; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.BuiltinIsInstance, ϒseq, λ.ListType)
						}
					}()) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.StopIterationType, func(λex λ.BaseException) {
									// pass
								}},
							)
							ϒepisode_number = λ.Cal(λ.BuiltinNext, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
										var (
											ϒe   λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, ϒseq)
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒe = τmp1
											if λ.IsTrue(func() λ.Object {
												if λv := λ.Cal(λ.BuiltinIsInstance, ϒe, λ.DictType); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Eq(λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("id"))), ϒshow_id)
												}
											}()) {
												λgy.Yield(λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("episode_number"))))
											}
										}
										return λ.None
									})
								})))
							return λ.BlockExitNormally, nil
						}()
					}
					return λ.DictLiteral(map[string]λ.Object{
						"id":    ϒvideo_id,
						"title": ϒtitle,
						"description": func() λ.Object {
							if λv := λ.Calm(ϒshow, "get", λ.StrLiteral("desc")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒshow, "get", λ.StrLiteral("short_desc"))
							}
						}(),
						"duration":       λ.Cal(ϒfloat_or_none, λ.Calm(ϒshow, "get", λ.StrLiteral("audio_duration"))),
						"is_live":        λ.False,
						"release_date":   λ.Cal(ϒunified_strdate, λ.Calm(ϒshow, "get", λ.StrLiteral("published_date"))),
						"series":         λ.StrLiteral("Bandcamp Weekly"),
						"episode":        λ.Calm(ϒshow, "get", λ.StrLiteral("subtitle")),
						"episode_number": ϒepisode_number,
						"episode_id":     λ.Cal(ϒcompat_str, ϒvideo_id),
						"formats":        ϒformats,
					})
				})
			return λ.DictLiteral(map[string]λ.Object{
				"IE_NAME":       BandcampWeeklyIE_IE_NAME,
				"_VALID_URL":    BandcampWeeklyIE__VALID_URL,
				"_real_extract": BandcampWeeklyIE__real_extract,
			})
		}())
	})
}

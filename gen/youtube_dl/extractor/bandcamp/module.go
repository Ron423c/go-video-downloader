// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * bandcamp/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/bandcamp.py
 */

package bandcamp

import (
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωtime "github.com/tenta-browser/go-video-downloader/gen/time"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	BandcampAlbumIE    λ.Object
	BandcampIE         λ.Object
	BandcampWeeklyIE   λ.Object
	ExtractorError     λ.Object
	InfoExtractor      λ.Object
	KNOWN_EXTENSIONS   λ.Object
	ϒcompat_str        λ.Object
	ϒfloat_or_none     λ.Object
	ϒint_or_none       λ.Object
	ϒparse_filesize    λ.Object
	ϒstr_or_none       λ.Object
	ϒtry_get           λ.Object
	ϒunescapeHTML      λ.Object
	ϒunified_strdate   λ.Object
	ϒunified_timestamp λ.Object
	ϒupdate_url_query  λ.Object
	ϒurl_or_none       λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_str = Ωcompat.ϒcompat_str
		ExtractorError = Ωutils.ExtractorError
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		ϒint_or_none = Ωutils.ϒint_or_none
		KNOWN_EXTENSIONS = Ωutils.KNOWN_EXTENSIONS
		ϒparse_filesize = Ωutils.ϒparse_filesize
		ϒstr_or_none = Ωutils.ϒstr_or_none
		ϒtry_get = Ωutils.ϒtry_get
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒupdate_url_query = Ωutils.ϒupdate_url_query
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		ϒurl_or_none = Ωutils.ϒurl_or_none
		BandcampIE = λ.Cal(λ.TypeType, λ.NewStr("BandcampIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BandcampIE__TESTS        λ.Object
				BandcampIE__VALID_URL    λ.Object
				BandcampIE__real_extract λ.Object
			)
			BandcampIE__VALID_URL = λ.NewStr("https?://[^/]+\\.bandcamp\\.com/track/(?P<title>[^/?#&]+)")
			BandcampIE__TESTS = λ.NewList(
				λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("url"): λ.NewStr("http://youtube-dl.bandcamp.com/track/youtube-dl-test-song"),
					λ.NewStr("md5"): λ.NewStr("c557841d5e50261777a6585648adf439"),
					λ.NewStr("info_dict"): λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):       λ.NewStr("1812978515"),
						λ.NewStr("ext"):      λ.NewStr("mp3"),
						λ.NewStr("title"):    λ.NewStr("youtube-dl  \"'/\\ä↭ - youtube-dl test song \"'/\\ä↭"),
						λ.NewStr("duration"): λ.NewFloat(9.8485),
					}),
					λ.NewStr("_skip"): λ.NewStr("There is a limit of 200 free downloads / month for the test song"),
				}),
				λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("url"): λ.NewStr("http://benprunty.bandcamp.com/track/lanius-battle"),
					λ.NewStr("md5"): λ.NewStr("853e35bf34aa1d6fe2615ae612564b36"),
					λ.NewStr("info_dict"): λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):           λ.NewStr("2650410135"),
						λ.NewStr("ext"):          λ.NewStr("aiff"),
						λ.NewStr("title"):        λ.NewStr("Ben Prunty - Lanius (Battle)"),
						λ.NewStr("thumbnail"):    λ.NewStr("re:^https?://.*\\.jpg$"),
						λ.NewStr("uploader"):     λ.NewStr("Ben Prunty"),
						λ.NewStr("timestamp"):    λ.NewInt(1396508491),
						λ.NewStr("upload_date"):  λ.NewStr("20140403"),
						λ.NewStr("release_date"): λ.NewStr("20140403"),
						λ.NewStr("duration"):     λ.NewFloat(260.877),
						λ.NewStr("track"):        λ.NewStr("Lanius (Battle)"),
						λ.NewStr("track_number"): λ.NewInt(1),
						λ.NewStr("track_id"):     λ.NewStr("2650410135"),
						λ.NewStr("artist"):       λ.NewStr("Ben Prunty"),
						λ.NewStr("album"):        λ.NewStr("FTL: Advanced Edition Soundtrack"),
					}),
				}),
				λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("url"): λ.NewStr("https://relapsealumni.bandcamp.com/track/hail-to-fire"),
					λ.NewStr("md5"): λ.NewStr("fec12ff55e804bb7f7ebeb77a800c8b7"),
					λ.NewStr("info_dict"): λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):           λ.NewStr("2584466013"),
						λ.NewStr("ext"):          λ.NewStr("mp3"),
						λ.NewStr("title"):        λ.NewStr("Mastodon - Hail to Fire"),
						λ.NewStr("thumbnail"):    λ.NewStr("re:^https?://.*\\.jpg$"),
						λ.NewStr("uploader"):     λ.NewStr("Mastodon"),
						λ.NewStr("timestamp"):    λ.NewInt(1322005399),
						λ.NewStr("upload_date"):  λ.NewStr("20111122"),
						λ.NewStr("release_date"): λ.NewStr("20040207"),
						λ.NewStr("duration"):     λ.NewFloat(120.79),
						λ.NewStr("track"):        λ.NewStr("Hail to Fire"),
						λ.NewStr("track_number"): λ.NewInt(5),
						λ.NewStr("track_id"):     λ.NewStr("2584466013"),
						λ.NewStr("artist"):       λ.NewStr("Mastodon"),
						λ.NewStr("album"):        λ.NewStr("Call of the Mastodon"),
					}),
				}),
			)
			BandcampIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabr_str               λ.Object
						ϒalbum                 λ.Object
						ϒartist                λ.Object
						ϒblob                  λ.Object
						ϒdownload_formats      λ.Object
						ϒdownload_formats_list λ.Object
						ϒdownload_link         λ.Object
						ϒdownload_webpage      λ.Object
						ϒdownloads             λ.Object
						ϒduration              λ.Object
						ϒext                   λ.Object
						ϒextract               λ.Object
						ϒf                     λ.Object
						ϒfile_                 λ.Object
						ϒformat_id             λ.Object
						ϒformat_url            λ.Object
						ϒformats               λ.Object
						ϒinfo                  λ.Object
						ϒmobj                  λ.Object
						ϒname                  λ.Object
						ϒrelease_date          λ.Object
						ϒretry_url             λ.Object
						ϒself                  = λargs[0]
						ϒstat                  λ.Object
						ϒstat_url              λ.Object
						ϒthumbnail             λ.Object
						ϒtimestamp             λ.Object
						ϒtitle                 λ.Object
						ϒtrack                 λ.Object
						ϒtrack_id              λ.Object
						ϒtrack_info            λ.Object
						ϒtrack_number          λ.Object
						ϒurl                   = λargs[1]
						ϒwebpage               λ.Object
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
					)
					ϒmobj = λ.Cal(Ωre.ϒmatch, λ.GetAttr(ϒself, "_VALID_URL", nil), ϒurl)
					ϒtitle = λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("title"))
					ϒwebpage = λ.Cal(λ.GetAttr(ϒself, "_download_webpage", nil), ϒurl, ϒtitle)
					ϒthumbnail = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
						λ.NewStr("og:image"),
						ϒwebpage,
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒtrack_id = λ.None
					ϒtrack = λ.None
					ϒtrack_number = λ.None
					ϒduration = λ.None
					ϒformats = λ.NewList()
					ϒtrack_info = λ.Cal(λ.GetAttr(ϒself, "_parse_json", nil), λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewStr("trackinfo\\s*:\\s*\\[\\s*({.+?})\\s*\\]\\s*,\\s*?\\n"),
						ϒwebpage,
						λ.NewStr("track info"),
					), λ.KWArgs{
						{Name: "default", Value: λ.NewStr("{}")},
					}), ϒtitle)
					if λ.IsTrue(ϒtrack_info) {
						ϒfile_ = λ.Cal(λ.GetAttr(ϒtrack_info, "get", nil), λ.NewStr("file"))
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒfile_, λ.DictType)) {
							τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒfile_, "items", nil)))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								τmp2 = τmp1
								ϒformat_id = λ.GetItem(τmp2, λ.NewInt(0))
								ϒformat_url = λ.GetItem(τmp2, λ.NewInt(1))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(ϒurl_or_none, ϒformat_url)))) {
									continue
								}
								τmp2 = λ.Cal(λ.GetAttr(ϒformat_id, "split", nil), λ.NewStr("-"), λ.NewInt(1))
								ϒext = λ.GetItem(τmp2, λ.NewInt(0))
								ϒabr_str = λ.GetItem(τmp2, λ.NewInt(1))
								λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("format_id"): ϒformat_id,
									λ.NewStr("url"):       λ.Cal(λ.GetAttr(ϒself, "_proto_relative_url", nil), ϒformat_url, λ.NewStr("http:")),
									λ.NewStr("ext"):       ϒext,
									λ.NewStr("vcodec"):    λ.NewStr("none"),
									λ.NewStr("acodec"):    ϒext,
									λ.NewStr("abr"):       λ.Cal(ϒint_or_none, ϒabr_str),
								}))
							}
						}
						ϒtrack = λ.Cal(λ.GetAttr(ϒtrack_info, "get", nil), λ.NewStr("title"))
						ϒtrack_id = λ.Cal(ϒstr_or_none, func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒtrack_info, "get", nil), λ.NewStr("track_id")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒtrack_info, "get", nil), λ.NewStr("id"))
							}
						}())
						ϒtrack_number = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒtrack_info, "get", nil), λ.NewStr("track_num")))
						ϒduration = λ.Cal(ϒfloat_or_none, λ.Cal(λ.GetAttr(ϒtrack_info, "get", nil), λ.NewStr("duration")))
					}
					ϒextract = λ.NewFunction("extract",
						[]λ.Param{
							{Name: "key"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒkey = λargs[0]
							)
							return λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.Mod(λ.NewStr("\\b%s\\s*[\"\\']?\\s*:\\s*([\"\\'])(?P<value>(?:(?!\\1).)+)\\1"), ϒkey),
								ϒwebpage,
								ϒkey,
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
								{Name: "group", Value: λ.NewStr("value")},
							})
						})
					ϒartist = λ.Cal(ϒextract, λ.NewStr("artist"))
					ϒalbum = λ.Cal(ϒextract, λ.NewStr("album_title"))
					ϒtimestamp = λ.Cal(ϒunified_timestamp, func() λ.Object {
						if λv := λ.Cal(ϒextract, λ.NewStr("publish_date")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒextract, λ.NewStr("album_publish_date"))
						}
					}())
					ϒrelease_date = λ.Cal(ϒunified_strdate, λ.Cal(ϒextract, λ.NewStr("album_release_date")))
					ϒdownload_link = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewStr("freeDownloadPage\\s*:\\s*([\"\\'])(?P<url>(?:(?!\\1).)+)\\1"),
						ϒwebpage,
						λ.NewStr("download link"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
						{Name: "group", Value: λ.NewStr("url")},
					})
					if λ.IsTrue(ϒdownload_link) {
						ϒtrack_id = λ.Cal(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewStr("(?ms)var TralbumData = .*?[{,]\\s*id: (?P<id>\\d+),?$"), ϒwebpage, λ.NewStr("track id"))
						ϒdownload_webpage = λ.Cal(λ.GetAttr(ϒself, "_download_webpage", nil), ϒdownload_link, ϒtrack_id, λ.NewStr("Downloading free downloads page"))
						ϒblob = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.NewStr("data-blob=([\"\\'])(?P<blob>{.+?})\\1"),
								ϒdownload_webpage,
								λ.NewStr("blob"),
							), λ.KWArgs{
								{Name: "group", Value: λ.NewStr("blob")},
							}),
							ϒtrack_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒunescapeHTML},
						})
						ϒinfo = λ.Cal(ϒtry_get, ϒblob, λ.NewTuple(
							λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("digital_items")), λ.NewInt(0))
								}),
							λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.NewStr("download_items")), λ.NewInt(0))
								}),
						), λ.DictType)
						if λ.IsTrue(ϒinfo) {
							ϒdownloads = λ.Cal(λ.GetAttr(ϒinfo, "get", nil), λ.NewStr("downloads"))
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒdownloads, λ.DictType)) {
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒtrack))) {
									ϒtrack = λ.Cal(λ.GetAttr(ϒinfo, "get", nil), λ.NewStr("title"))
								}
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒartist))) {
									ϒartist = λ.Cal(λ.GetAttr(ϒinfo, "get", nil), λ.NewStr("artist"))
								}
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒthumbnail))) {
									ϒthumbnail = λ.Cal(λ.GetAttr(ϒinfo, "get", nil), λ.NewStr("thumb_url"))
								}
								ϒdownload_formats = λ.NewDictWithTable(map[λ.Object]λ.Object{})
								ϒdownload_formats_list = λ.Cal(λ.GetAttr(ϒblob, "get", nil), λ.NewStr("download_formats"))
								if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒdownload_formats_list, λ.ListType)) {
									τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒblob, λ.NewStr("download_formats")))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒf = τmp1
										τmp2 = λ.NewTuple(
											λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("name")),
											λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("file_extension")),
										)
										ϒname = λ.GetItem(τmp2, λ.NewInt(0))
										ϒext = λ.GetItem(τmp2, λ.NewInt(1))
										if λ.IsTrue(λ.Cal(λ.BuiltinAll, λ.Cal(λ.NewFunction("<generator>",
											nil,
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
													var (
														ϒx   λ.Object
														τmp0 λ.Object
														τmp1 λ.Object
													)
													τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
														ϒname,
														ϒext,
													))
													for {
														if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
															break
														}
														ϒx = τmp1
														λgy.Yield(λ.Cal(λ.BuiltinIsInstance, ϒx, ϒcompat_str))
													}
													return λ.None
												})
											})))) {
											λ.SetItem(ϒdownload_formats, ϒname, λ.Cal(λ.GetAttr(ϒext, "strip", nil), λ.NewStr(".")))
										}
									}
								}
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒdownloads, "items", nil)))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒformat_id = λ.GetItem(τmp2, λ.NewInt(0))
									ϒf = λ.GetItem(τmp2, λ.NewInt(1))
									ϒformat_url = λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("url"))
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒformat_url))) {
										continue
									}
									ϒstat_url = λ.Cal(ϒupdate_url_query, λ.Cal(λ.GetAttr(ϒformat_url, "replace", nil), λ.NewStr("/download/"), λ.NewStr("/statdownload/")), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr(".rand"): λ.Cal(λ.IntType, λ.Mul(λ.Mul(λ.Cal(Ωtime.ϒtime), λ.NewInt(1000)), λ.Cal(λ.None))),
									}))
									ϒformat_id = func() λ.Object {
										if λv := λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("encoding_name")); λ.IsTrue(λv) {
											return λv
										} else {
											return ϒformat_id
										}
									}()
									ϒstat = λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
										ϒstat_url,
										ϒtrack_id,
										λ.Mod(λ.NewStr("Downloading %s JSON"), ϒformat_id),
									), λ.KWArgs{
										{Name: "transform_source", Value: λ.NewFunction("<lambda>",
											[]λ.Param{
												{Name: "s"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒs = λargs[0]
												)
												return λ.GetItem(ϒs, λ.NewSlice(λ.Cal(λ.GetAttr(ϒs, "index", nil), λ.NewStr("{")), λ.Add(λ.Cal(λ.GetAttr(ϒs, "rindex", nil), λ.NewStr("}")), λ.NewInt(1)), λ.None))
											})},
										{Name: "fatal", Value: λ.False},
									})
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒstat))) {
										continue
									}
									ϒretry_url = λ.Cal(ϒurl_or_none, λ.Cal(λ.GetAttr(ϒstat, "get", nil), λ.NewStr("retry_url")))
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒretry_url))) {
										continue
									}
									λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("url"):         λ.Cal(λ.GetAttr(ϒself, "_proto_relative_url", nil), ϒretry_url, λ.NewStr("http:")),
										λ.NewStr("ext"):         λ.Cal(λ.GetAttr(ϒdownload_formats, "get", nil), ϒformat_id),
										λ.NewStr("format_id"):   ϒformat_id,
										λ.NewStr("format_note"): λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("description")),
										λ.NewStr("filesize"):    λ.Cal(ϒparse_filesize, λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("size_mb"))),
										λ.NewStr("vcodec"):      λ.NewStr("none"),
									}))
								}
							}
						}
					}
					λ.Cal(λ.GetAttr(ϒself, "_sort_formats", nil), ϒformats)
					ϒtitle = func() λ.Object {
						if λ.IsTrue(ϒartist) {
							return λ.Mod(λ.NewStr("%s - %s"), λ.NewTuple(
								ϒartist,
								ϒtrack,
							))
						} else {
							return ϒtrack
						}
					}()
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒduration))) {
						ϒduration = λ.Cal(ϒfloat_or_none, λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
							λ.NewStr("duration"),
							ϒwebpage,
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}))
					}
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):           ϒtrack_id,
						λ.NewStr("title"):        ϒtitle,
						λ.NewStr("thumbnail"):    ϒthumbnail,
						λ.NewStr("uploader"):     ϒartist,
						λ.NewStr("timestamp"):    ϒtimestamp,
						λ.NewStr("release_date"): ϒrelease_date,
						λ.NewStr("duration"):     ϒduration,
						λ.NewStr("track"):        ϒtrack,
						λ.NewStr("track_number"): ϒtrack_number,
						λ.NewStr("track_id"):     ϒtrack_id,
						λ.NewStr("artist"):       ϒartist,
						λ.NewStr("album"):        ϒalbum,
						λ.NewStr("formats"):      ϒformats,
					})
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_TESTS"):        BandcampIE__TESTS,
				λ.NewStr("_VALID_URL"):    BandcampIE__VALID_URL,
				λ.NewStr("_real_extract"): BandcampIE__real_extract,
			})
		}())
		BandcampAlbumIE = λ.Cal(λ.TypeType, λ.NewStr("BandcampAlbumIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BandcampAlbumIE__VALID_URL λ.Object
				BandcampAlbumIE_suitable   λ.Object
			)
			BandcampAlbumIE__VALID_URL = λ.NewStr("https?://(?:(?P<subdomain>[^.]+)\\.)?bandcamp\\.com(?:/album/(?P<album_id>[^/?#&]+))?")
			BandcampAlbumIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(BandcampWeeklyIE, "suitable", nil), ϒurl); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(BandcampIE, "suitable", nil), ϒurl)
							}
						}()) {
							return λ.False
						} else {
							return λ.Cal(λ.GetAttr(λ.Cal(λ.SuperType, BandcampAlbumIE, ϒcls), "suitable", nil), ϒurl)
						}
					}()
				})
			BandcampAlbumIE_suitable = λ.Cal(λ.ClassMethodType, BandcampAlbumIE_suitable)
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_VALID_URL"): BandcampAlbumIE__VALID_URL,
				λ.NewStr("suitable"):   BandcampAlbumIE_suitable,
			})
		}())
		BandcampWeeklyIE = λ.Cal(λ.TypeType, λ.NewStr("BandcampWeeklyIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BandcampWeeklyIE_IE_NAME       λ.Object
				BandcampWeeklyIE__TESTS        λ.Object
				BandcampWeeklyIE__VALID_URL    λ.Object
				BandcampWeeklyIE__real_extract λ.Object
			)
			BandcampWeeklyIE_IE_NAME = λ.NewStr("Bandcamp:weekly")
			BandcampWeeklyIE__VALID_URL = λ.NewStr("https?://(?:www\\.)?bandcamp\\.com/?\\?(?:.*?&)?show=(?P<id>\\d+)")
			BandcampWeeklyIE__TESTS = λ.NewList(
				λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("url"): λ.NewStr("https://bandcamp.com/?show=224"),
					λ.NewStr("md5"): λ.NewStr("b00df799c733cf7e0c567ed187dea0fd"),
					λ.NewStr("info_dict"): λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):             λ.NewStr("224"),
						λ.NewStr("ext"):            λ.NewStr("opus"),
						λ.NewStr("title"):          λ.NewStr("BC Weekly April 4th 2017 - Magic Moments"),
						λ.NewStr("description"):    λ.NewStr("md5:5d48150916e8e02d030623a48512c874"),
						λ.NewStr("duration"):       λ.NewFloat(5829.77),
						λ.NewStr("release_date"):   λ.NewStr("20170404"),
						λ.NewStr("series"):         λ.NewStr("Bandcamp Weekly"),
						λ.NewStr("episode"):        λ.NewStr("Magic Moments"),
						λ.NewStr("episode_number"): λ.NewInt(208),
						λ.NewStr("episode_id"):     λ.NewStr("224"),
					}),
				}),
				λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("url"):           λ.NewStr("https://bandcamp.com/?blah/blah@&show=228"),
					λ.NewStr("only_matching"): λ.True,
				}),
			)
			BandcampWeeklyIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒblob           λ.Object
						ϒepisode_number λ.Object
						ϒext            λ.Object
						ϒformat_id      λ.Object
						ϒformat_url     λ.Object
						ϒformats        λ.Object
						ϒknown_ext      λ.Object
						ϒself           = λargs[0]
						ϒseq            λ.Object
						ϒshow           λ.Object
						ϒshow_id        λ.Object
						ϒsubtitle       λ.Object
						ϒtitle          λ.Object
						ϒurl            = λargs[1]
						ϒvideo_id       λ.Object
						ϒwebpage        λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
						τmp3            λ.Object
					)
					_ = τmp0
					_ = τmp1
					ϒvideo_id = λ.Cal(λ.GetAttr(ϒself, "_match_id", nil), ϒurl)
					ϒwebpage = λ.Cal(λ.GetAttr(ϒself, "_download_webpage", nil), ϒurl, ϒvideo_id)
					ϒblob = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
						λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.NewStr("data-blob=([\"\\'])(?P<blob>{.+?})\\1"),
							ϒwebpage,
							λ.NewStr("blob"),
						), λ.KWArgs{
							{Name: "group", Value: λ.NewStr("blob")},
						}),
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "transform_source", Value: ϒunescapeHTML},
					})
					ϒshow = λ.GetItem(ϒblob, λ.NewStr("bcw_show"))
					ϒshow_id = func() λ.Object {
						if λv := λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("show_id"))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒint_or_none, ϒvideo_id)
						}
					}()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(λ.GetItem(ϒshow, λ.NewStr("audio_stream")), "items", nil)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒformat_id = λ.GetItem(τmp2, λ.NewInt(0))
						ϒformat_url = λ.GetItem(τmp2, λ.NewInt(1))
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(ϒurl_or_none, ϒformat_url)))) {
							continue
						}
						τmp2 = λ.Cal(λ.BuiltinIter, KNOWN_EXTENSIONS)
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒknown_ext = τmp3
							if λ.IsTrue(λ.NewBool(λ.Contains(ϒformat_id, ϒknown_ext))) {
								ϒext = ϒknown_ext
								break
							}
						}
						if τmp3 == λ.AfterLast {
							ϒext = λ.None
						}
						λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("format_id"): ϒformat_id,
							λ.NewStr("url"):       ϒformat_url,
							λ.NewStr("ext"):       ϒext,
							λ.NewStr("vcodec"):    λ.NewStr("none"),
						}))
					}
					λ.Cal(λ.GetAttr(ϒself, "_sort_formats", nil), ϒformats)
					ϒtitle = func() λ.Object {
						if λv := λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("audio_title")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewStr("Bandcamp Weekly")
						}
					}()
					ϒsubtitle = λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("subtitle"))
					if λ.IsTrue(ϒsubtitle) {
						τmp0 = λ.IAdd(ϒtitle, λ.Mod(λ.NewStr(" - %s"), ϒsubtitle))
						ϒtitle = τmp0
					}
					ϒepisode_number = λ.None
					ϒseq = λ.Cal(λ.GetAttr(ϒblob, "get", nil), λ.NewStr("bcw_seq"))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒseq; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.BuiltinIsInstance, ϒseq, λ.ListType)
						}
					}()) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.StopIterationType, func(λex λ.BaseException) {
									// pass
								}},
							)
							ϒepisode_number = λ.Cal(λ.BuiltinNext, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
										var (
											ϒe   λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, ϒseq)
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒe = τmp1
											if λ.IsTrue(func() λ.Object {
												if λv := λ.Cal(λ.BuiltinIsInstance, ϒe, λ.DictType); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Eq(λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("id"))), ϒshow_id)
												}
											}()) {
												λgy.Yield(λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("episode_number"))))
											}
										}
										return λ.None
									})
								})))
							return λ.BlockExitNormally, nil
						}()
					}
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):    ϒvideo_id,
						λ.NewStr("title"): ϒtitle,
						λ.NewStr("description"): func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("desc")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("short_desc"))
							}
						}(),
						λ.NewStr("duration"):       λ.Cal(ϒfloat_or_none, λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("audio_duration"))),
						λ.NewStr("is_live"):        λ.False,
						λ.NewStr("release_date"):   λ.Cal(ϒunified_strdate, λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("published_date"))),
						λ.NewStr("series"):         λ.NewStr("Bandcamp Weekly"),
						λ.NewStr("episode"):        λ.Cal(λ.GetAttr(ϒshow, "get", nil), λ.NewStr("subtitle")),
						λ.NewStr("episode_number"): ϒepisode_number,
						λ.NewStr("episode_id"):     λ.Cal(ϒcompat_str, ϒvideo_id),
						λ.NewStr("formats"):        ϒformats,
					})
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("IE_NAME"):       BandcampWeeklyIE_IE_NAME,
				λ.NewStr("_TESTS"):        BandcampWeeklyIE__TESTS,
				λ.NewStr("_VALID_URL"):    BandcampWeeklyIE__VALID_URL,
				λ.NewStr("_real_extract"): BandcampWeeklyIE__real_extract,
			})
		}())
	})
}

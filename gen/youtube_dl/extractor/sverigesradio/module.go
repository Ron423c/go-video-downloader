// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * sverigesradio/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/sverigesradio.py
 */

package sverigesradio

import (
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	InfoExtractor              λ.Object
	SverigesRadioBaseIE        λ.Object
	SverigesRadioEpisodeIE     λ.Object
	SverigesRadioPublicationIE λ.Object
	ϒdetermine_ext             λ.Object
	ϒint_or_none               λ.Object
	ϒstr_or_none               λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒstr_or_none = Ωutils.ϒstr_or_none
		SverigesRadioBaseIE = λ.Cal(λ.TypeType, λ.NewStr("SverigesRadioBaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				SverigesRadioBaseIE__BASE_URL                 λ.Object
				SverigesRadioBaseIE__CODING_FORMAT_TO_ABR_MAP λ.Object
				SverigesRadioBaseIE__EXT_TO_CODEC_MAP         λ.Object
				SverigesRadioBaseIE__QUALITIES                λ.Object
				SverigesRadioBaseIE__real_extract             λ.Object
			)
			SverigesRadioBaseIE__BASE_URL = λ.NewStr("https://sverigesradio.se/sida/playerajax/")
			SverigesRadioBaseIE__QUALITIES = λ.NewList(
				λ.NewStr("low"),
				λ.NewStr("medium"),
				λ.NewStr("high"),
			)
			SverigesRadioBaseIE__EXT_TO_CODEC_MAP = λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("mp3"): λ.NewStr("mp3"),
				λ.NewStr("m4a"): λ.NewStr("aac"),
			})
			SverigesRadioBaseIE__CODING_FORMAT_TO_ABR_MAP = λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewInt(5):  λ.NewInt(128),
				λ.NewInt(11): λ.NewInt(192),
				λ.NewInt(12): λ.NewInt(32),
				λ.NewInt(13): λ.NewInt(96),
			})
			SverigesRadioBaseIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabr            λ.Object
						ϒaudio_id       λ.Object
						ϒaudio_url      λ.Object
						ϒaudio_url_data λ.Object
						ϒcoding_format  λ.Object
						ϒext            λ.Object
						ϒformats        λ.Object
						ϒitem           λ.Object
						ϒquality        λ.Object
						ϒquery          λ.Object
						ϒself           = λargs[0]
						ϒtitle          λ.Object
						ϒurl            = λargs[1]
						ϒurls           λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
					)
					ϒaudio_id = λ.Cal(λ.GetAttr(ϒself, "_match_id", nil), ϒurl)
					ϒquery = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):   ϒaudio_id,
						λ.NewStr("type"): λ.GetAttr(ϒself, "_AUDIO_TYPE", nil),
					})
					ϒitem = λ.GetItem(λ.GetItem(λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
						λ.Add(λ.GetAttr(ϒself, "_BASE_URL", nil), λ.NewStr("audiometadata")),
						ϒaudio_id,
						λ.NewStr("Downloading audio JSON metadata"),
					), λ.KWArgs{
						{Name: "query", Value: ϒquery},
					}), λ.NewStr("items")), λ.NewInt(0))
					ϒtitle = λ.GetItem(ϒitem, λ.NewStr("subtitle"))
					λ.SetItem(ϒquery, λ.NewStr("format"), λ.NewStr("iis"))
					ϒurls = λ.NewList()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_QUALITIES", nil))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒquality = τmp1
						λ.SetItem(ϒquery, λ.NewStr("quality"), ϒquality)
						ϒaudio_url_data = func() λ.Object {
							if λv := λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
								λ.Add(λ.GetAttr(ϒself, "_BASE_URL", nil), λ.NewStr("getaudiourl")),
								ϒaudio_id,
								λ.Mod(λ.NewStr("Downloading %s format JSON metadata"), ϒquality),
							), λ.KWArgs{
								{Name: "fatal", Value: λ.False},
								{Name: "query", Value: ϒquery},
							}); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewDictWithTable(map[λ.Object]λ.Object{})
							}
						}()
						ϒaudio_url = λ.Cal(λ.GetAttr(ϒaudio_url_data, "get", nil), λ.NewStr("audioUrl"))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒaudio_url)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒurls, ϒaudio_url))
							}
						}()) {
							continue
						}
						λ.Cal(λ.GetAttr(ϒurls, "append", nil), ϒaudio_url)
						ϒext = λ.Cal(ϒdetermine_ext, ϒaudio_url)
						ϒcoding_format = λ.Cal(λ.GetAttr(ϒaudio_url_data, "get", nil), λ.NewStr("codingFormat"))
						ϒabr = func() λ.Object {
							if λv := λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.NewStr("_a(\\d+)\\.m4a"),
								ϒaudio_url,
								λ.NewStr("audio bitrate"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							})); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_CODING_FORMAT_TO_ABR_MAP", nil), "get", nil), ϒcoding_format)
							}
						}()
						λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("abr"):       ϒabr,
							λ.NewStr("acodec"):    λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_EXT_TO_CODEC_MAP", nil), "get", nil), ϒext),
							λ.NewStr("ext"):       ϒext,
							λ.NewStr("format_id"): λ.Cal(ϒstr_or_none, ϒcoding_format),
							λ.NewStr("vcodec"):    λ.NewStr("none"),
							λ.NewStr("url"):       ϒaudio_url,
						}))
					}
					λ.Cal(λ.GetAttr(ϒself, "_sort_formats", nil), ϒformats)
					return λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("id"):          ϒaudio_id,
						λ.NewStr("title"):       ϒtitle,
						λ.NewStr("formats"):     ϒformats,
						λ.NewStr("series"):      λ.Cal(λ.GetAttr(ϒitem, "get", nil), λ.NewStr("title")),
						λ.NewStr("duration"):    λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒitem, "get", nil), λ.NewStr("duration"))),
						λ.NewStr("thumbnail"):   λ.Cal(λ.GetAttr(ϒitem, "get", nil), λ.NewStr("displayimageurl")),
						λ.NewStr("description"): λ.Cal(λ.GetAttr(ϒitem, "get", nil), λ.NewStr("description")),
					})
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_BASE_URL"):                 SverigesRadioBaseIE__BASE_URL,
				λ.NewStr("_CODING_FORMAT_TO_ABR_MAP"): SverigesRadioBaseIE__CODING_FORMAT_TO_ABR_MAP,
				λ.NewStr("_EXT_TO_CODEC_MAP"):         SverigesRadioBaseIE__EXT_TO_CODEC_MAP,
				λ.NewStr("_QUALITIES"):                SverigesRadioBaseIE__QUALITIES,
				λ.NewStr("_real_extract"):             SverigesRadioBaseIE__real_extract,
			})
		}())
		SverigesRadioPublicationIE = λ.Cal(λ.TypeType, λ.NewStr("SverigesRadioPublicationIE"), λ.NewTuple(SverigesRadioBaseIE), func() λ.Dict {
			var (
				SverigesRadioPublicationIE_IE_NAME     λ.Object
				SverigesRadioPublicationIE__AUDIO_TYPE λ.Object
				SverigesRadioPublicationIE__VALID_URL  λ.Object
			)
			SverigesRadioPublicationIE_IE_NAME = λ.NewStr("sverigesradio:publication")
			SverigesRadioPublicationIE__VALID_URL = λ.NewStr("https?://(?:www\\.)?sverigesradio\\.se/sida/(?:artikel|gruppsida)\\.aspx\\?.*?\\bartikel=(?P<id>[0-9]+)")
			SverigesRadioPublicationIE__AUDIO_TYPE = λ.NewStr("publication")
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("IE_NAME"):     SverigesRadioPublicationIE_IE_NAME,
				λ.NewStr("_AUDIO_TYPE"): SverigesRadioPublicationIE__AUDIO_TYPE,
				λ.NewStr("_VALID_URL"):  SverigesRadioPublicationIE__VALID_URL,
			})
		}())
		SverigesRadioEpisodeIE = λ.Cal(λ.TypeType, λ.NewStr("SverigesRadioEpisodeIE"), λ.NewTuple(SverigesRadioBaseIE), func() λ.Dict {
			var (
				SverigesRadioEpisodeIE_IE_NAME     λ.Object
				SverigesRadioEpisodeIE__AUDIO_TYPE λ.Object
				SverigesRadioEpisodeIE__VALID_URL  λ.Object
			)
			SverigesRadioEpisodeIE_IE_NAME = λ.NewStr("sverigesradio:episode")
			SverigesRadioEpisodeIE__VALID_URL = λ.NewStr("https?://(?:www\\.)?sverigesradio\\.se/(?:sida/)?avsnitt/(?P<id>[0-9]+)")
			SverigesRadioEpisodeIE__AUDIO_TYPE = λ.NewStr("episode")
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("IE_NAME"):     SverigesRadioEpisodeIE_IE_NAME,
				λ.NewStr("_AUDIO_TYPE"): SverigesRadioEpisodeIE__AUDIO_TYPE,
				λ.NewStr("_VALID_URL"):  SverigesRadioEpisodeIE__VALID_URL,
			})
		}())
	})
}

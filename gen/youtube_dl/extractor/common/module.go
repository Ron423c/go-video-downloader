// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2018 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * common/module.go: transpiled from https://github.com/rg3/youtube-dl/blob/master/youtube_dl/extractor/common.py
 */

package common

import (
	Ωcookiejar "github.com/tenta-browser/go-video-downloader/gen/http/cookiejar"
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωrandom "github.com/tenta-browser/go-video-downloader/gen/random"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωsocket "github.com/tenta-browser/go-video-downloader/gen/socket"
	Ωsys "github.com/tenta-browser/go-video-downloader/gen/sys"
	Ωerror "github.com/tenta-browser/go-video-downloader/gen/urllib/error"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωrequest "github.com/tenta-browser/go-video-downloader/gen/urllib/request"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωf4m "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/downloader/f4m"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError                 λ.Object
	GeoRestrictedError             λ.Object
	GeoUtils                       λ.Object
	InfoExtractor                  λ.Object
	JSON_LD_RE                     λ.Object
	NO_DEFAULT                     λ.Object
	RegexNotFoundError             λ.Object
	SearchInfoExtractor            λ.Object
	ϒbase_url                      λ.Object
	ϒbug_reports_message           λ.Object
	ϒclean_html                    λ.Object
	ϒcompat_etree_fromstring       λ.Object
	ϒcompat_http_client            λ.Object
	ϒcompat_str                    λ.Object
	ϒcompat_urllib_parse_unquote   λ.Object
	ϒcompat_urllib_parse_urlencode λ.Object
	ϒcompat_xml_parse_error        λ.Object
	ϒcompiled_regex_type           λ.Object
	ϒdetermine_ext                 λ.Object
	ϒdetermine_protocol            λ.Object
	ϒerror_to_compat_str           λ.Object
	ϒextract_attributes            λ.Object
	ϒfix_xml_ampersands            λ.Object
	ϒfloat_or_none                 λ.Object
	ϒget_base_url                  λ.Object
	ϒint_or_none                   λ.Object
	ϒjs_to_json                    λ.Object
	ϒmimetype2ext                  λ.Object
	ϒorderedSet                    λ.Object
	ϒparse_codecs                  λ.Object
	ϒparse_duration                λ.Object
	ϒparse_iso8601                 λ.Object
	ϒparse_m3u8_attributes         λ.Object
	ϒremove_encrypted_media        λ.Object
	ϒsanitize_filename             λ.Object
	ϒsanitized_Request             λ.Object
	ϒunescapeHTML                  λ.Object
	ϒunified_strdate               λ.Object
	ϒunified_timestamp             λ.Object
	ϒupdate_Request                λ.Object
	ϒupdate_url_query              λ.Object
	ϒurl_basename                  λ.Object
	ϒurl_or_none                   λ.Object
	ϒurljoin                       λ.Object
	ϒxpath_element                 λ.Object
	ϒxpath_text                    λ.Object
)

func init() {
	λ.InitModule(func() {
		ϒcompat_etree_fromstring = Ωcompat.ϒcompat_etree_fromstring
		ϒcompat_http_client = Ωcompat.ϒcompat_http_client
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒcompat_urllib_parse_unquote = Ωcompat.ϒcompat_urllib_parse_unquote
		ϒcompat_urllib_parse_urlencode = Ωcompat.ϒcompat_urllib_parse_urlencode
		ϒcompat_xml_parse_error = Ωcompat.ϒcompat_xml_parse_error
		ϒget_base_url = Ωf4m.ϒget_base_url
		ϒremove_encrypted_media = Ωf4m.ϒremove_encrypted_media
		NO_DEFAULT = Ωutils.NO_DEFAULT
		ϒbase_url = Ωutils.ϒbase_url
		ϒbug_reports_message = Ωutils.ϒbug_reports_message
		ϒclean_html = Ωutils.ϒclean_html
		ϒcompiled_regex_type = Ωutils.ϒcompiled_regex_type
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ϒdetermine_protocol = Ωutils.ϒdetermine_protocol
		ϒerror_to_compat_str = Ωutils.ϒerror_to_compat_str
		ExtractorError = Ωutils.ExtractorError
		ϒextract_attributes = Ωutils.ϒextract_attributes
		ϒfix_xml_ampersands = Ωutils.ϒfix_xml_ampersands
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		GeoRestrictedError = Ωutils.GeoRestrictedError
		GeoUtils = Ωutils.GeoUtils
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒjs_to_json = Ωutils.ϒjs_to_json
		JSON_LD_RE = Ωutils.JSON_LD_RE
		ϒmimetype2ext = Ωutils.ϒmimetype2ext
		ϒorderedSet = Ωutils.ϒorderedSet
		ϒparse_codecs = Ωutils.ϒparse_codecs
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒparse_iso8601 = Ωutils.ϒparse_iso8601
		ϒparse_m3u8_attributes = Ωutils.ϒparse_m3u8_attributes
		RegexNotFoundError = Ωutils.RegexNotFoundError
		ϒsanitized_Request = Ωutils.ϒsanitized_Request
		ϒsanitize_filename = Ωutils.ϒsanitize_filename
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		ϒupdate_Request = Ωutils.ϒupdate_Request
		ϒupdate_url_query = Ωutils.ϒupdate_url_query
		ϒurljoin = Ωutils.ϒurljoin
		ϒurl_basename = Ωutils.ϒurl_basename
		ϒurl_or_none = Ωutils.ϒurl_or_none
		ϒxpath_element = Ωutils.ϒxpath_element
		ϒxpath_text = Ωutils.ϒxpath_text
		InfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("InfoExtractor"), λ.NewTuple(λ.ObjectType), func() λ.Dict {
			var (
				InfoExtractor_IE_NAME                      λ.Object
				InfoExtractor__GEO_BYPASS                  λ.Object
				InfoExtractor__GEO_COUNTRIES               λ.Object
				InfoExtractor__GEO_IP_BLOCKS               λ.Object
				InfoExtractor__WORKING                     λ.Object
				InfoExtractor___can_accept_status_code     λ.Object
				InfoExtractor___check_blocked              λ.Object
				InfoExtractor___init__                     λ.Object
				InfoExtractor__check_formats               λ.Object
				InfoExtractor__download_json               λ.Object
				InfoExtractor__download_json_handle        λ.Object
				InfoExtractor__download_smil               λ.Object
				InfoExtractor__download_webpage            λ.Object
				InfoExtractor__download_webpage_handle     λ.Object
				InfoExtractor__download_xml                λ.Object
				InfoExtractor__download_xml_handle         λ.Object
				InfoExtractor__downloader                  λ.Object
				InfoExtractor__extract_f4m_formats         λ.Object
				InfoExtractor__extract_ism_formats         λ.Object
				InfoExtractor__extract_m3u8_formats        λ.Object
				InfoExtractor__extract_mpd_formats         λ.Object
				InfoExtractor__extract_smil_formats        λ.Object
				InfoExtractor__family_friendly_search      λ.Object
				InfoExtractor__float                       λ.Object
				InfoExtractor__get_login_info              λ.Object
				InfoExtractor__get_netrc_login_info        λ.Object
				InfoExtractor__guess_encoding_from_content λ.Object
				InfoExtractor__hidden_inputs               λ.Object
				InfoExtractor__html_search_meta            λ.Object
				InfoExtractor__html_search_regex           λ.Object
				InfoExtractor__initialize_geo_bypass       λ.Object
				InfoExtractor__int                         λ.Object
				InfoExtractor__is_valid_url                λ.Object
				InfoExtractor__json_ld                     λ.Object
				InfoExtractor__live_title                  λ.Object
				InfoExtractor__match_id                    λ.Object
				InfoExtractor__media_rating_search         λ.Object
				InfoExtractor__meta_regex                  λ.Object
				InfoExtractor__og_regexes                  λ.Object
				InfoExtractor__og_search_description       λ.Object
				InfoExtractor__og_search_property          λ.Object
				InfoExtractor__og_search_thumbnail         λ.Object
				InfoExtractor__og_search_title             λ.Object
				InfoExtractor__og_search_url               λ.Object
				InfoExtractor__og_search_video_url         λ.Object
				InfoExtractor__parse_f4m_formats           λ.Object
				InfoExtractor__parse_html5_media_entries   λ.Object
				InfoExtractor__parse_ism_formats           λ.Object
				InfoExtractor__parse_json                  λ.Object
				InfoExtractor__parse_jwplayer_data         λ.Object
				InfoExtractor__parse_jwplayer_formats      λ.Object
				InfoExtractor__parse_m3u8_formats          λ.Object
				InfoExtractor__parse_mpd_formats           λ.Object
				InfoExtractor__parse_smil_formats          λ.Object
				InfoExtractor__parse_smil_namespace        λ.Object
				InfoExtractor__parse_xml                   λ.Object
				InfoExtractor__proto_relative_url          λ.Object
				InfoExtractor__ready                       λ.Object
				InfoExtractor__real_initialize             λ.Object
				InfoExtractor__remove_duplicate_formats    λ.Object
				InfoExtractor__request_webpage             λ.Object
				InfoExtractor__rta_search                  λ.Object
				InfoExtractor__search_json_ld              λ.Object
				InfoExtractor__search_regex                λ.Object
				InfoExtractor__set_cookie                  λ.Object
				InfoExtractor__sort_formats                λ.Object
				InfoExtractor__webpage_read_content        λ.Object
				InfoExtractor__x_forwarded_for_ip          λ.Object
				InfoExtractor__xpath_ns                    λ.Object
				InfoExtractor_extract                      λ.Object
				InfoExtractor_geo_verification_headers     λ.Object
				InfoExtractor_http_scheme                  λ.Object
				InfoExtractor_ie_key                       λ.Object
				InfoExtractor_initialize                   λ.Object
				InfoExtractor_playlist_result              λ.Object
				InfoExtractor_report_download_webpage      λ.Object
				InfoExtractor_report_extraction            λ.Object
				InfoExtractor_report_warning               λ.Object
				InfoExtractor_set_downloader               λ.Object
				InfoExtractor_suitable                     λ.Object
				InfoExtractor_to_screen                    λ.Object
				InfoExtractor_url_result                   λ.Object
				InfoExtractor_working                      λ.Object
			)
			λ.NewStr("Information Extractor class.\n\n    Information extractors are the classes that, given a URL, extract\n    information about the video (or videos) the URL refers to. This\n    information includes the real video URL, the video title, author and\n    others. The information is stored in a dictionary which is then\n    passed to the YoutubeDL. The YoutubeDL processes this\n    information possibly downloading the video to the file system, among\n    other possible outcomes.\n\n    The type field determines the type of the result.\n    By far the most common value (and the default if _type is missing) is\n    \"video\", which indicates a single video.\n\n    For a video, the dictionaries must include the following fields:\n\n    id:             Video identifier.\n    title:          Video title, unescaped.\n\n    Additionally, it must contain either a formats entry or a url one:\n\n    formats:        A list of dictionaries for each format available, ordered\n                    from worst to best quality.\n\n                    Potential fields:\n                    * url        Mandatory. The URL of the video file\n                    * manifest_url\n                                 The URL of the manifest file in case of\n                                 fragmented media (DASH, hls, hds)\n                    * ext        Will be calculated from URL if missing\n                    * format     A human-readable description of the format\n                                 (\"mp4 container with h264/opus\").\n                                 Calculated from the format_id, width, height.\n                                 and format_note fields if missing.\n                    * format_id  A short description of the format\n                                 (\"mp4_h264_opus\" or \"19\").\n                                Technically optional, but strongly recommended.\n                    * format_note Additional info about the format\n                                 (\"3D\" or \"DASH video\")\n                    * width      Width of the video, if known\n                    * height     Height of the video, if known\n                    * resolution Textual description of width and height\n                    * tbr        Average bitrate of audio and video in KBit/s\n                    * abr        Average audio bitrate in KBit/s\n                    * acodec     Name of the audio codec in use\n                    * asr        Audio sampling rate in Hertz\n                    * vbr        Average video bitrate in KBit/s\n                    * fps        Frame rate\n                    * vcodec     Name of the video codec in use\n                    * container  Name of the container format\n                    * filesize   The number of bytes, if known in advance\n                    * filesize_approx  An estimate for the number of bytes\n                    * player_url SWF Player URL (used for rtmpdump).\n                    * protocol   The protocol that will be used for the actual\n                                 download, lower-case.\n                                 \"http\", \"https\", \"rtsp\", \"rtmp\", \"rtmpe\",\n                                 \"m3u8\", \"m3u8_native\" or \"http_dash_segments\".\n                    * fragment_base_url\n                                 Base URL for fragments. Each fragment's path\n                                 value (if present) will be relative to\n                                 this URL.\n                    * fragments  A list of fragments of a fragmented media.\n                                 Each fragment entry must contain either an url\n                                 or a path. If an url is present it should be\n                                 considered by a client. Otherwise both path and\n                                 fragment_base_url must be present. Here is\n                                 the list of all potential fields:\n                                 * \"url\" - fragment's URL\n                                 * \"path\" - fragment's path relative to\n                                            fragment_base_url\n                                 * \"duration\" (optional, int or float)\n                                 * \"filesize\" (optional, int)\n                    * preference Order number of this format. If this field is\n                                 present and not None, the formats get sorted\n                                 by this field, regardless of all other values.\n                                 -1 for default (order by other properties),\n                                 -2 or smaller for less than default.\n                                 < -1000 to hide the format (if there is\n                                    another one which is strictly better)\n                    * language   Language code, e.g. \"de\" or \"en-US\".\n                    * language_preference  Is this in the language mentioned in\n                                 the URL?\n                                 10 if it's what the URL is about,\n                                 -1 for default (don't know),\n                                 -10 otherwise, other values reserved for now.\n                    * quality    Order number of the video quality of this\n                                 format, irrespective of the file format.\n                                 -1 for default (order by other properties),\n                                 -2 or smaller for less than default.\n                    * source_preference  Order number for this video source\n                                  (quality takes higher priority)\n                                 -1 for default (order by other properties),\n                                 -2 or smaller for less than default.\n                    * http_headers  A dictionary of additional HTTP headers\n                                 to add to the request.\n                    * stretched_ratio  If given and not 1, indicates that the\n                                 video's pixels are not square.\n                                 width : height ratio as float.\n                    * no_resume  The server does not support resuming the\n                                 (HTTP or RTMP) download. Boolean.\n                    * downloader_options  A dictionary of downloader options as\n                                 described in FileDownloader\n\n    url:            Final video URL.\n    ext:            Video filename extension.\n    format:         The video format, defaults to ext (used for --get-format)\n    player_url:     SWF Player URL (used for rtmpdump).\n\n    The following fields are optional:\n\n    alt_title:      A secondary title of the video.\n    display_id      An alternative identifier for the video, not necessarily\n                    unique, but available before title. Typically, id is\n                    something like \"4234987\", title \"Dancing naked mole rats\",\n                    and display_id \"dancing-naked-mole-rats\"\n    thumbnails:     A list of dictionaries, with the following entries:\n                        * \"id\" (optional, string) - Thumbnail format ID\n                        * \"url\"\n                        * \"preference\" (optional, int) - quality of the image\n                        * \"width\" (optional, int)\n                        * \"height\" (optional, int)\n                        * \"resolution\" (optional, string \"{width}x{height\"},\n                                        deprecated)\n                        * \"filesize\" (optional, int)\n    thumbnail:      Full URL to a video thumbnail image.\n    description:    Full video description.\n    uploader:       Full name of the video uploader.\n    license:        License name the video is licensed under.\n    creator:        The creator of the video.\n    release_date:   The date (YYYYMMDD) when the video was released.\n    timestamp:      UNIX timestamp of the moment the video became available.\n    upload_date:    Video upload date (YYYYMMDD).\n                    If not explicitly set, calculated from timestamp.\n    uploader_id:    Nickname or id of the video uploader.\n    uploader_url:   Full URL to a personal webpage of the video uploader.\n    channel:        Full name of the channel the video is uploaded on.\n                    Note that channel fields may or may not repeat uploader\n                    fields. This depends on a particular extractor.\n    channel_id:     Id of the channel.\n    channel_url:    Full URL to a channel webpage.\n    location:       Physical location where the video was filmed.\n    subtitles:      The available subtitles as a dictionary in the format\n                    {tag: subformats}. \"tag\" is usually a language code, and\n                    \"subformats\" is a list sorted from lower to higher\n                    preference, each element is a dictionary with the \"ext\"\n                    entry and one of:\n                        * \"data\": The subtitles file contents\n                        * \"url\": A URL pointing to the subtitles file\n                    \"ext\" will be calculated from URL if missing\n    automatic_captions: Like 'subtitles', used by the YoutubeIE for\n                    automatically generated captions\n    duration:       Length of the video in seconds, as an integer or float.\n    view_count:     How many users have watched the video on the platform.\n    like_count:     Number of positive ratings of the video\n    dislike_count:  Number of negative ratings of the video\n    repost_count:   Number of reposts of the video\n    average_rating: Average rating give by users, the scale used depends on the webpage\n    comment_count:  Number of comments on the video\n    comments:       A list of comments, each with one or more of the following\n                    properties (all but one of text or html optional):\n                        * \"author\" - human-readable name of the comment author\n                        * \"author_id\" - user ID of the comment author\n                        * \"id\" - Comment ID\n                        * \"html\" - Comment as HTML\n                        * \"text\" - Plain text of the comment\n                        * \"timestamp\" - UNIX timestamp of comment\n                        * \"parent\" - ID of the comment this one is replying to.\n                                     Set to \"root\" to indicate that this is a\n                                     comment to the original video.\n    age_limit:      Age restriction for the video, as an integer (years)\n    webpage_url:    The URL to the video webpage, if given to youtube-dl it\n                    should allow to get the same result again. (It will be set\n                    by YoutubeDL if it's missing)\n    categories:     A list of categories that the video falls in, for example\n                    [\"Sports\", \"Berlin\"]\n    tags:           A list of tags assigned to the video, e.g. [\"sweden\", \"pop music\"]\n    is_live:        True, False, or None (=unknown). Whether this video is a\n                    live stream that goes on instead of a fixed-length video.\n    start_time:     Time in seconds where the reproduction should start, as\n                    specified in the URL.\n    end_time:       Time in seconds where the reproduction should end, as\n                    specified in the URL.\n    chapters:       A list of dictionaries, with the following entries:\n                        * \"start_time\" - The start time of the chapter in seconds\n                        * \"end_time\" - The end time of the chapter in seconds\n                        * \"title\" (optional, string)\n\n    The following fields should only be used when the video belongs to some logical\n    chapter or section:\n\n    chapter:        Name or title of the chapter the video belongs to.\n    chapter_number: Number of the chapter the video belongs to, as an integer.\n    chapter_id:     Id of the chapter the video belongs to, as a unicode string.\n\n    The following fields should only be used when the video is an episode of some\n    series, programme or podcast:\n\n    series:         Title of the series or programme the video episode belongs to.\n    season:         Title of the season the video episode belongs to.\n    season_number:  Number of the season the video episode belongs to, as an integer.\n    season_id:      Id of the season the video episode belongs to, as a unicode string.\n    episode:        Title of the video episode. Unlike mandatory video title field,\n                    this field should denote the exact title of the video episode\n                    without any kind of decoration.\n    episode_number: Number of the video episode within a season, as an integer.\n    episode_id:     Id of the video episode, as a unicode string.\n\n    The following fields should only be used when the media is a track or a part of\n    a music album:\n\n    track:          Title of the track.\n    track_number:   Number of the track within an album or a disc, as an integer.\n    track_id:       Id of the track (useful in case of custom indexing, e.g. 6.iii),\n                    as a unicode string.\n    artist:         Artist(s) of the track.\n    genre:          Genre(s) of the track.\n    album:          Title of the album the track belongs to.\n    album_type:     Type of the album (e.g. \"Demo\", \"Full-length\", \"Split\", \"Compilation\", etc).\n    album_artist:   List of all artists appeared on the album (e.g.\n                    \"Ash Borer / Fell Voices\" or \"Various Artists\", useful for splits\n                    and compilations).\n    disc_number:    Number of the disc or other physical medium the track belongs to,\n                    as an integer.\n    release_year:   Year (YYYY) when the album was released.\n\n    Unless mentioned otherwise, the fields should be Unicode strings.\n\n    Unless mentioned otherwise, None is equivalent to absence of information.\n\n\n    _type \"playlist\" indicates multiple videos.\n    There must be a key \"entries\", which is a list, an iterable, or a PagedList\n    object, each element of which is a valid dictionary by this specification.\n\n    Additionally, playlists can have \"id\", \"title\", \"description\", \"uploader\",\n    \"uploader_id\", \"uploader_url\" attributes with the same semantics as videos\n    (see above).\n\n\n    _type \"multi_video\" indicates that there are multiple videos that\n    form a single show, for examples multiple acts of an opera or TV episode.\n    It must have an entries key like a playlist and contain all the keys\n    required for a video at the same time.\n\n\n    _type \"url\" indicates that the video must be extracted from another\n    location, possibly by a different extractor. Its only required key is:\n    \"url\" - the next URL to extract.\n    The key \"ie_key\" can be set to the class name (minus the trailing \"IE\",\n    e.g. \"Youtube\") if the extractor class is known in advance.\n    Additionally, the dictionary may have any properties of the resolved entity\n    known in advance, for example \"title\" if the title of the referred video is\n    known ahead of time.\n\n\n    _type \"url_transparent\" entities have the same specification as \"url\", but\n    indicate that the given additional information is more precise than the one\n    associated with the resolved URL.\n    This is useful when a site employs a video service that hosts the video and\n    its technical metadata, but that video service does not embed a useful\n    title, description etc.\n\n\n    Subclasses of this one should re-define the _real_initialize() and\n    _real_extract() methods and define a _VALID_URL regexp.\n    Probably, they should also be added to the list of extractors.\n\n    _GEO_BYPASS attribute may be set to False in order to disable\n    geo restriction bypass mechanisms for a particular extractor.\n    Though it won't disable explicit geo restriction bypass based on\n    country code provided with geo_bypass_country.\n\n    _GEO_COUNTRIES attribute may contain a list of presumably geo unrestricted\n    countries for this extractor. One of these countries will be used by\n    geo restriction bypass mechanism right away in order to bypass\n    geo restriction, of course, if the mechanism is not disabled.\n\n    _GEO_IP_BLOCKS attribute may contain a list of presumably geo unrestricted\n    IP blocks in CIDR notation for this extractor. One of these IP blocks\n    will be used by geo restriction bypass mechanism similarly\n    to _GEO_COUNTRIES.\n\n    Finally, the _WORKING attribute should be set to False for broken IEs\n    in order to warn the users and skip the tests.\n    ")
			InfoExtractor__ready = λ.False
			InfoExtractor__downloader = λ.None
			InfoExtractor__x_forwarded_for_ip = λ.None
			InfoExtractor__GEO_BYPASS = λ.True
			InfoExtractor__GEO_COUNTRIES = λ.None
			InfoExtractor__GEO_IP_BLOCKS = λ.None
			InfoExtractor__WORKING = λ.True
			InfoExtractor___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "downloader", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownloader = λargs[1]
						ϒself       = λargs[0]
					)
					λ.NewStr("Constructor. Receives an optional downloader.")
					λ.SetAttr(ϒself, "_ready", λ.False)
					λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.None)
					λ.Cal(λ.GetAttr(ϒself, "set_downloader", nil), ϒdownloader)
					return λ.None
				})
			InfoExtractor_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					λ.NewStr("Receives a URL and returns True if suitable for this IE.")
					if λ.IsTrue(λ.NewBool(!λ.Contains(λ.GetAttr(ϒcls, "__dict__", nil), λ.NewStr("_VALID_URL_RE")))) {
						λ.SetAttr(ϒcls, "_VALID_URL_RE", λ.Cal(Ωre.ϒcompile, λ.GetAttr(ϒcls, "_VALID_URL", nil)))
					}
					return λ.NewBool(λ.Cal(λ.GetAttr(λ.GetAttr(ϒcls, "_VALID_URL_RE", nil), "match", nil), ϒurl) != λ.None)
				})
			InfoExtractor_suitable = λ.Cal(λ.ClassMethodType, InfoExtractor_suitable)
			InfoExtractor__match_id = λ.NewFunction("_match_id",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒm   λ.Object
						ϒurl = λargs[1]
					)
					if λ.IsTrue(λ.NewBool(!λ.Contains(λ.GetAttr(ϒcls, "__dict__", nil), λ.NewStr("_VALID_URL_RE")))) {
						λ.SetAttr(ϒcls, "_VALID_URL_RE", λ.Cal(Ωre.ϒcompile, λ.GetAttr(ϒcls, "_VALID_URL", nil)))
					}
					ϒm = λ.Cal(λ.GetAttr(λ.GetAttr(ϒcls, "_VALID_URL_RE", nil), "match", nil), ϒurl)
					if !λ.IsTrue(ϒm) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					return λ.Cal(ϒcompat_str, λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewStr("id")))
				})
			InfoExtractor__match_id = λ.Cal(λ.ClassMethodType, InfoExtractor__match_id)
			InfoExtractor_working = λ.NewFunction("working",
				[]λ.Param{
					{Name: "cls"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
					)
					λ.NewStr("Getter method for _WORKING.")
					return λ.GetAttr(ϒcls, "_WORKING", nil)
				})
			InfoExtractor_working = λ.Cal(λ.ClassMethodType, InfoExtractor_working)
			InfoExtractor_initialize = λ.NewFunction("initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.NewStr("Initializes an instance (authentication, etc).")
					λ.Cal(λ.GetAttr(ϒself, "_initialize_geo_bypass", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("countries"): λ.GetAttr(ϒself, "_GEO_COUNTRIES", nil),
						λ.NewStr("ip_blocks"): λ.GetAttr(ϒself, "_GEO_IP_BLOCKS", nil),
					}))
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.GetAttr(ϒself, "_ready", nil)))) {
						λ.Cal(λ.GetAttr(ϒself, "_real_initialize", nil))
						λ.SetAttr(ϒself, "_ready", λ.True)
					}
					return λ.None
				})
			InfoExtractor__initialize_geo_bypass = λ.NewFunction("_initialize_geo_bypass",
				[]λ.Param{
					{Name: "self"},
					{Name: "geo_bypass_context"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcountries          λ.Object
						ϒcountry            λ.Object
						ϒgeo_bypass_context = λargs[1]
						ϒip_block           λ.Object
						ϒip_blocks          λ.Object
						ϒself               = λargs[0]
					)
					λ.NewStr("\n        Initialize geo restriction bypass mechanism.\n\n        This method is used to initialize geo bypass mechanism based on faking\n        X-Forwarded-For HTTP header. A random country from provided country list\n        is selected and a random IP belonging to this country is generated. This\n        IP will be passed as X-Forwarded-For HTTP header in all subsequent\n        HTTP requests.\n\n        This method will be used for initial geo bypass mechanism initialization\n        during the instance initialization with _GEO_COUNTRIES and\n        _GEO_IP_BLOCKS.\n\n        You may also manually call it from extractor's code if geo bypass\n        information is not available beforehand (e.g. obtained during\n        extraction) or due to some other reason. In this case you should pass\n        this information in geo bypass context passed as first argument. It may\n        contain following fields:\n\n        countries:  List of geo unrestricted countries (similar\n                    to _GEO_COUNTRIES)\n        ip_blocks:  List of geo unrestricted IP blocks in CIDR notation\n                    (similar to _GEO_IP_BLOCKS)\n\n        ")
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)))) {
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("geo_bypass"), λ.True)))) {
							return λ.None
						}
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒgeo_bypass_context))) {
							ϒgeo_bypass_context = λ.NewDictWithTable(map[λ.Object]λ.Object{})
						}
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒgeo_bypass_context, λ.NewTuple(
							λ.ListType,
							λ.TupleType,
						))) {
							ϒgeo_bypass_context = λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("countries"): ϒgeo_bypass_context,
							})
						}
						ϒip_block = λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("geo_bypass_ip_block"), λ.None)
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒip_block))) {
							ϒip_blocks = λ.Cal(λ.GetAttr(ϒgeo_bypass_context, "get", nil), λ.NewStr("ip_blocks"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.GetAttr(ϒself, "_GEO_BYPASS", nil); !λ.IsTrue(λv) {
									return λv
								} else {
									return ϒip_blocks
								}
							}()) {
								ϒip_block = λ.Cal(Ωrandom.ϒchoice, ϒip_blocks)
							}
						}
						if λ.IsTrue(ϒip_block) {
							λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.Cal(λ.GetAttr(GeoUtils, "random_ipv4", nil), ϒip_block))
							if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("verbose"), λ.False)) {
								λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", nil), λ.Mod(λ.NewStr("[debug] Using fake IP %s as X-Forwarded-For."), λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)))
							}
							return λ.None
						}
						ϒcountry = λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("geo_bypass_country"), λ.None)
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒcountry))) {
							ϒcountries = λ.Cal(λ.GetAttr(ϒgeo_bypass_context, "get", nil), λ.NewStr("countries"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.GetAttr(ϒself, "_GEO_BYPASS", nil); !λ.IsTrue(λv) {
									return λv
								} else {
									return ϒcountries
								}
							}()) {
								ϒcountry = λ.Cal(Ωrandom.ϒchoice, ϒcountries)
							}
						}
						if λ.IsTrue(ϒcountry) {
							λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.Cal(λ.GetAttr(GeoUtils, "random_ipv4", nil), ϒcountry))
							if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("verbose"), λ.False)) {
								λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", nil), λ.Mod(λ.NewStr("[debug] Using fake IP %s (%s) as X-Forwarded-For."), λ.NewTuple(
									λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil),
									λ.Cal(λ.GetAttr(ϒcountry, "upper", nil)),
								)))
							}
						}
					}
					return λ.None
				})
			InfoExtractor_extract = λ.NewFunction("extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie_result λ.Object
						ϒself      = λargs[0]
						ϒurl       = λargs[1]
						τmp0       λ.Object
						τmp1       λ.Object
						τmp2       λ.Object
						τmp3       λ.Object
						τmp4       λ.Object
						τmp5       λ.Object
					)
					λ.NewStr("Extracts URL information and returns it in list of dicts.")
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
								panic(λ.Raise(λex))
							}},
							&λ.Catcher{λ.GetAttr(ϒcompat_http_client, "IncompleteRead", nil), func(λex λ.BaseException) {
								ϒe := λex
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("A network error has occurred.")), λ.KWArgs{
									{Name: "cause", Value: ϒe},
									{Name: "expected", Value: λ.True},
								})))
							}},
							&λ.Catcher{λ.NewTuple(
								λ.KeyErrorType,
								λ.StopIterationType,
							), func(λex λ.BaseException) {
								ϒe := λex
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("An extractor error has occurred.")), λ.KWArgs{
									{Name: "cause", Value: ϒe},
								})))
							}},
						)
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.NewInt(2)))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							_ = τmp3
							τmp4, τmp5 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{GeoRestrictedError, func(λex λ.BaseException) {
										ϒe := λex
										if λ.IsTrue(λ.Cal(λ.GetAttr(ϒself, "__maybe_fake_ip_and_retry", nil), λ.GetAttr(ϒe, "countries", nil))) {
											λexit = λ.BlockExitContinue
											return
										}
										panic(λ.Raise(λex))
									}},
								)
								λ.Cal(λ.GetAttr(ϒself, "initialize", nil))
								ϒie_result = λ.Cal(λ.GetAttr(ϒself, "_real_extract", nil), ϒurl)
								if λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)) {
									λ.SetItem(ϒie_result, λ.NewStr("__x_forwarded_for_ip"), λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil))
								}
								λexit, λret = λ.BlockExitReturn, ϒie_result
								return
								return λ.BlockExitNormally, nil
							}()
							if τmp4 == λ.BlockExitReturn {
								λexit, λret = λ.BlockExitReturn, τmp5
								return
							}
							if τmp4 == λ.BlockExitContinue {
								continue
							}
						}
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor_set_downloader = λ.NewFunction("set_downloader",
				[]λ.Param{
					{Name: "self"},
					{Name: "downloader"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownloader = λargs[1]
						ϒself       = λargs[0]
					)
					λ.NewStr("Sets the downloader for this IE.")
					λ.SetAttr(ϒself, "_downloader", ϒdownloader)
					return λ.None
				})
			InfoExtractor__real_initialize = λ.NewFunction("_real_initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					_ = ϒself
					λ.NewStr("Real initialization process. Redefine in subclasses.")
					// pass
					return λ.None
				})
			InfoExtractor_ie_key = λ.NewFunction("ie_key",
				[]λ.Param{
					{Name: "cls"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
					)
					λ.NewStr("A string for getting the InfoExtractor with get_info_extractor")
					return λ.Cal(ϒcompat_str, λ.GetItem(λ.GetAttr(ϒcls, "__name__", nil), λ.NewSlice(λ.None, λ.Neg(λ.NewInt(2)), λ.None)))
				})
			InfoExtractor_ie_key = λ.Cal(λ.ClassMethodType, InfoExtractor_ie_key)
			InfoExtractor_IE_NAME = λ.NewFunction("IE_NAME",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					return λ.Cal(ϒcompat_str, λ.GetItem(λ.GetAttr(λ.Cal(λ.TypeType, ϒself), "__name__", nil), λ.NewSlice(λ.None, λ.Neg(λ.NewInt(2)), λ.None)))
				})
			InfoExtractor_IE_NAME = λ.Cal(λ.PropertyType, InfoExtractor_IE_NAME)
			InfoExtractor___can_accept_status_code = λ.NewFunction("__can_accept_status_code",
				[]λ.Param{
					{Name: "err"},
					{Name: "expected_status"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerr             = λargs[0]
						ϒexpected_status = λargs[1]
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒerr, Ωerror.HTTPError)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if λ.IsTrue(λ.NewBool(ϒexpected_status == λ.None)) {
						return λ.False
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒexpected_status, λ.None)) {
						return λ.Eq(λ.GetAttr(ϒerr, "code", nil), ϒexpected_status)
					} else {
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒexpected_status, λ.NewTuple(
							λ.ListType,
							λ.TupleType,
						))) {
							return λ.NewBool(λ.Contains(ϒexpected_status, λ.GetAttr(ϒerr, "code", nil)))
						} else {
							if λ.IsTrue(λ.Cal(λ.BuiltinCallable, ϒexpected_status)) {
								return λ.NewBool(λ.Cal(ϒexpected_status, λ.GetAttr(ϒerr, "code", nil)) == λ.True)
							} else {
								if !λ.IsTrue(λ.False) {
									panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
								}
							}
						}
					}
					return λ.None
				})
			InfoExtractor___can_accept_status_code = λ.Cal(λ.StaticMethodType, InfoExtractor___can_accept_status_code)
			InfoExtractor__request_webpage = λ.NewFunction("_request_webpage",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata            = λargs[6]
						ϒerrmsg          λ.Object
						ϒerrnote         = λargs[4]
						ϒexpected_status = λargs[9]
						ϒfatal           = λargs[5]
						ϒheaders         = λargs[7]
						ϒnote            = λargs[3]
						ϒquery           = λargs[8]
						ϒself            = λargs[0]
						ϒurl_or_request  = λargs[1]
						ϒvideo_id        = λargs[2]
						τmp0             λ.Object
						τmp1             λ.Object
					)
					λ.NewStr("\n        Return the response handle.\n\n        See _download_webpage docstring for arguments specification.\n        ")
					if λ.IsTrue(λ.NewBool(ϒnote == λ.None)) {
						λ.Cal(λ.GetAttr(ϒself, "report_download_webpage", nil), ϒvideo_id)
					} else {
						if λ.IsTrue(λ.NewBool(ϒnote != λ.False)) {
							if λ.IsTrue(λ.NewBool(ϒvideo_id == λ.None)) {
								λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("%s"), λ.NewTuple(ϒnote)))
							} else {
								λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("%s: %s"), λ.NewTuple(
									ϒvideo_id,
									ϒnote,
								)))
							}
						}
					}
					if λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)) {
						if λ.IsTrue(λ.NewBool(!λ.Contains(ϒheaders, λ.NewStr("X-Forwarded-For")))) {
							λ.SetItem(ϒheaders, λ.NewStr("X-Forwarded-For"), λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil))
						}
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl_or_request, Ωrequest.Request)) {
						ϒurl_or_request = λ.Call(ϒupdate_Request, λ.NewArgs(ϒurl_or_request), λ.KWArgs{
							{Name: "data", Value: ϒdata},
							{Name: "headers", Value: ϒheaders},
							{Name: "query", Value: ϒquery},
						})
					} else {
						if λ.IsTrue(ϒquery) {
							ϒurl_or_request = λ.Cal(ϒupdate_url_query, ϒurl_or_request, ϒquery)
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒdata != λ.None); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒheaders
							}
						}()) {
							ϒurl_or_request = λ.Cal(ϒsanitized_Request, ϒurl_or_request, ϒdata, ϒheaders)
						}
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.NewTuple(
								Ωerror.URLError,
								λ.GetAttr(ϒcompat_http_client, "HTTPException", nil),
								Ωsocket.ϒerror,
							), func(λex λ.BaseException) {
								ϒerr := λex
								if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒerr, Ωerror.HTTPError)) {
									if λ.IsTrue(λ.Cal(λ.GetAttr(ϒself, "__can_accept_status_code", nil), ϒerr, ϒexpected_status)) {
										λ.SetAttr(λ.GetAttr(ϒerr, "fp", nil), "_error", ϒerr)
										λexit, λret = λ.BlockExitReturn, λ.GetAttr(ϒerr, "fp", nil)
										return
									}
								}
								if λ.IsTrue(λ.NewBool(ϒerrnote == λ.False)) {
									λexit, λret = λ.BlockExitReturn, λ.False
									return
								}
								if λ.IsTrue(λ.NewBool(ϒerrnote == λ.None)) {
									ϒerrnote = λ.NewStr("Unable to download webpage")
								}
								ϒerrmsg = λ.Mod(λ.NewStr("%s: %s"), λ.NewTuple(
									ϒerrnote,
									λ.Cal(ϒerror_to_compat_str, ϒerr),
								))
								if λ.IsTrue(ϒfatal) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(
										ϒerrmsg,
										λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.NewInt(2)),
									), λ.KWArgs{
										{Name: "cause", Value: ϒerr},
									})))
								} else {
									λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), ϒerrmsg)
									λexit, λret = λ.BlockExitReturn, λ.False
									return
								}
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "urlopen", nil), ϒurl_or_request)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor__download_webpage_handle = λ.NewFunction("_download_webpage_handle",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent         λ.Object
						ϒdata            = λargs[7]
						ϒencoding        = λargs[6]
						ϒerrnote         = λargs[4]
						ϒexpected_status = λargs[10]
						ϒfatal           = λargs[5]
						ϒheaders         = λargs[8]
						ϒnote            = λargs[3]
						ϒquery           = λargs[9]
						ϒself            = λargs[0]
						ϒurl_or_request  = λargs[1]
						ϒurlh            λ.Object
						ϒvideo_id        = λargs[2]
					)
					λ.NewStr("\n        Return a tuple (page content as string, URL handle).\n\n        See _download_webpage docstring for arguments specification.\n        ")
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl_or_request, λ.NewTuple(
						ϒcompat_str,
						λ.StrType,
					))) {
						ϒurl_or_request = λ.GetItem(λ.Cal(λ.GetAttr(ϒurl_or_request, "partition", nil), λ.NewStr("#")), λ.NewInt(0))
					}
					ϒurlh = λ.Call(λ.GetAttr(ϒself, "_request_webpage", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
						ϒfatal,
					), λ.KWArgs{
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					if λ.IsTrue(λ.NewBool(ϒurlh == λ.False)) {
						if !λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒfatal))) {
							panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
						}
						return λ.False
					}
					ϒcontent = λ.Call(λ.GetAttr(ϒself, "_webpage_read_content", nil), λ.NewArgs(
						ϒurlh,
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
						ϒfatal,
					), λ.KWArgs{
						{Name: "encoding", Value: ϒencoding},
					})
					return λ.NewTuple(
						ϒcontent,
						ϒurlh,
					)
				})
			InfoExtractor__guess_encoding_from_content = λ.NewFunction("_guess_encoding_from_content",
				[]λ.Param{
					{Name: "content_type"},
					{Name: "webpage_bytes"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent_type  = λargs[0]
						ϒencoding      λ.Object
						ϒm             λ.Object
						ϒwebpage_bytes = λargs[1]
					)
					ϒm = λ.Cal(Ωre.ϒmatch, λ.NewStr("[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+\\s*;\\s*charset=(.+)"), ϒcontent_type)
					if λ.IsTrue(ϒm) {
						ϒencoding = λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(1))
					} else {
						ϒm = λ.Cal(Ωre.ϒsearch, λ.NewBytes(0x3c, 0x6d, 0x65, 0x74, 0x61, 0x5b, 0x5e, 0x3e, 0x5d, 0x2b, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x5b, 0x5c, 0x27, 0x22, 0x5d, 0x3f, 0x28, 0x5b, 0x5e, 0x5c, 0x27, 0x22, 0x29, 0x5d, 0x2b, 0x29, 0x5b, 0x20, 0x2f, 0x5c, 0x27, 0x22, 0x3e, 0x5d), λ.GetItem(ϒwebpage_bytes, λ.NewSlice(λ.None, λ.NewInt(1024), λ.None)))
						if λ.IsTrue(ϒm) {
							ϒencoding = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒm, "group", nil), λ.NewInt(1)), "decode", nil), λ.NewStr("ascii"))
						} else {
							if λ.IsTrue(λ.Cal(λ.GetAttr(ϒwebpage_bytes, "startswith", nil), λ.NewBytes(0xff, 0xfe))) {
								ϒencoding = λ.NewStr("utf-16")
							} else {
								ϒencoding = λ.NewStr("utf-8")
							}
						}
					}
					return ϒencoding
				})
			InfoExtractor__guess_encoding_from_content = λ.Cal(λ.StaticMethodType, InfoExtractor__guess_encoding_from_content)
			InfoExtractor___check_blocked = λ.NewFunction("__check_blocked",
				[]λ.Param{
					{Name: "self"},
					{Name: "content"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒblock_msg      λ.Object
						ϒblocked_iframe λ.Object
						ϒcontent        = λargs[1]
						ϒfirst_block    λ.Object
						ϒmsg            λ.Object
						ϒself           = λargs[0]
						τmp0            λ.Object
					)
					ϒfirst_block = λ.GetItem(ϒcontent, λ.NewSlice(λ.None, λ.NewInt(512), λ.None))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒcontent, λ.NewStr("<title>Access to this site is blocked</title>"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(ϒfirst_block, λ.NewStr("Websense")))
						}
					}()) {
						ϒmsg = λ.NewStr("Access to this webpage has been blocked by Websense filtering software in your network.")
						ϒblocked_iframe = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.NewStr("<iframe src=\"([^\"]+)\""),
							ϒcontent,
							λ.NewStr("Websense information URL"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						if λ.IsTrue(ϒblocked_iframe) {
							τmp0 = λ.IAdd(ϒmsg, λ.Mod(λ.NewStr(" Visit %s for more details"), ϒblocked_iframe))
							ϒmsg = τmp0
						}
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒmsg), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					if λ.IsTrue(λ.NewBool(λ.Contains(ϒfirst_block, λ.NewStr("<title>The URL you requested has been blocked</title>")))) {
						ϒmsg = λ.NewStr("Access to this webpage has been blocked by Indian censorship. Use a VPN or proxy server (with --proxy) to route around it.")
						ϒblock_msg = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.NewStr("</h1><p>(.*?)</p>"),
							ϒcontent,
							λ.NewStr("block message"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						if λ.IsTrue(ϒblock_msg) {
							τmp0 = λ.IAdd(ϒmsg, λ.Mod(λ.NewStr(" (Message: \"%s\")"), λ.Cal(λ.GetAttr(ϒblock_msg, "replace", nil), λ.NewStr("\n"), λ.NewStr(" "))))
							ϒmsg = τmp0
						}
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒmsg), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒcontent, λ.NewStr("<title>TTK :: Доступ к ресурсу ограничен</title>"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(ϒcontent, λ.NewStr("blocklist.rkn.gov.ru")))
						}
					}()) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("Access to this webpage has been blocked by decision of the Russian government. Visit http://blocklist.rkn.gov.ru/ for a block reason.")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					return λ.None
				})
			InfoExtractor__webpage_read_content = λ.NewFunction("_webpage_read_content",
				[]λ.Param{
					{Name: "self"},
					{Name: "urlh"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "prefix", Def: λ.None},
					{Name: "encoding", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabsfilepath    λ.Object
						ϒbasen          λ.Object
						ϒcontent        λ.Object
						ϒcontent_type   λ.Object
						ϒdump           λ.Object
						ϒencoding       = λargs[8]
						ϒerrnote        = λargs[5]
						ϒfatal          = λargs[6]
						ϒfilename       λ.Object
						ϒh              λ.Object
						ϒnote           = λargs[4]
						ϒoutf           λ.Object
						ϒprefix         = λargs[7]
						ϒraw_filename   λ.Object
						ϒself           = λargs[0]
						ϒurl_or_request = λargs[2]
						ϒurlh           = λargs[1]
						ϒvideo_id       = λargs[3]
						ϒwebpage_bytes  λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
						τmp3            λ.Object
					)
					_ = ϒerrnote
					_ = ϒfatal
					_ = ϒnote
					_ = ϒurl_or_request
					_ = τmp0
					_ = τmp1
					_ = τmp2
					_ = τmp3
					ϒcontent_type = λ.Cal(λ.GetAttr(λ.GetAttr(ϒurlh, "headers", nil), "get", nil), λ.NewStr("Content-Type"), λ.NewStr(""))
					ϒwebpage_bytes = λ.Cal(λ.GetAttr(ϒurlh, "read", nil))
					if λ.IsTrue(λ.NewBool(ϒprefix != λ.None)) {
						ϒwebpage_bytes = λ.Add(ϒprefix, ϒwebpage_bytes)
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒencoding))) {
						ϒencoding = λ.Cal(λ.GetAttr(ϒself, "_guess_encoding_from_content", nil), ϒcontent_type, ϒwebpage_bytes)
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("dump_intermediate_pages"), λ.False)) {
						λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("Dumping request to "), λ.Cal(λ.GetAttr(ϒurlh, "geturl", nil))))
						ϒdump = λ.Cal(λ.GetAttr(λ.Cal(λ.None, ϒwebpage_bytes), "decode", nil), λ.NewStr("ascii"))
						λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", nil), ϒdump)
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("write_pages"), λ.False)) {
						ϒbasen = λ.Mod(λ.NewStr("%s_%s"), λ.NewTuple(
							ϒvideo_id,
							λ.Cal(λ.GetAttr(ϒurlh, "geturl", nil)),
						))
						if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒbasen), λ.NewInt(240))) {
							ϒh = λ.Add(λ.NewStr("___"), λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(λ.None, "md5", nil), λ.Cal(λ.GetAttr(ϒbasen, "encode", nil), λ.NewStr("utf-8"))), "hexdigest", nil)))
							ϒbasen = λ.Add(λ.GetItem(ϒbasen, λ.NewSlice(λ.None, λ.Sub(λ.NewInt(240), λ.Cal(λ.BuiltinLen, ϒh)), λ.None)), ϒh)
						}
						ϒraw_filename = λ.Add(ϒbasen, λ.NewStr(".dump"))
						ϒfilename = λ.Call(ϒsanitize_filename, λ.NewArgs(ϒraw_filename), λ.KWArgs{
							{Name: "restricted", Value: λ.True},
						})
						λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Add(λ.NewStr("Saving request to "), ϒfilename))
						if λ.IsTrue(λ.Eq(λ.None, λ.NewStr("nt"))) {
							ϒabsfilepath = λ.Cal(λ.GetAttr(λ.GetAttr(λ.None, "path", nil), "abspath", nil), ϒfilename)
							if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒabsfilepath), λ.NewInt(259))) {
								ϒfilename = λ.Add(λ.NewStr("\\\\?\\"), ϒabsfilepath)
							}
						}
						τmp0 = λ.Cal(λ.BuiltinOpen, ϒfilename, λ.NewStr("wb"))
						τmp1 = λ.GetAttr(τmp0, "__exit__", nil)
						ϒoutf = λ.Cal(λ.GetAttr(τmp0, "__enter__", nil))
						τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
								if ret := λ.Cal(τmp1, λex.Type(), λex, λ.NewStr("..todo..traceback..")); λ.IsTrue(ret) {
									panic(λ.Raise(λex))
								}
							}, func() {
								λ.Cal(τmp1, λ.None, λ.None, λ.None)
							})
							λ.Cal(λ.GetAttr(ϒoutf, "write", nil), ϒwebpage_bytes)
							return λ.BlockExitNormally, nil
						}()
					}
					τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.LookupErrorType, func(λex λ.BaseException) {
								ϒcontent = λ.Cal(λ.GetAttr(ϒwebpage_bytes, "decode", nil), λ.NewStr("utf-8"), λ.NewStr("replace"))
							}},
						)
						ϒcontent = λ.Cal(λ.GetAttr(ϒwebpage_bytes, "decode", nil), ϒencoding, λ.NewStr("replace"))
						return λ.BlockExitNormally, nil
					}()
					λ.Cal(λ.GetAttr(ϒself, "__check_blocked", nil), ϒcontent)
					return ϒcontent
				})
			InfoExtractor__download_webpage = λ.NewFunction("_download_webpage",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "tries", Def: λ.NewInt(1)},
					{Name: "timeout", Def: λ.NewInt(5)},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent         λ.Object
						ϒdata            = λargs[9]
						ϒencoding        = λargs[8]
						ϒerrnote         = λargs[4]
						ϒexpected_status = λargs[12]
						ϒfatal           = λargs[5]
						ϒheaders         = λargs[10]
						ϒnote            = λargs[3]
						ϒquery           = λargs[11]
						ϒres             λ.Object
						ϒself            = λargs[0]
						ϒsuccess         λ.Object
						ϒtimeout         = λargs[7]
						ϒtries           = λargs[6]
						ϒtry_count       λ.Object
						ϒurl_or_request  = λargs[1]
						ϒvideo_id        = λargs[2]
						τmp0             λ.Object
						τmp1             λ.Object
						τmp2             λ.Object
					)
					_ = τmp0
					λ.NewStr("\n        Return the data of the page as a string.\n\n        Arguments:\n        url_or_request -- plain text URL as a string or\n            a compat_urllib_request.Requestobject\n        video_id -- Video/playlist/item identifier (string)\n\n        Keyword arguments:\n        note -- note printed before downloading (string)\n        errnote -- note printed in case of an error (string)\n        fatal -- flag denoting whether error should be considered fatal,\n            i.e. whether it should cause ExtractionError to be raised,\n            otherwise a warning will be reported and extraction continued\n        tries -- number of tries\n        timeout -- sleep interval between tries\n        encoding -- encoding for a page content decoding, guessed automatically\n            when not explicitly specified\n        data -- POST data (bytes)\n        headers -- HTTP headers (dict)\n        query -- URL query (dict)\n        expected_status -- allows to accept failed HTTP requests (non 2xx\n            status code) by explicitly specifying a set of accepted status\n            codes. Can be any of the following entities:\n                - an integer type specifying an exact failed status code to\n                  accept\n                - a list or a tuple of integer types specifying a list of\n                  failed status codes to accept\n                - a callable accepting an actual failed status code and\n                  returning True if it should be accepted\n            Note that this argument does not affect success status codes (2xx)\n            which are always accepted.\n        ")
					ϒsuccess = λ.False
					ϒtry_count = λ.NewInt(0)
					for λ.IsTrue(λ.NewBool(ϒsuccess == λ.False)) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.GetAttr(ϒcompat_http_client, "IncompleteRead", nil), func(λex λ.BaseException) {
									ϒe := λex
									τmp2 = λ.IAdd(ϒtry_count, λ.NewInt(1))
									ϒtry_count = τmp2
									if λ.IsTrue(λ.Ge(ϒtry_count, ϒtries)) {
										panic(λ.Raise(ϒe))
									}
									λ.Cal(λ.GetAttr(ϒself, "_sleep", nil), ϒtimeout, ϒvideo_id)
								}},
							)
							ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
								ϒurl_or_request,
								ϒvideo_id,
								ϒnote,
								ϒerrnote,
								ϒfatal,
							), λ.KWArgs{
								{Name: "encoding", Value: ϒencoding},
								{Name: "data", Value: ϒdata},
								{Name: "headers", Value: ϒheaders},
								{Name: "query", Value: ϒquery},
								{Name: "expected_status", Value: ϒexpected_status},
							})
							ϒsuccess = λ.True
							return λ.BlockExitNormally, nil
						}()
					}
					if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
						return ϒres
					} else {
						τmp1 = ϒres
						ϒcontent = λ.GetItem(τmp1, λ.NewInt(0))
						_ = λ.GetItem(τmp1, λ.NewInt(1))
						return ϒcontent
					}
					return λ.None
				})
			InfoExtractor__download_xml_handle = λ.NewFunction("_download_xml_handle",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.NewStr("Downloading XML")},
					{Name: "errnote", Def: λ.NewStr("Unable to download XML")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒurlh             λ.Object
						ϒvideo_id         = λargs[2]
						ϒxml_string       λ.Object
						τmp0              λ.Object
					)
					λ.NewStr("\n        Return a tuple (xml as an xml.etree.ElementTree.Element, URL handle).\n\n        See _download_webpage docstring for arguments specification.\n        ")
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
						return ϒres
					}
					τmp0 = ϒres
					ϒxml_string = λ.GetItem(τmp0, λ.NewInt(0))
					ϒurlh = λ.GetItem(τmp0, λ.NewInt(1))
					return λ.NewTuple(
						λ.Call(λ.GetAttr(ϒself, "_parse_xml", nil), λ.NewArgs(
							ϒxml_string,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒtransform_source},
							{Name: "fatal", Value: ϒfatal},
						}),
						ϒurlh,
					)
				})
			InfoExtractor__download_xml = λ.NewFunction("_download_xml",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.NewStr("Downloading XML")},
					{Name: "errnote", Def: λ.NewStr("Unable to download XML")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒvideo_id         = λargs[2]
					)
					λ.NewStr("\n        Return the xml as an xml.etree.ElementTree.Element.\n\n        See _download_webpage docstring for arguments specification.\n        ")
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_xml_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: ϒnote},
						{Name: "errnote", Value: ϒerrnote},
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					return func() λ.Object {
						if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
							return ϒres
						} else {
							return λ.GetItem(ϒres, λ.NewInt(0))
						}
					}()
				})
			InfoExtractor__parse_xml = λ.NewFunction("_parse_xml",
				[]λ.Param{
					{Name: "self"},
					{Name: "xml_string"},
					{Name: "video_id"},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerrmsg           λ.Object
						ϒfatal            = λargs[4]
						ϒself             = λargs[0]
						ϒtransform_source = λargs[3]
						ϒvideo_id         = λargs[2]
						ϒxml_string       = λargs[1]
						τmp0              λ.Object
						τmp1              λ.Object
					)
					if λ.IsTrue(ϒtransform_source) {
						ϒxml_string = λ.Cal(ϒtransform_source, ϒxml_string)
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{ϒcompat_xml_parse_error, func(λex λ.BaseException) {
								ϒve := λex
								ϒerrmsg = λ.Mod(λ.NewStr("%s: Failed to parse XML "), ϒvideo_id)
								if λ.IsTrue(ϒfatal) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerrmsg), λ.KWArgs{
										{Name: "cause", Value: ϒve},
									})))
								} else {
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Add(ϒerrmsg, λ.Cal(λ.StrType, ϒve)))
								}
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Cal(ϒcompat_etree_fromstring, λ.Cal(λ.GetAttr(ϒxml_string, "encode", nil), λ.NewStr("utf-8")))
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor__download_json_handle = λ.NewFunction("_download_json_handle",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.NewStr("Downloading JSON metadata")},
					{Name: "errnote", Def: λ.NewStr("Unable to download JSON metadata")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒjson_string      λ.Object
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒurlh             λ.Object
						ϒvideo_id         = λargs[2]
						τmp0              λ.Object
					)
					λ.NewStr("\n        Return a tuple (JSON object, URL handle).\n\n        See _download_webpage docstring for arguments specification.\n        ")
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
						return ϒres
					}
					τmp0 = ϒres
					ϒjson_string = λ.GetItem(τmp0, λ.NewInt(0))
					ϒurlh = λ.GetItem(τmp0, λ.NewInt(1))
					return λ.NewTuple(
						λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							ϒjson_string,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒtransform_source},
							{Name: "fatal", Value: ϒfatal},
						}),
						ϒurlh,
					)
				})
			InfoExtractor__download_json = λ.NewFunction("_download_json",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.NewStr("Downloading JSON metadata")},
					{Name: "errnote", Def: λ.NewStr("Unable to download JSON metadata")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒvideo_id         = λargs[2]
					)
					λ.NewStr("\n        Return the JSON object as a dict.\n\n        See _download_webpage docstring for arguments specification.\n        ")
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_json_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: ϒnote},
						{Name: "errnote", Value: ϒerrnote},
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					return func() λ.Object {
						if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
							return ϒres
						} else {
							return λ.GetItem(ϒres, λ.NewInt(0))
						}
					}()
				})
			InfoExtractor__parse_json = λ.NewFunction("_parse_json",
				[]λ.Param{
					{Name: "self"},
					{Name: "json_string"},
					{Name: "video_id"},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerrmsg           λ.Object
						ϒfatal            = λargs[4]
						ϒjson_string      = λargs[1]
						ϒself             = λargs[0]
						ϒtransform_source = λargs[3]
						ϒvideo_id         = λargs[2]
						τmp0              λ.Object
						τmp1              λ.Object
					)
					if λ.IsTrue(ϒtransform_source) {
						ϒjson_string = λ.Cal(ϒtransform_source, ϒjson_string)
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
								ϒve := λex
								ϒerrmsg = λ.Mod(λ.NewStr("%s: Failed to parse JSON "), ϒvideo_id)
								if λ.IsTrue(ϒfatal) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerrmsg), λ.KWArgs{
										{Name: "cause", Value: ϒve},
									})))
								} else {
									λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Add(ϒerrmsg, λ.Cal(λ.StrType, ϒve)))
								}
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Cal(Ωjson.ϒloads, ϒjson_string)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor_report_warning = λ.NewFunction("report_warning",
				[]λ.Param{
					{Name: "self"},
					{Name: "msg"},
					{Name: "video_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒidstr    λ.Object
						ϒmsg      = λargs[1]
						ϒself     = λargs[0]
						ϒvideo_id = λargs[2]
					)
					ϒidstr = func() λ.Object {
						if λ.IsTrue(λ.NewBool(ϒvideo_id == λ.None)) {
							return λ.NewStr("")
						} else {
							return λ.Mod(λ.NewStr("%s: "), ϒvideo_id)
						}
					}()
					λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.Mod(λ.NewStr("[%s] %s%s"), λ.NewTuple(
						λ.GetAttr(ϒself, "IE_NAME", nil),
						ϒidstr,
						ϒmsg,
					)))
					return λ.None
				})
			InfoExtractor_to_screen = λ.NewFunction("to_screen",
				[]λ.Param{
					{Name: "self"},
					{Name: "msg"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmsg  = λargs[1]
						ϒself = λargs[0]
					)
					λ.NewStr("Print msg to screen, prefixing it with '[ie_name]'")
					λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", nil), λ.Mod(λ.NewStr("[%s] %s"), λ.NewTuple(
						λ.GetAttr(ϒself, "IE_NAME", nil),
						ϒmsg,
					)))
					return λ.None
				})
			InfoExtractor_report_extraction = λ.NewFunction("report_extraction",
				[]λ.Param{
					{Name: "self"},
					{Name: "id_or_name"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒid_or_name = λargs[1]
						ϒself       = λargs[0]
					)
					λ.NewStr("Report information extraction.")
					λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("%s: Extracting information"), ϒid_or_name))
					return λ.None
				})
			InfoExtractor_report_download_webpage = λ.NewFunction("report_download_webpage",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself     = λargs[0]
						ϒvideo_id = λargs[1]
					)
					λ.NewStr("Report webpage download.")
					λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("%s: Downloading webpage"), ϒvideo_id))
					return λ.None
				})
			InfoExtractor_url_result = λ.NewFunction("url_result",
				[]λ.Param{
					{Name: "url"},
					{Name: "ie", Def: λ.None},
					{Name: "video_id", Def: λ.None},
					{Name: "video_title", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie          = λargs[1]
						ϒurl         = λargs[0]
						ϒvideo_id    = λargs[2]
						ϒvideo_info  λ.Object
						ϒvideo_title = λargs[3]
					)
					λ.NewStr("Returns a URL that points to a page that should be processed")
					ϒvideo_info = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("_type"):  λ.NewStr("url"),
						λ.NewStr("url"):    ϒurl,
						λ.NewStr("ie_key"): ϒie,
					})
					if λ.IsTrue(λ.NewBool(ϒvideo_id != λ.None)) {
						λ.SetItem(ϒvideo_info, λ.NewStr("id"), ϒvideo_id)
					}
					if λ.IsTrue(λ.NewBool(ϒvideo_title != λ.None)) {
						λ.SetItem(ϒvideo_info, λ.NewStr("title"), ϒvideo_title)
					}
					return ϒvideo_info
				})
			InfoExtractor_url_result = λ.Cal(λ.StaticMethodType, InfoExtractor_url_result)
			InfoExtractor_playlist_result = λ.NewFunction("playlist_result",
				[]λ.Param{
					{Name: "entries"},
					{Name: "playlist_id", Def: λ.None},
					{Name: "playlist_title", Def: λ.None},
					{Name: "playlist_description", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒentries              = λargs[0]
						ϒplaylist_description = λargs[3]
						ϒplaylist_id          = λargs[1]
						ϒplaylist_title       = λargs[2]
						ϒvideo_info           λ.Object
					)
					λ.NewStr("Returns a playlist")
					ϒvideo_info = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("_type"):   λ.NewStr("playlist"),
						λ.NewStr("entries"): ϒentries,
					})
					if λ.IsTrue(ϒplaylist_id) {
						λ.SetItem(ϒvideo_info, λ.NewStr("id"), ϒplaylist_id)
					}
					if λ.IsTrue(ϒplaylist_title) {
						λ.SetItem(ϒvideo_info, λ.NewStr("title"), ϒplaylist_title)
					}
					if λ.IsTrue(ϒplaylist_description) {
						λ.SetItem(ϒvideo_info, λ.NewStr("description"), ϒplaylist_description)
					}
					return ϒvideo_info
				})
			InfoExtractor_playlist_result = λ.Cal(λ.StaticMethodType, InfoExtractor_playlist_result)
			InfoExtractor__search_regex = λ.NewFunction("_search_regex",
				[]λ.Param{
					{Name: "self"},
					{Name: "pattern"},
					{Name: "string"},
					{Name: "name"},
					{Name: "default", Def: NO_DEFAULT},
					{Name: "fatal", Def: λ.True},
					{Name: "flags", Def: λ.NewInt(0)},
					{Name: "group", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_name   λ.Object
						ϒdefault = λargs[4]
						ϒfatal   = λargs[5]
						ϒflags   = λargs[6]
						ϒgroup   = λargs[7]
						ϒmobj    λ.Object
						ϒname    = λargs[3]
						ϒp       λ.Object
						ϒpattern = λargs[1]
						ϒself    = λargs[0]
						ϒstring  = λargs[2]
						τmp0     λ.Object
						τmp1     λ.Object
					)
					λ.NewStr("\n        Perform a regex search on the given string, using a single or a list of\n        patterns returning the first matching group.\n        In case of failure return a default value or raise a WARNING or a\n        RegexNotFoundError, depending on fatal, specifying the field name.\n        ")
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpattern, λ.NewTuple(
						λ.StrType,
						ϒcompat_str,
						ϒcompiled_regex_type,
					))) {
						ϒmobj = λ.Cal(Ωre.ϒsearch, ϒpattern, ϒstring, ϒflags)
					} else {
						τmp0 = λ.Cal(λ.BuiltinIter, ϒpattern)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒp = τmp1
							ϒmobj = λ.Cal(Ωre.ϒsearch, ϒp, ϒstring, ϒflags)
							if λ.IsTrue(ϒmobj) {
								break
							}
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("no_color")))); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.Ne(λ.None, λ.NewStr("nt")); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(λ.None, "isatty", nil))
						}
					}()) {
						ϒ_name = λ.Mod(λ.NewStr("[0;34m%s[0m"), ϒname)
					} else {
						ϒ_name = ϒname
					}
					if λ.IsTrue(ϒmobj) {
						if λ.IsTrue(λ.NewBool(ϒgroup == λ.None)) {
							return λ.Cal(λ.BuiltinNext, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
										var (
											ϒg   λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒmobj, "groups", nil)))
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒg = τmp1
											if λ.IsTrue(λ.NewBool(ϒg != λ.None)) {
												λgen.Yield(ϒg)
											}
										}
										return λ.None
									})
								})))
						} else {
							return λ.Cal(λ.GetAttr(ϒmobj, "group", nil), ϒgroup)
						}
					} else {
						if λ.IsTrue(λ.NewBool(ϒdefault != NO_DEFAULT)) {
							return ϒdefault
						} else {
							if λ.IsTrue(ϒfatal) {
								panic(λ.Raise(λ.Cal(RegexNotFoundError, λ.Mod(λ.NewStr("Unable to extract %s"), ϒ_name))))
							} else {
								λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.Add(λ.Mod(λ.NewStr("unable to extract %s"), ϒ_name), λ.Cal(ϒbug_reports_message)))
								return λ.None
							}
						}
					}
					return λ.None
				})
			InfoExtractor__html_search_regex = λ.NewFunction("_html_search_regex",
				[]λ.Param{
					{Name: "self"},
					{Name: "pattern"},
					{Name: "string"},
					{Name: "name"},
					{Name: "default", Def: NO_DEFAULT},
					{Name: "fatal", Def: λ.True},
					{Name: "flags", Def: λ.NewInt(0)},
					{Name: "group", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdefault = λargs[4]
						ϒfatal   = λargs[5]
						ϒflags   = λargs[6]
						ϒgroup   = λargs[7]
						ϒname    = λargs[3]
						ϒpattern = λargs[1]
						ϒres     λ.Object
						ϒself    = λargs[0]
						ϒstring  = λargs[2]
					)
					λ.NewStr("\n        Like _search_regex, but strips HTML tags and unescapes entities.\n        ")
					ϒres = λ.Cal(λ.GetAttr(ϒself, "_search_regex", nil), ϒpattern, ϒstring, ϒname, ϒdefault, ϒfatal, ϒflags, ϒgroup)
					if λ.IsTrue(ϒres) {
						return λ.Cal(λ.GetAttr(λ.Cal(ϒclean_html, ϒres), "strip", nil))
					} else {
						return ϒres
					}
					return λ.None
				})
			InfoExtractor__get_netrc_login_info = λ.NewFunction("_get_netrc_login_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "netrc_machine", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒinfo          λ.Object
						ϒnetrc_machine = λargs[1]
						ϒpassword      λ.Object
						ϒself          = λargs[0]
						ϒusername      λ.Object
						τmp0           λ.Object
						τmp1           λ.Object
					)
					_ = τmp0
					_ = τmp1
					ϒusername = λ.None
					ϒpassword = λ.None
					ϒnetrc_machine = func() λ.Object {
						if λv := ϒnetrc_machine; λ.IsTrue(λv) {
							return λv
						} else {
							return λ.GetAttr(ϒself, "_NETRC_MACHINE", nil)
						}
					}()
					if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("usenetrc"), λ.False)) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.NewTuple(
									λ.OSErrorType,
									λ.GetAttr(λ.None, "NetrcParseError", nil),
								), func(λex λ.BaseException) {
									ϒerr := λex
									λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), λ.Mod(λ.NewStr("parsing .netrc: %s"), λ.Cal(ϒerror_to_compat_str, ϒerr)))
								}},
							)
							ϒinfo = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(λ.None, "netrc", nil)), "authenticators", nil), ϒnetrc_machine)
							if λ.IsTrue(λ.NewBool(ϒinfo != λ.None)) {
								ϒusername = λ.GetItem(ϒinfo, λ.NewInt(0))
								ϒpassword = λ.GetItem(ϒinfo, λ.NewInt(2))
							} else {
								panic(λ.Raise(λ.Cal(λ.GetAttr(λ.None, "NetrcParseError", nil), λ.Mod(λ.NewStr("No authenticators for %s"), ϒnetrc_machine))))
							}
							return λ.BlockExitNormally, nil
						}()
					}
					return λ.NewTuple(
						ϒusername,
						ϒpassword,
					)
				})
			InfoExtractor__get_login_info = λ.NewFunction("_get_login_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "username_option", Def: λ.NewStr("username")},
					{Name: "password_option", Def: λ.NewStr("password")},
					{Name: "netrc_machine", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownloader_params λ.Object
						ϒnetrc_machine     = λargs[3]
						ϒpassword          λ.Object
						ϒpassword_option   = λargs[2]
						ϒself              = λargs[0]
						ϒusername          λ.Object
						ϒusername_option   = λargs[1]
						τmp0               λ.Object
					)
					λ.NewStr("\n        Get the login info as (username, password)\n        First look for the manually specified credentials using username_option\n        and password_option as keys in params dictionary. If no such credentials\n        available look in the netrc file using the netrc_machine or _NETRC_MACHINE\n        value.\n        If there's no info available, return (None, None)\n        ")
					if λ.IsTrue(λ.NewBool(λ.GetAttr(ϒself, "_downloader", nil) == λ.None)) {
						return λ.NewTuple(
							λ.None,
							λ.None,
						)
					}
					ϒdownloader_params = λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil)
					if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒdownloader_params, "get", nil), ϒusername_option) != λ.None)) {
						ϒusername = λ.GetItem(ϒdownloader_params, ϒusername_option)
						ϒpassword = λ.GetItem(ϒdownloader_params, ϒpassword_option)
					} else {
						τmp0 = λ.Cal(λ.GetAttr(ϒself, "_get_netrc_login_info", nil), ϒnetrc_machine)
						ϒusername = λ.GetItem(τmp0, λ.NewInt(0))
						ϒpassword = λ.GetItem(τmp0, λ.NewInt(1))
					}
					return λ.NewTuple(
						ϒusername,
						ϒpassword,
					)
				})
			InfoExtractor__og_regexes = λ.NewFunction("_og_regexes",
				[]λ.Param{
					{Name: "prop"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent_re  λ.Object
						ϒprop        = λargs[0]
						ϒproperty_re λ.Object
						ϒtemplate    λ.Object
					)
					ϒcontent_re = λ.NewStr("content=(?:\"([^\"]+?)\"|\\'([^\\']+?)\\'|\\s*([^\\s\"\\'=<>`]+?))")
					ϒproperty_re = λ.Mod(λ.NewStr("(?:name|property)=(?:\\'og:%(prop)s\\'|\"og:%(prop)s\"|\\s*og:%(prop)s\\b)"), λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("prop"): λ.Cal(Ωre.ϒescape, ϒprop),
					}))
					ϒtemplate = λ.NewStr("<meta[^>]+?%s[^>]+?%s")
					return λ.NewList(
						λ.Mod(ϒtemplate, λ.NewTuple(
							ϒproperty_re,
							ϒcontent_re,
						)),
						λ.Mod(ϒtemplate, λ.NewTuple(
							ϒcontent_re,
							ϒproperty_re,
						)),
					)
				})
			InfoExtractor__og_regexes = λ.Cal(λ.StaticMethodType, InfoExtractor__og_regexes)
			InfoExtractor__meta_regex = λ.NewFunction("_meta_regex",
				[]λ.Param{
					{Name: "prop"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒprop = λargs[0]
					)
					return λ.Mod(λ.NewStr("(?isx)<meta\n                    (?=[^>]+(?:itemprop|name|property|id|http-equiv)=([\"\\']?)%s\\1)\n                    [^>]+?content=([\"\\'])(?P<content>.*?)\\2"), λ.Cal(Ωre.ϒescape, ϒprop))
				})
			InfoExtractor__meta_regex = λ.Cal(λ.StaticMethodType, InfoExtractor__meta_regex)
			InfoExtractor__og_search_property = λ.NewFunction("_og_search_property",
				[]λ.Param{
					{Name: "self"},
					{Name: "prop"},
					{Name: "html"},
					{Name: "name", Def: λ.None},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒescaped    λ.Object
						ϒhtml       = λargs[2]
						ϒkargs      = λargs[4]
						ϒname       = λargs[3]
						ϒog_regexes λ.Object
						ϒp          λ.Object
						ϒprop       = λargs[1]
						ϒself       = λargs[0]
						τmp0        λ.Object
						τmp1        λ.Object
					)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒprop, λ.NewTuple(
						λ.ListType,
						λ.TupleType,
					))))) {
						ϒprop = λ.NewList(ϒprop)
					}
					if λ.IsTrue(λ.NewBool(ϒname == λ.None)) {
						ϒname = λ.Mod(λ.NewStr("OpenGraph %s"), λ.GetItem(ϒprop, λ.NewInt(0)))
					}
					ϒog_regexes = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒprop)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒp = τmp1
						λ.Cal(λ.GetAttr(ϒog_regexes, "extend", nil), λ.Cal(λ.GetAttr(ϒself, "_og_regexes", nil), ϒp))
					}
					ϒescaped = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						ϒog_regexes,
						ϒhtml,
						ϒname,
					), λ.KWArgs{
						{Name: "flags", Value: Ωre.DOTALL},
						{Name: "", Value: ϒkargs},
					})
					if λ.IsTrue(λ.NewBool(ϒescaped == λ.None)) {
						return λ.None
					}
					return λ.Cal(ϒunescapeHTML, ϒescaped)
				})
			InfoExtractor__og_search_thumbnail = λ.NewFunction("_og_search_thumbnail",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.NewStr("image"),
						ϒhtml,
						λ.NewStr("thumbnail URL"),
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_description = λ.NewFunction("_og_search_description",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.NewStr("description"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_title = λ.NewFunction("_og_search_title",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.NewStr("title"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_video_url = λ.NewFunction("_og_search_video_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
					{Name: "name", Def: λ.NewStr("video url")},
					{Name: "secure", Def: λ.True},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml    = λargs[1]
						ϒkargs   = λargs[4]
						ϒname    = λargs[2]
						ϒregexes λ.Object
						ϒsecure  = λargs[3]
						ϒself    = λargs[0]
					)
					ϒregexes = λ.Add(λ.Cal(λ.GetAttr(ϒself, "_og_regexes", nil), λ.NewStr("video")), λ.Cal(λ.GetAttr(ϒself, "_og_regexes", nil), λ.NewStr("video:url")))
					if λ.IsTrue(ϒsecure) {
						ϒregexes = λ.Add(λ.Cal(λ.GetAttr(ϒself, "_og_regexes", nil), λ.NewStr("video:secure_url")), ϒregexes)
					}
					return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						ϒregexes,
						ϒhtml,
						ϒname,
					), λ.KWArgs{
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_url = λ.NewFunction("_og_search_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.NewStr("url"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__html_search_meta = λ.NewFunction("_html_search_meta",
				[]λ.Param{
					{Name: "self"},
					{Name: "name"},
					{Name: "html"},
					{Name: "display_name", Def: λ.None},
					{Name: "fatal", Def: λ.False},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdisplay_name = λargs[3]
						ϒfatal        = λargs[4]
						ϒhtml         = λargs[2]
						ϒkwargs       = λargs[5]
						ϒname         = λargs[1]
						ϒself         = λargs[0]
					)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒname, λ.NewTuple(
						λ.ListType,
						λ.TupleType,
					))))) {
						ϒname = λ.NewList(ϒname)
					}
					if λ.IsTrue(λ.NewBool(ϒdisplay_name == λ.None)) {
						ϒdisplay_name = λ.GetItem(ϒname, λ.NewInt(0))
					}
					return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
									var (
										ϒn   λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒname)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒn = τmp1
										λgen.Yield(λ.Cal(λ.GetAttr(ϒself, "_meta_regex", nil), ϒn))
									}
									return λ.None
								})
							}))),
						ϒhtml,
						ϒdisplay_name,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "group", Value: λ.NewStr("content")},
						{Name: "", Value: ϒkwargs},
					})
				})
			InfoExtractor__rta_search = λ.NewFunction("_rta_search",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml = λargs[1]
						ϒself = λargs[0]
					)
					_ = ϒself
					if λ.IsTrue(λ.Cal(Ωre.ϒsearch, λ.NewStr("(?ix)<meta\\s+name=\"rating\"\\s+     content=\"RTA-5042-1996-1400-1577-RTA\""), ϒhtml)) {
						return λ.NewInt(18)
					}
					return λ.NewInt(0)
				})
			InfoExtractor__media_rating_search = λ.NewFunction("_media_rating_search",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						RATING_TABLE λ.Object
						ϒhtml        = λargs[1]
						ϒrating      λ.Object
						ϒself        = λargs[0]
					)
					ϒrating = λ.Cal(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewStr("rating"), ϒhtml)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒrating))) {
						return λ.None
					}
					RATING_TABLE = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("safe for kids"): λ.NewInt(0),
						λ.NewStr("general"):       λ.NewInt(8),
						λ.NewStr("14 years"):      λ.NewInt(14),
						λ.NewStr("mature"):        λ.NewInt(17),
						λ.NewStr("restricted"):    λ.NewInt(19),
					})
					return λ.Cal(λ.GetAttr(RATING_TABLE, "get", nil), λ.Cal(λ.GetAttr(ϒrating, "lower", nil)))
				})
			InfoExtractor__family_friendly_search = λ.NewFunction("_family_friendly_search",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						RATING_TABLE     λ.Object
						ϒfamily_friendly λ.Object
						ϒhtml            = λargs[1]
						ϒself            = λargs[0]
					)
					ϒfamily_friendly = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
						λ.NewStr("isFamilyFriendly"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒfamily_friendly))) {
						return λ.None
					}
					RATING_TABLE = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("1"):     λ.NewInt(0),
						λ.NewStr("true"):  λ.NewInt(0),
						λ.NewStr("0"):     λ.NewInt(18),
						λ.NewStr("false"): λ.NewInt(18),
					})
					return λ.Cal(λ.GetAttr(RATING_TABLE, "get", nil), λ.Cal(λ.GetAttr(ϒfamily_friendly, "lower", nil)))
				})
			InfoExtractor__search_json_ld = λ.NewFunction("_search_json_ld",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
					{Name: "video_id"},
					{Name: "expected_type", Def: λ.None},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdefault       λ.Object
						ϒexpected_type = λargs[3]
						ϒfatal         λ.Object
						ϒhtml          = λargs[1]
						ϒjson_ld       λ.Object
						ϒkwargs        = λargs[4]
						ϒself          = λargs[0]
						ϒvideo_id      = λargs[2]
					)
					ϒjson_ld = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						JSON_LD_RE,
						ϒhtml,
						λ.NewStr("JSON-LD"),
					), λ.KWArgs{
						{Name: "group", Value: λ.NewStr("json_ld")},
						{Name: "", Value: ϒkwargs},
					})
					ϒdefault = λ.Cal(λ.GetAttr(ϒkwargs, "get", nil), λ.NewStr("default"), NO_DEFAULT)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒjson_ld))) {
						return func() λ.Object {
							if λ.IsTrue(λ.NewBool(ϒdefault != NO_DEFAULT)) {
								return ϒdefault
							} else {
								return λ.NewDictWithTable(map[λ.Object]λ.Object{})
							}
						}()
					}
					ϒfatal = func() λ.Object {
						if λ.IsTrue(λ.Eq(ϒdefault, NO_DEFAULT)) {
							return λ.Cal(λ.GetAttr(ϒkwargs, "get", nil), λ.NewStr("fatal"), λ.True)
						} else {
							return λ.False
						}
					}()
					return λ.Call(λ.GetAttr(ϒself, "_json_ld", nil), λ.NewArgs(
						ϒjson_ld,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "expected_type", Value: ϒexpected_type},
					})
				})
			InfoExtractor__json_ld = λ.NewFunction("_json_ld",
				[]λ.Param{
					{Name: "self"},
					{Name: "json_ld"},
					{Name: "video_id"},
					{Name: "fatal", Def: λ.True},
					{Name: "expected_type", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						INTERACTION_TYPE_MAP           λ.Object
						ϒe                             λ.Object
						ϒepisode_name                  λ.Object
						ϒexpected_type                 = λargs[4]
						ϒextract_interaction_statistic λ.Object
						ϒextract_video_object          λ.Object
						ϒfatal                         = λargs[3]
						ϒinfo                          λ.Object
						ϒitem_type                     λ.Object
						ϒjson_ld                       = λargs[1]
						ϒpart_of_season                λ.Object
						ϒpart_of_series                λ.Object
						ϒself                          = λargs[0]
						ϒvideo                         λ.Object
						ϒvideo_id                      = λargs[2]
						τmp0                           λ.Object
						τmp1                           λ.Object
					)
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld, ϒcompat_str)) {
						ϒjson_ld = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							ϒjson_ld,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "fatal", Value: ϒfatal},
						})
					}
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒjson_ld))) {
						return λ.NewDictWithTable(map[λ.Object]λ.Object{})
					}
					ϒinfo = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld, λ.NewTuple(
						λ.ListType,
						λ.TupleType,
						λ.DictType,
					))))) {
						return ϒinfo
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld, λ.DictType)) {
						ϒjson_ld = λ.NewList(ϒjson_ld)
					}
					INTERACTION_TYPE_MAP = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("CommentAction"):  λ.NewStr("comment"),
						λ.NewStr("AgreeAction"):    λ.NewStr("like"),
						λ.NewStr("DisagreeAction"): λ.NewStr("dislike"),
						λ.NewStr("LikeAction"):     λ.NewStr("like"),
						λ.NewStr("DislikeAction"):  λ.NewStr("dislike"),
						λ.NewStr("ListenAction"):   λ.NewStr("view"),
						λ.NewStr("WatchAction"):    λ.NewStr("view"),
						λ.NewStr("ViewAction"):     λ.NewStr("view"),
					})
					ϒextract_interaction_statistic = λ.NewFunction("extract_interaction_statistic",
						[]λ.Param{
							{Name: "e"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcount_key             λ.Object
								ϒcount_kind            λ.Object
								ϒe                     = λargs[0]
								ϒinteraction_count     λ.Object
								ϒinteraction_statistic λ.Object
								ϒinteraction_type      λ.Object
								ϒis_e                  λ.Object
								τmp0                   λ.Object
								τmp1                   λ.Object
							)
							ϒinteraction_statistic = λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("interactionStatistic"))
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒinteraction_statistic, λ.ListType)))) {
								return λ.None
							}
							τmp0 = λ.Cal(λ.BuiltinIter, ϒinteraction_statistic)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒis_e = τmp1
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒis_e, λ.DictType)))) {
									continue
								}
								if λ.IsTrue(λ.Ne(λ.Cal(λ.GetAttr(ϒis_e, "get", nil), λ.NewStr("@type")), λ.NewStr("InteractionCounter"))) {
									continue
								}
								ϒinteraction_type = λ.Cal(λ.GetAttr(ϒis_e, "get", nil), λ.NewStr("interactionType"))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒinteraction_type, ϒcompat_str)))) {
									continue
								}
								ϒinteraction_count = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒis_e, "get", nil), λ.NewStr("userInteractionCount")))
								if λ.IsTrue(λ.NewBool(ϒinteraction_count == λ.None)) {
									continue
								}
								ϒcount_kind = λ.Cal(λ.GetAttr(INTERACTION_TYPE_MAP, "get", nil), λ.GetItem(λ.Cal(λ.GetAttr(ϒinteraction_type, "split", nil), λ.NewStr("/")), λ.Neg(λ.NewInt(1))))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒcount_kind))) {
									continue
								}
								ϒcount_key = λ.Mod(λ.NewStr("%s_count"), ϒcount_kind)
								if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒinfo, "get", nil), ϒcount_key) != λ.None)) {
									continue
								}
								λ.SetItem(ϒinfo, ϒcount_key, ϒinteraction_count)
							}
							return λ.None
						})
					ϒextract_video_object = λ.NewFunction("extract_video_object",
						[]λ.Param{
							{Name: "e"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒe = λargs[0]
							)
							if !λ.IsTrue(λ.Eq(λ.GetItem(ϒe, λ.NewStr("@type")), λ.NewStr("VideoObject"))) {
								panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
							}
							λ.Cal(λ.GetAttr(ϒinfo, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("url"):         λ.Cal(ϒurl_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("contentUrl"))),
								λ.NewStr("title"):       λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("name"))),
								λ.NewStr("description"): λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("description"))),
								λ.NewStr("thumbnail"): λ.Cal(ϒurl_or_none, func() λ.Object {
									if λv := λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("thumbnailUrl")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("thumbnailURL"))
									}
								}()),
								λ.NewStr("duration"):   λ.Cal(ϒparse_duration, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("duration"))),
								λ.NewStr("timestamp"):  λ.Cal(ϒunified_timestamp, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("uploadDate"))),
								λ.NewStr("filesize"):   λ.Cal(ϒfloat_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("contentSize"))),
								λ.NewStr("tbr"):        λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("bitrate"))),
								λ.NewStr("width"):      λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("width"))),
								λ.NewStr("height"):     λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("height"))),
								λ.NewStr("view_count"): λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("interactionCount"))),
							}))
							λ.Cal(ϒextract_interaction_statistic, ϒe)
							return λ.None
						})
					τmp0 = λ.Cal(λ.BuiltinIter, ϒjson_ld)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒe = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Cal(λ.BuiltinIsInstance, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("@context")), ϒcompat_str); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(Ωre.ϒmatch, λ.NewStr("^https?://schema.org/?$"), λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("@context")))
							}
						}()) {
							ϒitem_type = λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("@type"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(ϒexpected_type != λ.None); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Ne(ϒexpected_type, ϒitem_type)
								}
							}()) {
								return ϒinfo
							}
							if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
								λ.NewStr("TVEpisode"),
								λ.NewStr("Episode"),
							), ϒitem_type))) {
								ϒepisode_name = λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("name")))
								λ.Cal(λ.GetAttr(ϒinfo, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("episode"):        ϒepisode_name,
									λ.NewStr("episode_number"): λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("episodeNumber"))),
									λ.NewStr("description"):    λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("description"))),
								}))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒinfo, "get", nil), λ.NewStr("title")))); !λ.IsTrue(λv) {
										return λv
									} else {
										return ϒepisode_name
									}
								}()) {
									λ.SetItem(ϒinfo, λ.NewStr("title"), ϒepisode_name)
								}
								ϒpart_of_season = λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("partOfSeason"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.BuiltinIsInstance, ϒpart_of_season, λ.DictType); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("TVSeason"),
											λ.NewStr("Season"),
											λ.NewStr("CreativeWorkSeason"),
										), λ.Cal(λ.GetAttr(ϒpart_of_season, "get", nil), λ.NewStr("@type"))))
									}
								}()) {
									λ.SetItem(ϒinfo, λ.NewStr("season_number"), λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒpart_of_season, "get", nil), λ.NewStr("seasonNumber"))))
								}
								ϒpart_of_series = func() λ.Object {
									if λv := λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("partOfSeries")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("partOfTVSeries"))
									}
								}()
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.BuiltinIsInstance, ϒpart_of_series, λ.DictType); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("TVSeries"),
											λ.NewStr("Series"),
											λ.NewStr("CreativeWorkSeries"),
										), λ.Cal(λ.GetAttr(ϒpart_of_series, "get", nil), λ.NewStr("@type"))))
									}
								}()) {
									λ.SetItem(ϒinfo, λ.NewStr("series"), λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒpart_of_series, "get", nil), λ.NewStr("name"))))
								}
							} else {
								if λ.IsTrue(λ.Eq(ϒitem_type, λ.NewStr("Movie"))) {
									λ.Cal(λ.GetAttr(ϒinfo, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("title"):       λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("name"))),
										λ.NewStr("description"): λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("description"))),
										λ.NewStr("duration"):    λ.Cal(ϒparse_duration, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("duration"))),
										λ.NewStr("timestamp"):   λ.Cal(ϒunified_timestamp, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("dateCreated"))),
									}))
								} else {
									if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
										λ.NewStr("Article"),
										λ.NewStr("NewsArticle"),
									), ϒitem_type))) {
										λ.Cal(λ.GetAttr(ϒinfo, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("timestamp"):   λ.Cal(ϒparse_iso8601, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("datePublished"))),
											λ.NewStr("title"):       λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("headline"))),
											λ.NewStr("description"): λ.Cal(ϒunescapeHTML, λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("articleBody"))),
										}))
									} else {
										if λ.IsTrue(λ.Eq(ϒitem_type, λ.NewStr("VideoObject"))) {
											λ.Cal(ϒextract_video_object, ϒe)
											continue
										}
									}
								}
							}
							ϒvideo = λ.Cal(λ.GetAttr(ϒe, "get", nil), λ.NewStr("video"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.BuiltinIsInstance, ϒvideo, λ.DictType); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(λ.Cal(λ.GetAttr(ϒvideo, "get", nil), λ.NewStr("@type")), λ.NewStr("VideoObject"))
								}
							}()) {
								λ.Cal(ϒextract_video_object, ϒvideo)
							}
							break
						}
					}
					return λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
								var (
									ϒk   λ.Object
									ϒv   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
									τmp2 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒinfo, "items", nil)))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒk = λ.GetItem(τmp2, λ.NewInt(0))
									ϒv = λ.GetItem(τmp2, λ.NewInt(1))
									if λ.IsTrue(λ.NewBool(ϒv != λ.None)) {
										λgen.Yield(λ.NewTuple(
											ϒk,
											ϒv,
										))
									}
								}
								return λ.None
							})
						})))
				})
			InfoExtractor__hidden_inputs = λ.NewFunction("_hidden_inputs",
				[]λ.Param{
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒattrs         λ.Object
						ϒhidden_inputs λ.Object
						ϒhtml          = λargs[0]
						ϒinput         λ.Object
						ϒname          λ.Object
						ϒvalue         λ.Object
						τmp0           λ.Object
						τmp1           λ.Object
					)
					ϒhtml = λ.Cal(Ωre.ϒsub, λ.NewStr("<!--(?:(?!<!--).)*-->"), λ.NewStr(""), ϒhtml)
					ϒhidden_inputs = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.NewStr("(?i)(<input[^>]+>)"), ϒhtml))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒinput = τmp1
						ϒattrs = λ.Cal(ϒextract_attributes, ϒinput)
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒinput))) {
							continue
						}
						if λ.IsTrue(λ.NewBool(!λ.Contains(λ.NewTuple(
							λ.NewStr("hidden"),
							λ.NewStr("submit"),
						), λ.Cal(λ.GetAttr(ϒattrs, "get", nil), λ.NewStr("type"))))) {
							continue
						}
						ϒname = func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒattrs, "get", nil), λ.NewStr("name")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒattrs, "get", nil), λ.NewStr("id"))
							}
						}()
						ϒvalue = λ.Cal(λ.GetAttr(ϒattrs, "get", nil), λ.NewStr("value"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒname; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(ϒvalue != λ.None)
							}
						}()) {
							λ.SetItem(ϒhidden_inputs, ϒname, ϒvalue)
						}
					}
					return ϒhidden_inputs
				})
			InfoExtractor__hidden_inputs = λ.Cal(λ.StaticMethodType, InfoExtractor__hidden_inputs)
			InfoExtractor__sort_formats = λ.NewFunction("_sort_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "formats"},
					{Name: "field_preference", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_formats_key     λ.Object
						ϒf                λ.Object
						ϒfield_preference = λargs[2]
						ϒformats          = λargs[1]
						ϒself             = λargs[0]
						τmp0              λ.Object
						τmp1              λ.Object
					)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒformats))) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.NewStr("No video formats found"))))
					}
					τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒf = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.Contains(ϒf, λ.NewStr("tbr"))); !λ.IsTrue(λv) {
								return λv
							} else if λv := λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("abr")) != λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vbr")) != λ.None)
							}
						}()) {
							λ.SetItem(ϒf, λ.NewStr("tbr"), λ.Add(λ.GetItem(ϒf, λ.NewStr("abr")), λ.GetItem(ϒf, λ.NewStr("vbr"))))
						}
					}
					ϒ_formats_key = λ.NewFunction("_formats_key",
						[]λ.Param{
							{Name: "f"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ORDER                 λ.Object
								ϒaudio_ext_preference λ.Object
								ϒdetermine_ext        λ.Object
								ϒext_preference       λ.Object
								ϒf                    = λargs[0]
								ϒpreference           λ.Object
								ϒproto_preference     λ.Object
								ϒprotocol             λ.Object
								τmp0                  λ.Object
								τmp1                  λ.Object
							)
							_ = τmp0
							_ = τmp1
							ϒdetermine_ext = Ωutils.ϒdetermine_ext
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("ext")))); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Contains(ϒf, λ.NewStr("url")))
								}
							}()) {
								λ.SetItem(ϒf, λ.NewStr("ext"), λ.Cal(ϒdetermine_ext, λ.GetItem(ϒf, λ.NewStr("url"))))
							}
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒfield_preference, λ.NewTuple(
								λ.ListType,
								λ.TupleType,
							))) {
								return λ.Cal(λ.TupleType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
											var (
												ϒfield λ.Object
												τmp0   λ.Object
												τmp1   λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, ϒfield_preference)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒfield = τmp1
												λgen.Yield(func() λ.Object {
													if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), ϒfield) != λ.None)) {
														return λ.Cal(λ.GetAttr(ϒf, "get", nil), ϒfield)
													} else {
														return func() λ.Object {
															if λ.IsTrue(λ.Eq(ϒfield, λ.NewStr("format_id"))) {
																return λ.NewStr("")
															} else {
																return λ.Neg(λ.NewInt(1))
															}
														}()
													}
												}())
											}
											return λ.None
										})
									})))
							}
							ϒpreference = λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("preference"))
							if λ.IsTrue(λ.NewBool(ϒpreference == λ.None)) {
								ϒpreference = λ.NewInt(0)
								if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewList(
									λ.NewStr("f4f"),
									λ.NewStr("f4m"),
								), λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("ext"))))) {
									τmp0 = λ.ISub(ϒpreference, λ.NewFloat(0.5))
									ϒpreference = τmp0
								}
							}
							ϒprotocol = func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("protocol")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒdetermine_protocol, ϒf)
								}
							}()
							ϒproto_preference = func() λ.Object {
								if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewList(
									λ.NewStr("http"),
									λ.NewStr("https"),
								), ϒprotocol))) {
									return λ.NewInt(0)
								} else {
									return func() λ.Object {
										if λ.IsTrue(λ.Eq(ϒprotocol, λ.NewStr("rtsp"))) {
											return λ.Neg(λ.NewFloat(0.5))
										} else {
											return λ.Neg(λ.NewFloat(0.1))
										}
									}()
								}
							}()
							if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none"))) {
								τmp0 = λ.ISub(ϒpreference, λ.NewInt(50))
								ϒpreference = τmp0
								if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("prefer_free_formats"))) {
									ORDER = λ.NewList(
										λ.NewStr("aac"),
										λ.NewStr("mp3"),
										λ.NewStr("m4a"),
										λ.NewStr("webm"),
										λ.NewStr("ogg"),
										λ.NewStr("opus"),
									)
								} else {
									ORDER = λ.NewList(
										λ.NewStr("webm"),
										λ.NewStr("opus"),
										λ.NewStr("ogg"),
										λ.NewStr("mp3"),
										λ.NewStr("aac"),
										λ.NewStr("m4a"),
									)
								}
								ϒext_preference = λ.NewInt(0)
								τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
											ϒaudio_ext_preference = λ.Neg(λ.NewInt(1))
										}},
									)
									ϒaudio_ext_preference = λ.Cal(λ.GetAttr(ORDER, "index", nil), λ.GetItem(ϒf, λ.NewStr("ext")))
									return λ.BlockExitNormally, nil
								}()
							} else {
								if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("acodec")), λ.NewStr("none"))) {
									τmp1 = λ.ISub(ϒpreference, λ.NewInt(40))
									ϒpreference = τmp1
								}
								if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("prefer_free_formats"))) {
									ORDER = λ.NewList(
										λ.NewStr("flv"),
										λ.NewStr("mp4"),
										λ.NewStr("webm"),
									)
								} else {
									ORDER = λ.NewList(
										λ.NewStr("webm"),
										λ.NewStr("flv"),
										λ.NewStr("mp4"),
									)
								}
								τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
											ϒext_preference = λ.Neg(λ.NewInt(1))
										}},
									)
									ϒext_preference = λ.Cal(λ.GetAttr(ORDER, "index", nil), λ.GetItem(ϒf, λ.NewStr("ext")))
									return λ.BlockExitNormally, nil
								}()
								ϒaudio_ext_preference = λ.NewInt(0)
							}
							return λ.NewTuple(
								ϒpreference,
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("language_preference")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("language_preference"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("quality")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("quality"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("tbr")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("tbr"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("filesize")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("filesize"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vbr")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vbr"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("height")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("height"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("width")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("width"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								ϒproto_preference,
								ϒext_preference,
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("abr")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("abr"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								ϒaudio_ext_preference,
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("fps")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("fps"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("filesize_approx")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("filesize_approx"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("source_preference")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("source_preference"))
									} else {
										return λ.Neg(λ.NewInt(1))
									}
								}(),
								func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("format_id")) != λ.None)) {
										return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("format_id"))
									} else {
										return λ.NewStr("")
									}
								}(),
							)
						})
					λ.Call(λ.GetAttr(ϒformats, "sort", nil), nil, λ.KWArgs{
						{Name: "key", Value: ϒ_formats_key},
					})
					return λ.None
				})
			InfoExtractor__check_formats = λ.NewFunction("_check_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "formats"},
					{Name: "video_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒformats  = λargs[1]
						ϒself     = λargs[0]
						ϒvideo_id = λargs[2]
					)
					if λ.IsTrue(ϒformats) {
						λ.SetItem(ϒformats, λ.NewSlice(λ.None, λ.None, λ.None), λ.Cal(λ.FilterIteratorType, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "f"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒf = λargs[0]
								)
								return λ.Call(λ.GetAttr(ϒself, "_is_valid_url", nil), λ.NewArgs(
									λ.GetItem(ϒf, λ.NewStr("url")),
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "item", Value: func() λ.Object {
										if λ.IsTrue(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("format_id"))) {
											return λ.Mod(λ.NewStr("%s video format"), λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("format_id")))
										} else {
											return λ.NewStr("video")
										}
									}()},
								})
							}), ϒformats))
					}
					return λ.None
				})
			InfoExtractor__remove_duplicate_formats = λ.NewFunction("_remove_duplicate_formats",
				[]λ.Param{
					{Name: "formats"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf              λ.Object
						ϒformat_urls    λ.Object
						ϒformats        = λargs[0]
						ϒunique_formats λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
					)
					ϒformat_urls = λ.Cal(λ.SetType)
					ϒunique_formats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒf = τmp1
						if λ.IsTrue(λ.NewBool(!λ.Contains(ϒformat_urls, λ.GetItem(ϒf, λ.NewStr("url"))))) {
							λ.Cal(λ.GetAttr(ϒformat_urls, "add", nil), λ.GetItem(ϒf, λ.NewStr("url")))
							λ.Cal(λ.GetAttr(ϒunique_formats, "append", nil), ϒf)
						}
					}
					λ.SetItem(ϒformats, λ.NewSlice(λ.None, λ.None, λ.None), ϒunique_formats)
					return λ.None
				})
			InfoExtractor__remove_duplicate_formats = λ.Cal(λ.StaticMethodType, InfoExtractor__remove_duplicate_formats)
			InfoExtractor__is_valid_url = λ.NewFunction("_is_valid_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "video_id"},
					{Name: "item", Def: λ.NewStr("video")},
					{Name: "headers", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒheaders  = λargs[4]
						ϒitem     = λargs[3]
						ϒself     = λargs[0]
						ϒurl      = λargs[1]
						ϒvideo_id = λargs[2]
						τmp0      λ.Object
						τmp1      λ.Object
					)
					ϒurl = λ.Call(λ.GetAttr(ϒself, "_proto_relative_url", nil), λ.NewArgs(ϒurl), λ.KWArgs{
						{Name: "scheme", Value: λ.NewStr("http:")},
					})
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(func() λ.Object {
						if λv := λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("http://")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("https://"))
						}
					}()))) {
						return λ.True
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
								ϒe := λex
								if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, λ.GetAttr(ϒe, "cause", nil), Ωerror.URLError)) {
									λ.Cal(λ.GetAttr(ϒself, "to_screen", nil), λ.Mod(λ.NewStr("%s: %s URL is invalid, skipping"), λ.NewTuple(
										ϒvideo_id,
										ϒitem,
									)))
									λexit, λret = λ.BlockExitReturn, λ.False
									return
								}
								panic(λ.Raise(λex))
							}},
						)
						λ.Call(λ.GetAttr(ϒself, "_request_webpage", nil), λ.NewArgs(
							ϒurl,
							ϒvideo_id,
							λ.Mod(λ.NewStr("Checking %s URL"), ϒitem),
						), λ.KWArgs{
							{Name: "headers", Value: ϒheaders},
						})
						λexit, λret = λ.BlockExitReturn, λ.True
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor_http_scheme = λ.NewFunction("http_scheme",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.NewStr(" Either \"http:\" or \"https:\", depending on the user's preferences ")
					return func() λ.Object {
						if λ.IsTrue(λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("prefer_insecure"), λ.False)) {
							return λ.NewStr("http:")
						} else {
							return λ.NewStr("https:")
						}
					}()
				})
			InfoExtractor__proto_relative_url = λ.NewFunction("_proto_relative_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "scheme", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒscheme = λargs[2]
						ϒself   = λargs[0]
						ϒurl    = λargs[1]
					)
					if λ.IsTrue(λ.NewBool(ϒurl == λ.None)) {
						return ϒurl
					}
					if λ.IsTrue(λ.Cal(λ.GetAttr(ϒurl, "startswith", nil), λ.NewStr("//"))) {
						if λ.IsTrue(λ.NewBool(ϒscheme == λ.None)) {
							ϒscheme = λ.Cal(λ.GetAttr(ϒself, "http_scheme", nil))
						}
						return λ.Add(ϒscheme, ϒurl)
					} else {
						return ϒurl
					}
					return λ.None
				})
			InfoExtractor__extract_f4m_formats = λ.NewFunction("_extract_f4m_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "manifest_url"},
					{Name: "video_id"},
					{Name: "preference", Def: λ.None},
					{Name: "f4m_id", Def: λ.None},
					{Name: "transform_source", Def: λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "s"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒs = λargs[0]
							)
							return λ.Cal(λ.GetAttr(λ.Cal(ϒfix_xml_ampersands, ϒs), "strip", nil))
						})},
					{Name: "fatal", Def: λ.True},
					{Name: "m3u8_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf4m_id           = λargs[4]
						ϒfatal            = λargs[6]
						ϒm3u8_id          = λargs[7]
						ϒmanifest         λ.Object
						ϒmanifest_url     = λargs[1]
						ϒpreference       = λargs[3]
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒvideo_id         = λargs[2]
					)
					ϒmanifest = λ.Call(λ.GetAttr(ϒself, "_download_xml", nil), λ.NewArgs(
						ϒmanifest_url,
						ϒvideo_id,
						λ.NewStr("Downloading f4m manifest"),
						λ.NewStr("Unable to download f4m manifest"),
					), λ.KWArgs{
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
					})
					if λ.IsTrue(λ.NewBool(ϒmanifest == λ.False)) {
						return λ.NewList()
					}
					return λ.Call(λ.GetAttr(ϒself, "_parse_f4m_formats", nil), λ.NewArgs(
						ϒmanifest,
						ϒmanifest_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "preference", Value: ϒpreference},
						{Name: "f4m_id", Value: ϒf4m_id},
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "m3u8_id", Value: ϒm3u8_id},
					})
				})
			InfoExtractor__parse_f4m_formats = λ.NewFunction("_parse_f4m_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "manifest"},
					{Name: "manifest_url"},
					{Name: "video_id"},
					{Name: "preference", Def: λ.None},
					{Name: "f4m_id", Def: λ.None},
					{Name: "transform_source", Def: λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "s"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒs = λargs[0]
							)
							return λ.Cal(λ.GetAttr(λ.Cal(ϒfix_xml_ampersands, ϒs), "strip", nil))
						})},
					{Name: "fatal", Def: λ.True},
					{Name: "m3u8_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒakamai_pv                   λ.Object
						ϒbootstrap_info              λ.Object
						ϒext                         λ.Object
						ϒf                           λ.Object
						ϒf4m_formats                 λ.Object
						ϒf4m_id                      = λargs[5]
						ϒfatal                       = λargs[7]
						ϒformat_id                   λ.Object
						ϒformats                     λ.Object
						ϒheight                      λ.Object
						ϒi                           λ.Object
						ϒm3u8_id                     = λargs[8]
						ϒmanifest                    = λargs[1]
						ϒmanifest_base_url           λ.Object
						ϒmanifest_url                = λargs[2]
						ϒmanifest_version            λ.Object
						ϒmedia_el                    λ.Object
						ϒmedia_nodes                 λ.Object
						ϒmedia_url                   λ.Object
						ϒmime_type                   λ.Object
						ϒplayerVerificationChallenge λ.Object
						ϒpreference                  = λargs[4]
						ϒself                        = λargs[0]
						ϒtbr                         λ.Object
						ϒtransform_source            = λargs[6]
						ϒvcodec                      λ.Object
						ϒvideo_id                    = λargs[3]
						ϒwidth                       λ.Object
						τmp0                         λ.Object
						τmp1                         λ.Object
						τmp2                         λ.Object
					)
					ϒakamai_pv = λ.Cal(λ.GetAttr(ϒmanifest, "find", nil), λ.NewStr("{http://ns.adobe.com/f4m/1.0}pv-2.0"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(ϒakamai_pv != λ.None); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(λ.GetAttr(ϒakamai_pv, "text", nil), λ.NewStr(";")))
						}
					}()) {
						ϒplayerVerificationChallenge = λ.GetItem(λ.Cal(λ.GetAttr(λ.GetAttr(ϒakamai_pv, "text", nil), "split", nil), λ.NewStr(";")), λ.NewInt(0))
						if λ.IsTrue(λ.Ne(λ.Cal(λ.GetAttr(ϒplayerVerificationChallenge, "strip", nil)), λ.NewStr(""))) {
							return λ.NewList()
						}
					}
					ϒformats = λ.NewList()
					ϒmanifest_version = λ.NewStr("1.0")
					ϒmedia_nodes = λ.Cal(λ.GetAttr(ϒmanifest, "findall", nil), λ.NewStr("{http://ns.adobe.com/f4m/1.0}media"))
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒmedia_nodes))) {
						ϒmanifest_version = λ.NewStr("2.0")
						ϒmedia_nodes = λ.Cal(λ.GetAttr(ϒmanifest, "findall", nil), λ.NewStr("{http://ns.adobe.com/f4m/2.0}media"))
					}
					ϒmedia_nodes = λ.Cal(ϒremove_encrypted_media, ϒmedia_nodes)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒmedia_nodes))) {
						return ϒformats
					}
					ϒmanifest_base_url = λ.Cal(ϒget_base_url, ϒmanifest)
					ϒbootstrap_info = λ.Call(ϒxpath_element, λ.NewArgs(
						ϒmanifest,
						λ.NewList(
							λ.NewStr("{http://ns.adobe.com/f4m/1.0}bootstrapInfo"),
							λ.NewStr("{http://ns.adobe.com/f4m/2.0}bootstrapInfo"),
						),
						λ.NewStr("bootstrap info"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒvcodec = λ.None
					ϒmime_type = λ.Call(ϒxpath_text, λ.NewArgs(
						ϒmanifest,
						λ.NewList(
							λ.NewStr("{http://ns.adobe.com/f4m/1.0}mimeType"),
							λ.NewStr("{http://ns.adobe.com/f4m/2.0}mimeType"),
						),
						λ.NewStr("base URL"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(func() λ.Object {
						if λv := ϒmime_type; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.GetAttr(ϒmime_type, "startswith", nil), λ.NewStr("audio/"))
						}
					}()) {
						ϒvcodec = λ.NewStr("none")
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒmedia_nodes))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒi = λ.GetItem(τmp2, λ.NewInt(0))
						ϒmedia_el = λ.GetItem(τmp2, λ.NewInt(1))
						ϒtbr = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", nil), λ.NewStr("bitrate")))
						ϒwidth = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", nil), λ.NewStr("width")))
						ϒheight = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", nil), λ.NewStr("height")))
						ϒformat_id = λ.Cal(λ.GetAttr(λ.NewStr("-"), "join", nil), λ.Cal(λ.FilterIteratorType, λ.None, λ.NewList(
							ϒf4m_id,
							λ.Cal(ϒcompat_str, func() λ.Object {
								if λ.IsTrue(λ.NewBool(ϒtbr == λ.None)) {
									return ϒi
								} else {
									return ϒtbr
								}
							}()),
						)))
						if λ.IsTrue(λ.NewBool(ϒbootstrap_info == λ.None)) {
							ϒmedia_url = λ.None
							if λ.IsTrue(λ.Eq(ϒmanifest_version, λ.NewStr("2.0"))) {
								ϒmedia_url = λ.Cal(λ.GetAttr(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", nil), λ.NewStr("href"))
							}
							if λ.IsTrue(λ.NewBool(ϒmedia_url == λ.None)) {
								ϒmedia_url = λ.Cal(λ.GetAttr(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", nil), λ.NewStr("url"))
							}
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒmedia_url))) {
								continue
							}
							ϒmanifest_url = func() λ.Object {
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.GetAttr(ϒmedia_url, "startswith", nil), λ.NewStr("http://")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.GetAttr(ϒmedia_url, "startswith", nil), λ.NewStr("https://"))
									}
								}()) {
									return ϒmedia_url
								} else {
									return λ.Add(λ.Add(func() λ.Object {
										if λv := ϒmanifest_base_url; λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.GetAttr(λ.NewStr("/"), "join", nil), λ.GetItem(λ.Cal(λ.GetAttr(ϒmanifest_url, "split", nil), λ.NewStr("/")), λ.NewSlice(λ.None, λ.Neg(λ.NewInt(1)), λ.None)))
										}
									}(), λ.NewStr("/")), ϒmedia_url)
								}
							}()
							ϒext = λ.Cal(ϒdetermine_ext, ϒmanifest_url)
							if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("f4m"))) {
								ϒf4m_formats = λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
									ϒmanifest_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "preference", Value: ϒpreference},
									{Name: "f4m_id", Value: ϒf4m_id},
									{Name: "transform_source", Value: ϒtransform_source},
									{Name: "fatal", Value: ϒfatal},
								})
								if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒf4m_formats), λ.NewInt(1))) {
									ϒf = λ.GetItem(ϒf4m_formats, λ.NewInt(0))
									λ.Cal(λ.GetAttr(ϒf, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("tbr"): func() λ.Object {
											if λv := λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("tbr")); λ.IsTrue(λv) {
												return λv
											} else {
												return ϒtbr
											}
										}(),
										λ.NewStr("width"): func() λ.Object {
											if λv := λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("width")); λ.IsTrue(λv) {
												return λv
											} else {
												return ϒwidth
											}
										}(),
										λ.NewStr("height"): func() λ.Object {
											if λv := λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("height")); λ.IsTrue(λv) {
												return λv
											} else {
												return ϒheight
											}
										}(),
										λ.NewStr("format_id"): func() λ.Object {
											if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒtbr))) {
												return λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("format_id"))
											} else {
												return ϒformat_id
											}
										}(),
										λ.NewStr("vcodec"): ϒvcodec,
									}))
								}
								λ.Cal(λ.GetAttr(ϒformats, "extend", nil), ϒf4m_formats)
								continue
							} else {
								if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("m3u8"))) {
									λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
										ϒmanifest_url,
										ϒvideo_id,
										λ.NewStr("mp4"),
									), λ.KWArgs{
										{Name: "preference", Value: ϒpreference},
										{Name: "m3u8_id", Value: ϒm3u8_id},
										{Name: "fatal", Value: ϒfatal},
									}))
									continue
								}
							}
						}
						λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("format_id"):    ϒformat_id,
							λ.NewStr("url"):          ϒmanifest_url,
							λ.NewStr("manifest_url"): ϒmanifest_url,
							λ.NewStr("ext"): func() λ.Object {
								if λ.IsTrue(λ.NewBool(ϒbootstrap_info != λ.None)) {
									return λ.NewStr("flv")
								} else {
									return λ.None
								}
							}(),
							λ.NewStr("protocol"):   λ.NewStr("f4m"),
							λ.NewStr("tbr"):        ϒtbr,
							λ.NewStr("width"):      ϒwidth,
							λ.NewStr("height"):     ϒheight,
							λ.NewStr("vcodec"):     ϒvcodec,
							λ.NewStr("preference"): ϒpreference,
						}))
					}
					return ϒformats
				})
			InfoExtractor__extract_m3u8_formats = λ.NewFunction("_extract_m3u8_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "m3u8_url"},
					{Name: "video_id"},
					{Name: "ext", Def: λ.None},
					{Name: "entry_protocol", Def: λ.NewStr("m3u8")},
					{Name: "preference", Def: λ.None},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "live", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒentry_protocol = λargs[4]
						ϒerrnote        = λargs[8]
						ϒext            = λargs[3]
						ϒfatal          = λargs[9]
						ϒlive           = λargs[10]
						ϒm3u8_doc       λ.Object
						ϒm3u8_id        = λargs[6]
						ϒm3u8_url       = λargs[1]
						ϒnote           = λargs[7]
						ϒpreference     = λargs[5]
						ϒres            λ.Object
						ϒself           = λargs[0]
						ϒurlh           λ.Object
						ϒvideo_id       = λargs[2]
						τmp0            λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒm3u8_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("Downloading m3u8 information")
							}
						}()},
						{Name: "errnote", Value: func() λ.Object {
							if λv := ϒerrnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("Failed to download m3u8 information")
							}
						}()},
						{Name: "fatal", Value: ϒfatal},
					})
					if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
						return λ.NewList()
					}
					τmp0 = ϒres
					ϒm3u8_doc = λ.GetItem(τmp0, λ.NewInt(0))
					ϒurlh = λ.GetItem(τmp0, λ.NewInt(1))
					ϒm3u8_url = λ.Cal(λ.GetAttr(ϒurlh, "geturl", nil))
					return λ.Call(λ.GetAttr(ϒself, "_parse_m3u8_formats", nil), λ.NewArgs(
						ϒm3u8_doc,
						ϒm3u8_url,
					), λ.KWArgs{
						{Name: "ext", Value: ϒext},
						{Name: "entry_protocol", Value: ϒentry_protocol},
						{Name: "preference", Value: ϒpreference},
						{Name: "m3u8_id", Value: ϒm3u8_id},
						{Name: "live", Value: ϒlive},
					})
				})
			InfoExtractor__parse_m3u8_formats = λ.NewFunction("_parse_m3u8_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "m3u8_doc"},
					{Name: "m3u8_url"},
					{Name: "ext", Def: λ.None},
					{Name: "entry_protocol", Def: λ.NewStr("m3u8")},
					{Name: "preference", Def: λ.None},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "live", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabr               λ.Object
						ϒaudio_group       λ.Object
						ϒaudio_group_id    λ.Object
						ϒbuild_stream_name λ.Object
						ϒcodecs            λ.Object
						ϒentry_protocol    = λargs[4]
						ϒext               = λargs[3]
						ϒextract_media     λ.Object
						ϒf                 λ.Object
						ϒformat_id         λ.Object
						ϒformat_url        λ.Object
						ϒformats           λ.Object
						ϒgroups            λ.Object
						ϒlast_stream_inf   λ.Object
						ϒline              λ.Object
						ϒlive              = λargs[7]
						ϒm3u8_doc          = λargs[1]
						ϒm3u8_id           = λargs[6]
						ϒm3u8_url          = λargs[2]
						ϒmanifest_url      λ.Object
						ϒmobj              λ.Object
						ϒpreference        = λargs[5]
						ϒresolution        λ.Object
						ϒself              = λargs[0]
						ϒstream_name       λ.Object
						ϒtbr               λ.Object
						ϒvbr               λ.Object
						τmp0               λ.Object
						τmp1               λ.Object
						τmp2               λ.Object
					)
					_ = ϒself
					if λ.IsTrue(λ.NewBool(λ.Contains(ϒm3u8_doc, λ.NewStr("#EXT-X-FAXS-CM:")))) {
						return λ.NewList()
					}
					if λ.IsTrue(λ.Cal(Ωre.ϒsearch, λ.NewStr("#EXT-X-SESSION-KEY:.*?URI=\"skd://"), ϒm3u8_doc)) {
						return λ.NewList()
					}
					ϒformats = λ.NewList()
					ϒformat_url = λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "u"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒu = λargs[0]
							)
							return func() λ.Object {
								if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^https?://"), ϒu)) {
									return ϒu
								} else {
									return λ.Cal(Ωparse.ϒurljoin, ϒm3u8_url, ϒu)
								}
							}()
						})
					if λ.IsTrue(λ.NewBool(λ.Contains(ϒm3u8_doc, λ.NewStr("#EXT-X-TARGETDURATION")))) {
						return λ.NewList(λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("url"):        ϒm3u8_url,
							λ.NewStr("format_id"):  ϒm3u8_id,
							λ.NewStr("ext"):        ϒext,
							λ.NewStr("protocol"):   ϒentry_protocol,
							λ.NewStr("preference"): ϒpreference,
						}))
					}
					ϒgroups = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					ϒlast_stream_inf = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					ϒextract_media = λ.NewFunction("extract_media",
						[]λ.Param{
							{Name: "x_media_line"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒf            λ.Object
								ϒformat_id    λ.Object
								ϒgroup_id     λ.Object
								ϒmedia        λ.Object
								ϒmedia_type   λ.Object
								ϒmedia_url    λ.Object
								ϒname         λ.Object
								ϒv            λ.Object
								ϒx_media_line = λargs[0]
								τmp0          λ.Object
								τmp1          λ.Object
							)
							ϒmedia = λ.Cal(ϒparse_m3u8_attributes, ϒx_media_line)
							τmp0 = λ.NewTuple(
								λ.Cal(λ.GetAttr(ϒmedia, "get", nil), λ.NewStr("TYPE")),
								λ.Cal(λ.GetAttr(ϒmedia, "get", nil), λ.NewStr("GROUP-ID")),
								λ.Cal(λ.GetAttr(ϒmedia, "get", nil), λ.NewStr("NAME")),
							)
							ϒmedia_type = λ.GetItem(τmp0, λ.NewInt(0))
							ϒgroup_id = λ.GetItem(τmp0, λ.NewInt(1))
							ϒname = λ.GetItem(τmp0, λ.NewInt(2))
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(func() λ.Object {
								if λv := ϒmedia_type; !λ.IsTrue(λv) {
									return λv
								} else if λv := ϒgroup_id; !λ.IsTrue(λv) {
									return λv
								} else {
									return ϒname
								}
							}()))) {
								return λ.None
							}
							λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒgroups, "setdefault", nil), ϒgroup_id, λ.NewList()), "append", nil), ϒmedia)
							if λ.IsTrue(λ.NewBool(!λ.Contains(λ.NewTuple(
								λ.NewStr("VIDEO"),
								λ.NewStr("AUDIO"),
							), ϒmedia_type))) {
								return λ.None
							}
							ϒmedia_url = λ.Cal(λ.GetAttr(ϒmedia, "get", nil), λ.NewStr("URI"))
							if λ.IsTrue(ϒmedia_url) {
								ϒformat_id = λ.NewList()
								τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
									ϒm3u8_id,
									ϒgroup_id,
									ϒname,
								))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒv = τmp1
									if λ.IsTrue(ϒv) {
										λ.Cal(λ.GetAttr(ϒformat_id, "append", nil), ϒv)
									}
								}
								ϒf = λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("format_id"):    λ.Cal(λ.GetAttr(λ.NewStr("-"), "join", nil), ϒformat_id),
									λ.NewStr("url"):          λ.Cal(ϒformat_url, ϒmedia_url),
									λ.NewStr("manifest_url"): ϒm3u8_url,
									λ.NewStr("language"):     λ.Cal(λ.GetAttr(ϒmedia, "get", nil), λ.NewStr("LANGUAGE")),
									λ.NewStr("ext"):          ϒext,
									λ.NewStr("protocol"):     ϒentry_protocol,
									λ.NewStr("preference"):   ϒpreference,
								})
								if λ.IsTrue(λ.Eq(ϒmedia_type, λ.NewStr("AUDIO"))) {
									λ.SetItem(ϒf, λ.NewStr("vcodec"), λ.NewStr("none"))
								}
								λ.Cal(λ.GetAttr(ϒformats, "append", nil), ϒf)
							}
							return λ.None
						})
					ϒbuild_stream_name = λ.NewFunction("build_stream_name",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒrendition       λ.Object
								ϒstream_group    λ.Object
								ϒstream_group_id λ.Object
								ϒstream_name     λ.Object
							)
							ϒstream_name = λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("NAME"))
							if λ.IsTrue(ϒstream_name) {
								return ϒstream_name
							}
							ϒstream_group_id = λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("VIDEO"))
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒstream_group_id))) {
								return λ.None
							}
							ϒstream_group = λ.Cal(λ.GetAttr(ϒgroups, "get", nil), ϒstream_group_id)
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒstream_group))) {
								return ϒstream_group_id
							}
							ϒrendition = λ.GetItem(ϒstream_group, λ.NewInt(0))
							return func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒrendition, "get", nil), λ.NewStr("NAME")); λ.IsTrue(λv) {
									return λv
								} else {
									return ϒstream_group_id
								}
							}()
						})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒm3u8_doc, "splitlines", nil)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒline = τmp1
						if λ.IsTrue(λ.Cal(λ.GetAttr(ϒline, "startswith", nil), λ.NewStr("#EXT-X-STREAM-INF:"))) {
							ϒlast_stream_inf = λ.Cal(ϒparse_m3u8_attributes, ϒline)
						} else {
							if λ.IsTrue(λ.Cal(λ.GetAttr(ϒline, "startswith", nil), λ.NewStr("#EXT-X-MEDIA:"))) {
								λ.Cal(ϒextract_media, ϒline)
							} else {
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.GetAttr(ϒline, "startswith", nil), λ.NewStr("#")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒline, "strip", nil))))
									}
								}()) {
									continue
								} else {
									ϒtbr = λ.Call(ϒfloat_or_none, λ.NewArgs(func() λ.Object {
										if λv := λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("AVERAGE-BANDWIDTH")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("BANDWIDTH"))
										}
									}()), λ.KWArgs{
										{Name: "scale", Value: λ.NewInt(1000)},
									})
									ϒformat_id = λ.NewList()
									if λ.IsTrue(ϒm3u8_id) {
										λ.Cal(λ.GetAttr(ϒformat_id, "append", nil), ϒm3u8_id)
									}
									ϒstream_name = λ.Cal(ϒbuild_stream_name)
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒlive))) {
										λ.Cal(λ.GetAttr(ϒformat_id, "append", nil), func() λ.Object {
											if λ.IsTrue(ϒstream_name) {
												return ϒstream_name
											} else {
												return λ.Mod(λ.NewStr("%d"), func() λ.Object {
													if λ.IsTrue(ϒtbr) {
														return ϒtbr
													} else {
														return λ.Cal(λ.BuiltinLen, ϒformats)
													}
												}())
											}
										}())
									}
									ϒmanifest_url = λ.Cal(ϒformat_url, λ.Cal(λ.GetAttr(ϒline, "strip", nil)))
									ϒf = λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("format_id"):    λ.Cal(λ.GetAttr(λ.NewStr("-"), "join", nil), ϒformat_id),
										λ.NewStr("url"):          ϒmanifest_url,
										λ.NewStr("manifest_url"): ϒm3u8_url,
										λ.NewStr("tbr"):          ϒtbr,
										λ.NewStr("ext"):          ϒext,
										λ.NewStr("fps"):          λ.Cal(ϒfloat_or_none, λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("FRAME-RATE"))),
										λ.NewStr("protocol"):     ϒentry_protocol,
										λ.NewStr("preference"):   ϒpreference,
									})
									ϒresolution = λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("RESOLUTION"))
									if λ.IsTrue(ϒresolution) {
										ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("(?P<width>\\d+)[xX](?P<height>\\d+)"), ϒresolution)
										if λ.IsTrue(ϒmobj) {
											λ.SetItem(ϒf, λ.NewStr("width"), λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("width"))))
											λ.SetItem(ϒf, λ.NewStr("height"), λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒmobj, "group", nil), λ.NewStr("height"))))
										}
									}
									ϒmobj = λ.Cal(Ωre.ϒsearch, λ.NewStr("audio.*?(?:%3D|=)(\\d+)(?:-video.*?(?:%3D|=)(\\d+))?"), λ.GetItem(ϒf, λ.NewStr("url")))
									if λ.IsTrue(ϒmobj) {
										τmp2 = λ.Cal(λ.GetAttr(ϒmobj, "groups", nil))
										ϒabr = λ.GetItem(τmp2, λ.NewInt(0))
										ϒvbr = λ.GetItem(τmp2, λ.NewInt(1))
										τmp2 = λ.NewTuple(
											λ.Cal(ϒfloat_or_none, ϒabr, λ.NewInt(1000)),
											λ.Cal(ϒfloat_or_none, ϒvbr, λ.NewInt(1000)),
										)
										ϒabr = λ.GetItem(τmp2, λ.NewInt(0))
										ϒvbr = λ.GetItem(τmp2, λ.NewInt(1))
										λ.Cal(λ.GetAttr(ϒf, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("vbr"): ϒvbr,
											λ.NewStr("abr"): ϒabr,
										}))
									}
									ϒcodecs = λ.Cal(ϒparse_codecs, λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("CODECS")))
									λ.Cal(λ.GetAttr(ϒf, "update", nil), ϒcodecs)
									ϒaudio_group_id = λ.Cal(λ.GetAttr(ϒlast_stream_inf, "get", nil), λ.NewStr("AUDIO"))
									if λ.IsTrue(func() λ.Object {
										if λv := ϒaudio_group_id; !λ.IsTrue(λv) {
											return λv
										} else if λv := ϒcodecs; !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Ne(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("vcodec")), λ.NewStr("none"))
										}
									}()) {
										ϒaudio_group = λ.Cal(λ.GetAttr(ϒgroups, "get", nil), ϒaudio_group_id)
										if λ.IsTrue(func() λ.Object {
											if λv := ϒaudio_group; !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Cal(λ.GetAttr(λ.GetItem(ϒaudio_group, λ.NewInt(0)), "get", nil), λ.NewStr("URI"))
											}
										}()) {
											λ.SetItem(ϒf, λ.NewStr("acodec"), λ.NewStr("none"))
										}
									}
									λ.Cal(λ.GetAttr(ϒformats, "append", nil), ϒf)
									ϒlast_stream_inf = λ.NewDictWithTable(map[λ.Object]λ.Object{})
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__xpath_ns = λ.NewFunction("_xpath_ns",
				[]λ.Param{
					{Name: "path"},
					{Name: "namespace", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒc         λ.Object
						ϒnamespace = λargs[1]
						ϒout       λ.Object
						ϒpath      = λargs[0]
						τmp0       λ.Object
						τmp1       λ.Object
					)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒnamespace))) {
						return ϒpath
					}
					ϒout = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒpath, "split", nil), λ.NewStr("/")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒc = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒc)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒc, λ.NewStr("."))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒout, "append", nil), ϒc)
						} else {
							λ.Cal(λ.GetAttr(ϒout, "append", nil), λ.Mod(λ.NewStr("{%s}%s"), λ.NewTuple(
								ϒnamespace,
								ϒc,
							)))
						}
					}
					return λ.Cal(λ.GetAttr(λ.NewStr("/"), "join", nil), ϒout)
				})
			InfoExtractor__xpath_ns = λ.Cal(λ.StaticMethodType, InfoExtractor__xpath_ns)
			InfoExtractor__extract_smil_formats = λ.NewFunction("_extract_smil_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil_url"},
					{Name: "video_id"},
					{Name: "fatal", Def: λ.True},
					{Name: "f4m_params", Def: λ.None},
					{Name: "transform_source", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf4m_params       = λargs[4]
						ϒfatal            = λargs[3]
						ϒnamespace        λ.Object
						ϒself             = λargs[0]
						ϒsmil             λ.Object
						ϒsmil_url         = λargs[1]
						ϒtransform_source = λargs[5]
						ϒvideo_id         = λargs[2]
					)
					ϒsmil = λ.Call(λ.GetAttr(ϒself, "_download_smil", nil), λ.NewArgs(
						ϒsmil_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "transform_source", Value: ϒtransform_source},
					})
					if λ.IsTrue(λ.NewBool(ϒsmil == λ.False)) {
						if !λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒfatal))) {
							panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
						}
						return λ.NewList()
					}
					ϒnamespace = λ.Cal(λ.GetAttr(ϒself, "_parse_smil_namespace", nil), ϒsmil)
					return λ.Call(λ.GetAttr(ϒself, "_parse_smil_formats", nil), λ.NewArgs(
						ϒsmil,
						ϒsmil_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "namespace", Value: ϒnamespace},
						{Name: "f4m_params", Value: ϒf4m_params},
					})
				})
			InfoExtractor__download_smil = λ.NewFunction("_download_smil",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil_url"},
					{Name: "video_id"},
					{Name: "fatal", Def: λ.True},
					{Name: "transform_source", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal            = λargs[3]
						ϒself             = λargs[0]
						ϒsmil_url         = λargs[1]
						ϒtransform_source = λargs[4]
						ϒvideo_id         = λargs[2]
					)
					return λ.Call(λ.GetAttr(ϒself, "_download_xml", nil), λ.NewArgs(
						ϒsmil_url,
						ϒvideo_id,
						λ.NewStr("Downloading SMIL file"),
						λ.NewStr("Unable to download SMIL file"),
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "transform_source", Value: ϒtransform_source},
					})
				})
			InfoExtractor__parse_smil_namespace = λ.NewFunction("_parse_smil_namespace",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
						ϒsmil = λargs[1]
					)
					return λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewStr("(?i)^{([^}]+)?}smil$"),
						λ.GetAttr(ϒsmil, "tag", nil),
						λ.NewStr("namespace"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
				})
			InfoExtractor__parse_smil_formats = λ.NewFunction("_parse_smil_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil"},
					{Name: "smil_url"},
					{Name: "video_id"},
					{Name: "namespace", Def: λ.None},
					{Name: "f4m_params", Def: λ.None},
					{Name: "transform_rtmp_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒb                  λ.Object
						ϒbase               λ.Object
						ϒbitrate            λ.Object
						ϒext                λ.Object
						ϒf4m_params         = λargs[5]
						ϒf4m_url            λ.Object
						ϒfilesize           λ.Object
						ϒformats            λ.Object
						ϒheight             λ.Object
						ϒhttp_count         λ.Object
						ϒm3u8_count         λ.Object
						ϒm3u8_formats       λ.Object
						ϒmedia              λ.Object
						ϒmedium             λ.Object
						ϒmeta               λ.Object
						ϒnamespace          = λargs[4]
						ϒproto              λ.Object
						ϒrtmp_count         λ.Object
						ϒself               = λargs[0]
						ϒsmil               = λargs[1]
						ϒsmil_url           = λargs[2]
						ϒsrc                λ.Object
						ϒsrc_ext            λ.Object
						ϒsrc_url            λ.Object
						ϒsrcs               λ.Object
						ϒstreamer           λ.Object
						ϒtransform_rtmp_url = λargs[6]
						ϒvideo_id           = λargs[3]
						ϒwidth              λ.Object
						τmp0                λ.Object
						τmp1                λ.Object
						τmp2                λ.Object
					)
					ϒbase = ϒsmil_url
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒsmil, "findall", nil), λ.Cal(λ.GetAttr(ϒself, "_xpath_ns", nil), λ.NewStr("./head/meta"), ϒnamespace)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmeta = τmp1
						ϒb = func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒmeta, "get", nil), λ.NewStr("base")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒmeta, "get", nil), λ.NewStr("httpBase"))
							}
						}()
						if λ.IsTrue(ϒb) {
							ϒbase = ϒb
							break
						}
					}
					ϒformats = λ.NewList()
					ϒrtmp_count = λ.NewInt(0)
					ϒhttp_count = λ.NewInt(0)
					ϒm3u8_count = λ.NewInt(0)
					ϒsrcs = λ.NewList()
					ϒmedia = λ.Add(λ.Cal(λ.GetAttr(ϒsmil, "findall", nil), λ.Cal(λ.GetAttr(ϒself, "_xpath_ns", nil), λ.NewStr(".//video"), ϒnamespace)), λ.Cal(λ.GetAttr(ϒsmil, "findall", nil), λ.Cal(λ.GetAttr(ϒself, "_xpath_ns", nil), λ.NewStr(".//audio"), ϒnamespace)))
					τmp0 = λ.Cal(λ.BuiltinIter, ϒmedia)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmedium = τmp1
						ϒsrc = λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("src"))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒsrc)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒsrcs, ϒsrc))
							}
						}()) {
							continue
						}
						λ.Cal(λ.GetAttr(ϒsrcs, "append", nil), ϒsrc)
						ϒbitrate = λ.Cal(ϒfloat_or_none, func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("system-bitrate")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("systemBitrate"))
							}
						}(), λ.NewInt(1000))
						ϒfilesize = λ.Cal(ϒint_or_none, func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("size")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("fileSize"))
							}
						}())
						ϒwidth = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("width")))
						ϒheight = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("height")))
						ϒproto = λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("proto"))
						ϒext = λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("ext"))
						ϒsrc_ext = λ.Cal(ϒdetermine_ext, ϒsrc)
						ϒstreamer = func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒmedium, "get", nil), λ.NewStr("streamer")); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒbase
							}
						}()
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒproto, λ.NewStr("rtmp")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.GetAttr(ϒstreamer, "startswith", nil), λ.NewStr("rtmp"))
							}
						}()) {
							τmp2 = λ.IAdd(ϒrtmp_count, λ.NewInt(1))
							ϒrtmp_count = τmp2
							λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("url"):       ϒstreamer,
								λ.NewStr("play_path"): ϒsrc,
								λ.NewStr("ext"):       λ.NewStr("flv"),
								λ.NewStr("format_id"): λ.Mod(λ.NewStr("rtmp-%d"), func() λ.Object {
									if λ.IsTrue(λ.NewBool(ϒbitrate == λ.None)) {
										return ϒrtmp_count
									} else {
										return ϒbitrate
									}
								}()),
								λ.NewStr("tbr"):      ϒbitrate,
								λ.NewStr("filesize"): ϒfilesize,
								λ.NewStr("width"):    ϒwidth,
								λ.NewStr("height"):   ϒheight,
							}))
							if λ.IsTrue(ϒtransform_rtmp_url) {
								τmp2 = λ.Cal(ϒtransform_rtmp_url, ϒstreamer, ϒsrc)
								ϒstreamer = λ.GetItem(τmp2, λ.NewInt(0))
								ϒsrc = λ.GetItem(τmp2, λ.NewInt(1))
								λ.Cal(λ.GetAttr(λ.GetItem(ϒformats, λ.Neg(λ.NewInt(1))), "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("url"):       ϒstreamer,
									λ.NewStr("play_path"): ϒsrc,
								}))
							}
							continue
						}
						ϒsrc_url = func() λ.Object {
							if λ.IsTrue(λ.Cal(λ.GetAttr(ϒsrc, "startswith", nil), λ.NewStr("http"))) {
								return ϒsrc
							} else {
								return λ.Cal(Ωparse.ϒurljoin, ϒbase, ϒsrc)
							}
						}()
						ϒsrc_url = λ.Cal(λ.GetAttr(ϒsrc_url, "strip", nil))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒproto, λ.NewStr("m3u8")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒsrc_ext, λ.NewStr("m3u8"))
							}
						}()) {
							ϒm3u8_formats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
								ϒsrc_url,
								ϒvideo_id,
								func() λ.Object {
									if λv := ϒext; λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewStr("mp4")
									}
								}(),
							), λ.KWArgs{
								{Name: "m3u8_id", Value: λ.NewStr("hls")},
								{Name: "fatal", Value: λ.False},
							})
							if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒm3u8_formats), λ.NewInt(1))) {
								τmp2 = λ.IAdd(ϒm3u8_count, λ.NewInt(1))
								ϒm3u8_count = τmp2
								λ.Cal(λ.GetAttr(λ.GetItem(ϒm3u8_formats, λ.NewInt(0)), "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("format_id"): λ.Mod(λ.NewStr("hls-%d"), func() λ.Object {
										if λ.IsTrue(λ.NewBool(ϒbitrate == λ.None)) {
											return ϒm3u8_count
										} else {
											return ϒbitrate
										}
									}()),
									λ.NewStr("tbr"):    ϒbitrate,
									λ.NewStr("width"):  ϒwidth,
									λ.NewStr("height"): ϒheight,
								}))
							}
							λ.Cal(λ.GetAttr(ϒformats, "extend", nil), ϒm3u8_formats)
						} else {
							if λ.IsTrue(λ.Eq(ϒsrc_ext, λ.NewStr("f4m"))) {
								ϒf4m_url = ϒsrc_url
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒf4m_params))) {
									ϒf4m_params = λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("hdcore"): λ.NewStr("3.2.0"),
										λ.NewStr("plugin"): λ.NewStr("flowplayer-3.2.0.1"),
									})
								}
								τmp2 = λ.IAdd(ϒf4m_url, func() λ.Object {
									if λ.IsTrue(λ.NewBool(λ.Contains(ϒf4m_url, λ.NewStr("?")))) {
										return λ.NewStr("&")
									} else {
										return λ.NewStr("?")
									}
								}())
								ϒf4m_url = τmp2
								τmp2 = λ.IAdd(ϒf4m_url, λ.Cal(ϒcompat_urllib_parse_urlencode, ϒf4m_params))
								ϒf4m_url = τmp2
								λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
									ϒf4m_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "f4m_id", Value: λ.NewStr("hds")},
									{Name: "fatal", Value: λ.False},
								}))
							} else {
								if λ.IsTrue(λ.Eq(ϒsrc_ext, λ.NewStr("mpd"))) {
									λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
										ϒsrc_url,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "mpd_id", Value: λ.NewStr("dash")},
										{Name: "fatal", Value: λ.False},
									}))
								} else {
									if λ.IsTrue(λ.Cal(Ωre.ϒsearch, λ.NewStr("\\.ism/[Mm]anifest"), ϒsrc_url)) {
										λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_ism_formats", nil), λ.NewArgs(
											ϒsrc_url,
											ϒvideo_id,
										), λ.KWArgs{
											{Name: "ism_id", Value: λ.NewStr("mss")},
											{Name: "fatal", Value: λ.False},
										}))
									} else {
										if λ.IsTrue(func() λ.Object {
											if λv := λ.Cal(λ.GetAttr(ϒsrc_url, "startswith", nil), λ.NewStr("http")); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Cal(λ.GetAttr(ϒself, "_is_valid_url", nil), ϒsrc, ϒvideo_id)
											}
										}()) {
											τmp2 = λ.IAdd(ϒhttp_count, λ.NewInt(1))
											ϒhttp_count = τmp2
											λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
												λ.NewStr("url"): ϒsrc_url,
												λ.NewStr("ext"): func() λ.Object {
													if λv := ϒext; λ.IsTrue(λv) {
														return λv
													} else if λv := ϒsrc_ext; λ.IsTrue(λv) {
														return λv
													} else {
														return λ.NewStr("flv")
													}
												}(),
												λ.NewStr("format_id"): λ.Mod(λ.NewStr("http-%d"), func() λ.Object {
													if λv := ϒbitrate; λ.IsTrue(λv) {
														return λv
													} else {
														return ϒhttp_count
													}
												}()),
												λ.NewStr("tbr"):      ϒbitrate,
												λ.NewStr("filesize"): ϒfilesize,
												λ.NewStr("width"):    ϒwidth,
												λ.NewStr("height"):   ϒheight,
											}))
										}
									}
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__extract_mpd_formats = λ.NewFunction("_extract_mpd_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "mpd_url"},
					{Name: "video_id"},
					{Name: "mpd_id", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "formats_dict", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerrnote      = λargs[5]
						ϒfatal        = λargs[6]
						ϒformats_dict = λargs[7]
						ϒmpd_base_url λ.Object
						ϒmpd_doc      λ.Object
						ϒmpd_id       = λargs[3]
						ϒmpd_url      = λargs[1]
						ϒnote         = λargs[4]
						ϒres          λ.Object
						ϒself         = λargs[0]
						ϒurlh         λ.Object
						ϒvideo_id     = λargs[2]
						τmp0          λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_xml_handle", nil), λ.NewArgs(
						ϒmpd_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("Downloading MPD manifest")
							}
						}()},
						{Name: "errnote", Value: func() λ.Object {
							if λv := ϒerrnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("Failed to download MPD manifest")
							}
						}()},
						{Name: "fatal", Value: ϒfatal},
					})
					if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
						return λ.NewList()
					}
					τmp0 = ϒres
					ϒmpd_doc = λ.GetItem(τmp0, λ.NewInt(0))
					ϒurlh = λ.GetItem(τmp0, λ.NewInt(1))
					ϒmpd_base_url = λ.Cal(ϒbase_url, λ.Cal(λ.GetAttr(ϒurlh, "geturl", nil)))
					return λ.Call(λ.GetAttr(ϒself, "_parse_mpd_formats", nil), λ.NewArgs(ϒmpd_doc), λ.KWArgs{
						{Name: "mpd_id", Value: ϒmpd_id},
						{Name: "mpd_base_url", Value: ϒmpd_base_url},
						{Name: "formats_dict", Value: ϒformats_dict},
						{Name: "mpd_url", Value: ϒmpd_url},
					})
				})
			InfoExtractor__parse_mpd_formats = λ.NewFunction("_parse_mpd_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "mpd_doc"},
					{Name: "mpd_id", Def: λ.None},
					{Name: "mpd_base_url", Def: λ.NewStr("")},
					{Name: "formats_dict", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
					{Name: "mpd_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_add_ns                   λ.Object
						ϒadaptation_set            λ.Object
						ϒadaption_set_ms_info      λ.Object
						ϒadd_segment_url           λ.Object
						ϒbandwidth                 λ.Object
						ϒbase_url                  λ.Object
						ϒbase_url_e                λ.Object
						ϒcontent_type              λ.Object
						ϒduration                  λ.Object
						ϒelement                   λ.Object
						ϒextract_multisegment_info λ.Object
						ϒf                         λ.Object
						ϒfilesize                  λ.Object
						ϒformats                   λ.Object
						ϒformats_dict              = λargs[4]
						ϒfragment                  λ.Object
						ϒfragments                 λ.Object
						ϒfull_info                 λ.Object
						ϒinitialization_template   λ.Object
						ϒinitialization_url        λ.Object
						ϒis_drm_protected          λ.Object
						ϒlang                      λ.Object
						ϒlocation_key              λ.Object
						ϒmedia_location_key        λ.Object
						ϒmedia_template            λ.Object
						ϒmime_type                 λ.Object
						ϒmpd_base_url              = λargs[3]
						ϒmpd_doc                   = λargs[1]
						ϒmpd_duration              λ.Object
						ϒmpd_id                    = λargs[2]
						ϒmpd_url                   = λargs[5]
						ϒnamespace                 λ.Object
						ϒnum                       λ.Object
						ϒperiod                    λ.Object
						ϒperiod_duration           λ.Object
						ϒperiod_ms_info            λ.Object
						ϒprepare_template          λ.Object
						ϒr                         λ.Object
						ϒrepresentation            λ.Object
						ϒrepresentation_attrib     λ.Object
						ϒrepresentation_id         λ.Object
						ϒrepresentation_ms_info    λ.Object
						ϒs                         λ.Object
						ϒsegment_d                 λ.Object
						ϒsegment_duration          λ.Object
						ϒsegment_index             λ.Object
						ϒsegment_number            λ.Object
						ϒsegment_time              λ.Object
						ϒsegment_uri               λ.Object
						ϒsegment_url               λ.Object
						ϒself                      = λargs[0]
						ϒtimescale                 λ.Object
						ϒurl_el                    λ.Object
						τmp0                       λ.Object
						τmp1                       λ.Object
						τmp10                      λ.Object
						τmp2                       λ.Object
						τmp3                       λ.Object
						τmp4                       λ.Object
						τmp5                       λ.Object
						τmp6                       λ.Object
						τmp7                       λ.Object
						τmp8                       λ.Object
						τmp9                       λ.Object
					)
					_ = ϒnum
					_ = ϒr
					λ.NewStr("\n        Parse formats from MPD manifest.\n        References:\n         1. MPEG-DASH Standard, ISO/IEC 23009-1:2014(E),\n            http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip\n         2. https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP\n        ")
					if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒmpd_doc, "get", nil), λ.NewStr("type")), λ.NewStr("dynamic"))) {
						return λ.NewList()
					}
					ϒnamespace = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewStr("(?i)^{([^}]+)?}MPD$"),
						λ.GetAttr(ϒmpd_doc, "tag", nil),
						λ.NewStr("namespace"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒ_add_ns = λ.NewFunction("_add_ns",
						[]λ.Param{
							{Name: "path"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒpath = λargs[0]
							)
							return λ.Cal(λ.GetAttr(ϒself, "_xpath_ns", nil), ϒpath, ϒnamespace)
						})
					ϒis_drm_protected = λ.NewFunction("is_drm_protected",
						[]λ.Param{
							{Name: "element"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒelement = λargs[0]
							)
							return λ.NewBool(λ.Cal(λ.GetAttr(ϒelement, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("ContentProtection"))) != λ.None)
						})
					ϒextract_multisegment_info = λ.NewFunction("extract_multisegment_info",
						[]λ.Param{
							{Name: "element"},
							{Name: "ms_parent_info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒelement                = λargs[0]
								ϒextract_Initialization λ.Object
								ϒextract_common         λ.Object
								ϒinitialization         λ.Object
								ϒmedia                  λ.Object
								ϒms_info                λ.Object
								ϒms_parent_info         = λargs[1]
								ϒsegment_list           λ.Object
								ϒsegment_template       λ.Object
								ϒsegment_urls_e         λ.Object
							)
							ϒms_info = λ.Cal(λ.GetAttr(ϒms_parent_info, "copy", nil))
							ϒextract_common = λ.NewFunction("extract_common",
								[]λ.Param{
									{Name: "source"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒr                λ.Object
										ϒs                λ.Object
										ϒs_e              λ.Object
										ϒsegment_duration λ.Object
										ϒsegment_timeline λ.Object
										ϒsource           = λargs[0]
										ϒstart_number     λ.Object
										ϒtimescale        λ.Object
										τmp0              λ.Object
										τmp1              λ.Object
										τmp2              λ.Object
									)
									ϒsegment_timeline = λ.Cal(λ.GetAttr(ϒsource, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("SegmentTimeline")))
									if λ.IsTrue(λ.NewBool(ϒsegment_timeline != λ.None)) {
										ϒs_e = λ.Cal(λ.GetAttr(ϒsegment_timeline, "findall", nil), λ.Cal(ϒ_add_ns, λ.NewStr("S")))
										if λ.IsTrue(ϒs_e) {
											λ.SetItem(ϒms_info, λ.NewStr("total_number"), λ.NewInt(0))
											λ.SetItem(ϒms_info, λ.NewStr("s"), λ.NewList())
											τmp0 = λ.Cal(λ.BuiltinIter, ϒs_e)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒs = τmp1
												ϒr = λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒs, "get", nil), λ.NewStr("r"), λ.NewInt(0)))
												τmp2 = λ.IAdd(λ.GetItem(ϒms_info, λ.NewStr("total_number")), λ.Add(λ.NewInt(1), ϒr))
												λ.SetItem(ϒms_info, λ.NewStr("total_number"), τmp2)
												λ.Cal(λ.GetAttr(λ.GetItem(ϒms_info, λ.NewStr("s")), "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
													λ.NewStr("t"): λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(ϒs, "get", nil), λ.NewStr("t"), λ.NewInt(0))),
													λ.NewStr("d"): λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(ϒs, "attrib", nil), λ.NewStr("d"))),
													λ.NewStr("r"): ϒr,
												}))
											}
										}
									}
									ϒstart_number = λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("startNumber"))
									if λ.IsTrue(ϒstart_number) {
										λ.SetItem(ϒms_info, λ.NewStr("start_number"), λ.Cal(λ.IntType, ϒstart_number))
									}
									ϒtimescale = λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("timescale"))
									if λ.IsTrue(ϒtimescale) {
										λ.SetItem(ϒms_info, λ.NewStr("timescale"), λ.Cal(λ.IntType, ϒtimescale))
									}
									ϒsegment_duration = λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("duration"))
									if λ.IsTrue(ϒsegment_duration) {
										λ.SetItem(ϒms_info, λ.NewStr("segment_duration"), λ.Cal(λ.FloatType, ϒsegment_duration))
									}
									return λ.None
								})
							ϒextract_Initialization = λ.NewFunction("extract_Initialization",
								[]λ.Param{
									{Name: "source"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒinitialization λ.Object
										ϒsource         = λargs[0]
									)
									ϒinitialization = λ.Cal(λ.GetAttr(ϒsource, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("Initialization")))
									if λ.IsTrue(λ.NewBool(ϒinitialization != λ.None)) {
										λ.SetItem(ϒms_info, λ.NewStr("initialization_url"), λ.GetItem(λ.GetAttr(ϒinitialization, "attrib", nil), λ.NewStr("sourceURL")))
									}
									return λ.None
								})
							ϒsegment_list = λ.Cal(λ.GetAttr(ϒelement, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("SegmentList")))
							if λ.IsTrue(λ.NewBool(ϒsegment_list != λ.None)) {
								λ.Cal(ϒextract_common, ϒsegment_list)
								λ.Cal(ϒextract_Initialization, ϒsegment_list)
								ϒsegment_urls_e = λ.Cal(λ.GetAttr(ϒsegment_list, "findall", nil), λ.Cal(ϒ_add_ns, λ.NewStr("SegmentURL")))
								if λ.IsTrue(ϒsegment_urls_e) {
									λ.SetItem(ϒms_info, λ.NewStr("segment_urls"), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
										nil,
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
												var (
													ϒsegment λ.Object
													τmp0     λ.Object
													τmp1     λ.Object
												)
												τmp0 = λ.Cal(λ.BuiltinIter, ϒsegment_urls_e)
												for {
													if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
														break
													}
													ϒsegment = τmp1
													λgen.Yield(λ.GetItem(λ.GetAttr(ϒsegment, "attrib", nil), λ.NewStr("media")))
												}
												return λ.None
											})
										}))))
								}
							} else {
								ϒsegment_template = λ.Cal(λ.GetAttr(ϒelement, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("SegmentTemplate")))
								if λ.IsTrue(λ.NewBool(ϒsegment_template != λ.None)) {
									λ.Cal(ϒextract_common, ϒsegment_template)
									ϒmedia = λ.Cal(λ.GetAttr(ϒsegment_template, "get", nil), λ.NewStr("media"))
									if λ.IsTrue(ϒmedia) {
										λ.SetItem(ϒms_info, λ.NewStr("media"), ϒmedia)
									}
									ϒinitialization = λ.Cal(λ.GetAttr(ϒsegment_template, "get", nil), λ.NewStr("initialization"))
									if λ.IsTrue(ϒinitialization) {
										λ.SetItem(ϒms_info, λ.NewStr("initialization"), ϒinitialization)
									} else {
										λ.Cal(ϒextract_Initialization, ϒsegment_template)
									}
								}
							}
							return ϒms_info
						})
					ϒmpd_duration = λ.Cal(ϒparse_duration, λ.Cal(λ.GetAttr(ϒmpd_doc, "get", nil), λ.NewStr("mediaPresentationDuration")))
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒmpd_doc, "findall", nil), λ.Cal(ϒ_add_ns, λ.NewStr("Period"))))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒperiod = τmp1
						ϒperiod_duration = func() λ.Object {
							if λv := λ.Cal(ϒparse_duration, λ.Cal(λ.GetAttr(ϒperiod, "get", nil), λ.NewStr("duration"))); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒmpd_duration
							}
						}()
						ϒperiod_ms_info = λ.Cal(ϒextract_multisegment_info, ϒperiod, λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("start_number"): λ.NewInt(1),
							λ.NewStr("timescale"):    λ.NewInt(1),
						}))
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒperiod, "findall", nil), λ.Cal(ϒ_add_ns, λ.NewStr("AdaptationSet"))))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒadaptation_set = τmp3
							if λ.IsTrue(λ.Cal(ϒis_drm_protected, ϒadaptation_set)) {
								continue
							}
							ϒadaption_set_ms_info = λ.Cal(ϒextract_multisegment_info, ϒadaptation_set, ϒperiod_ms_info)
							τmp4 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒadaptation_set, "findall", nil), λ.Cal(ϒ_add_ns, λ.NewStr("Representation"))))
							for {
								if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
									break
								}
								ϒrepresentation = τmp5
								if λ.IsTrue(λ.Cal(ϒis_drm_protected, ϒrepresentation)) {
									continue
								}
								ϒrepresentation_attrib = λ.Cal(λ.GetAttr(λ.GetAttr(ϒadaptation_set, "attrib", nil), "copy", nil))
								λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "update", nil), λ.GetAttr(ϒrepresentation, "attrib", nil))
								ϒmime_type = λ.GetItem(ϒrepresentation_attrib, λ.NewStr("mimeType"))
								ϒcontent_type = λ.GetItem(λ.Cal(λ.GetAttr(ϒmime_type, "split", nil), λ.NewStr("/")), λ.NewInt(0))
								if λ.IsTrue(λ.Eq(ϒcontent_type, λ.NewStr("text"))) {
									// pass
								} else {
									if λ.IsTrue(λ.NewBool(λ.Contains(λ.NewTuple(
										λ.NewStr("video"),
										λ.NewStr("audio"),
									), ϒcontent_type))) {
										ϒbase_url = λ.NewStr("")
										τmp6 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
											ϒrepresentation,
											ϒadaptation_set,
											ϒperiod,
											ϒmpd_doc,
										))
										for {
											if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
												break
											}
											ϒelement = τmp7
											ϒbase_url_e = λ.Cal(λ.GetAttr(ϒelement, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("BaseURL")))
											if λ.IsTrue(λ.NewBool(ϒbase_url_e != λ.None)) {
												ϒbase_url = λ.Add(λ.GetAttr(ϒbase_url_e, "text", nil), ϒbase_url)
												if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^https?://"), ϒbase_url)) {
													break
												}
											}
										}
										if λ.IsTrue(func() λ.Object {
											if λv := ϒmpd_base_url; !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(!λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^https?://"), ϒbase_url)))
											}
										}()) {
											if λ.IsTrue(func() λ.Object {
												if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒmpd_base_url, "endswith", nil), λ.NewStr("/")))); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒbase_url, "startswith", nil), λ.NewStr("/"))))
												}
											}()) {
												τmp6 = λ.IAdd(ϒmpd_base_url, λ.NewStr("/"))
												ϒmpd_base_url = τmp6
											}
											ϒbase_url = λ.Add(ϒmpd_base_url, ϒbase_url)
										}
										ϒrepresentation_id = λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("id"))
										ϒlang = λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("lang"))
										ϒurl_el = λ.Cal(λ.GetAttr(ϒrepresentation, "find", nil), λ.Cal(ϒ_add_ns, λ.NewStr("BaseURL")))
										ϒfilesize = λ.Cal(ϒint_or_none, func() λ.Object {
											if λ.IsTrue(λ.NewBool(ϒurl_el != λ.None)) {
												return λ.Cal(λ.GetAttr(λ.GetAttr(ϒurl_el, "attrib", nil), "get", nil), λ.NewStr("{http://youtube.com/yt/2012/10/10}contentLength"))
											} else {
												return λ.None
											}
										}())
										ϒbandwidth = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("bandwidth")))
										ϒf = λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("format_id"): func() λ.Object {
												if λ.IsTrue(ϒmpd_id) {
													return λ.Mod(λ.NewStr("%s-%s"), λ.NewTuple(
														ϒmpd_id,
														ϒrepresentation_id,
													))
												} else {
													return ϒrepresentation_id
												}
											}(),
											λ.NewStr("url"):          ϒbase_url,
											λ.NewStr("manifest_url"): ϒmpd_url,
											λ.NewStr("ext"):          λ.Cal(ϒmimetype2ext, ϒmime_type),
											λ.NewStr("width"):        λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("width"))),
											λ.NewStr("height"):       λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("height"))),
											λ.NewStr("tbr"):          λ.Cal(ϒfloat_or_none, ϒbandwidth, λ.NewInt(1000)),
											λ.NewStr("asr"):          λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("audioSamplingRate"))),
											λ.NewStr("fps"):          λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("frameRate"))),
											λ.NewStr("language"): func() λ.Object {
												if λ.IsTrue(λ.NewBool(!λ.Contains(λ.NewTuple(
													λ.NewStr("mul"),
													λ.NewStr("und"),
													λ.NewStr("zxx"),
													λ.NewStr("mis"),
												), ϒlang))) {
													return ϒlang
												} else {
													return λ.None
												}
											}(),
											λ.NewStr("format_note"): λ.Mod(λ.NewStr("DASH %s"), ϒcontent_type),
											λ.NewStr("filesize"):    ϒfilesize,
											λ.NewStr("container"):   λ.Add(λ.Cal(ϒmimetype2ext, ϒmime_type), λ.NewStr("_dash")),
										})
										λ.Cal(λ.GetAttr(ϒf, "update", nil), λ.Cal(ϒparse_codecs, λ.Cal(λ.GetAttr(ϒrepresentation_attrib, "get", nil), λ.NewStr("codecs"))))
										ϒrepresentation_ms_info = λ.Cal(ϒextract_multisegment_info, ϒrepresentation, ϒadaption_set_ms_info)
										ϒprepare_template = λ.NewFunction("prepare_template",
											[]λ.Param{
												{Name: "template_name"},
												{Name: "identifiers"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒc             λ.Object
													ϒidentifiers   = λargs[1]
													ϒin_template   λ.Object
													ϒt             λ.Object
													ϒtemplate_name = λargs[0]
													ϒtmpl          λ.Object
													τmp0           λ.Object
													τmp1           λ.Object
													τmp2           λ.Object
												)
												ϒtmpl = λ.GetItem(ϒrepresentation_ms_info, ϒtemplate_name)
												ϒt = λ.NewStr("")
												ϒin_template = λ.False
												τmp0 = λ.Cal(λ.BuiltinIter, ϒtmpl)
												for {
													if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
														break
													}
													ϒc = τmp1
													τmp2 = λ.IAdd(ϒt, ϒc)
													ϒt = τmp2
													if λ.IsTrue(λ.Eq(ϒc, λ.NewStr("$"))) {
														ϒin_template = λ.NewBool(!λ.IsTrue(ϒin_template))
													} else {
														if λ.IsTrue(func() λ.Object {
															if λv := λ.Eq(ϒc, λ.NewStr("%")); !λ.IsTrue(λv) {
																return λv
															} else {
																return λ.NewBool(!λ.IsTrue(ϒin_template))
															}
														}()) {
															τmp2 = λ.IAdd(ϒt, ϒc)
															ϒt = τmp2
														}
													}
												}
												ϒt = λ.Cal(λ.GetAttr(ϒt, "replace", nil), λ.NewStr("$RepresentationID$"), ϒrepresentation_id)
												ϒt = λ.Cal(Ωre.ϒsub, λ.Mod(λ.NewStr("\\$(%s)\\$"), λ.Cal(λ.GetAttr(λ.NewStr("|"), "join", nil), ϒidentifiers)), λ.NewStr("%(\\1)d"), ϒt)
												ϒt = λ.Cal(Ωre.ϒsub, λ.Mod(λ.NewStr("\\$(%s)%%([^$]+)\\$"), λ.Cal(λ.GetAttr(λ.NewStr("|"), "join", nil), ϒidentifiers)), λ.NewStr("%(\\1)\\2"), ϒt)
												λ.Cal(λ.GetAttr(ϒt, "replace", nil), λ.NewStr("$$"), λ.NewStr("$"))
												return ϒt
											})
										if λ.IsTrue(λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("initialization")))) {
											ϒinitialization_template = λ.Cal(ϒprepare_template, λ.NewStr("initialization"), λ.NewTuple(λ.NewStr("Bandwidth")))
											λ.SetItem(ϒrepresentation_ms_info, λ.NewStr("initialization_url"), λ.Mod(ϒinitialization_template, λ.NewDictWithTable(map[λ.Object]λ.Object{
												λ.NewStr("Bandwidth"): ϒbandwidth,
											})))
										}
										ϒlocation_key = λ.NewFunction("location_key",
											[]λ.Param{
												{Name: "location"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒlocation = λargs[0]
												)
												return func() λ.Object {
													if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.NewStr("^https?://"), ϒlocation)) {
														return λ.NewStr("url")
													} else {
														return λ.NewStr("path")
													}
												}()
											})
										if λ.IsTrue(func() λ.Object {
											if λv := λ.NewBool(!λ.Contains(ϒrepresentation_ms_info, λ.NewStr("segment_urls"))); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("media")))
											}
										}()) {
											ϒmedia_template = λ.Cal(ϒprepare_template, λ.NewStr("media"), λ.NewTuple(
												λ.NewStr("Number"),
												λ.NewStr("Bandwidth"),
												λ.NewStr("Time"),
											))
											ϒmedia_location_key = λ.Cal(ϒlocation_key, ϒmedia_template)
											if λ.IsTrue(func() λ.Object {
												if λv := λ.NewBool(λ.Contains(ϒmedia_template, λ.NewStr("%(Number"))); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(!λ.Contains(ϒrepresentation_ms_info, λ.NewStr("s")))
												}
											}()) {
												ϒsegment_duration = λ.None
												if λ.IsTrue(func() λ.Object {
													if λv := λ.NewBool(!λ.Contains(ϒrepresentation_ms_info, λ.NewStr("total_number"))); !λ.IsTrue(λv) {
														return λv
													} else {
														return λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("segment_duration")))
													}
												}()) {
													ϒsegment_duration = λ.Cal(ϒfloat_or_none, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("segment_duration")), λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("timescale")))
													λ.SetItem(ϒrepresentation_ms_info, λ.NewStr("total_number"), λ.Cal(λ.IntType, λ.Cal(λ.GetAttr(λ.None, "ceil", nil), λ.TrueDiv(λ.Cal(λ.FloatType, ϒperiod_duration), ϒsegment_duration))))
												}
												λ.SetItem(ϒrepresentation_ms_info, λ.NewStr("fragments"), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
													nil,
													0, false, false,
													func(λargs []λ.Object) λ.Object {
														return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
															var (
																ϒsegment_number λ.Object
																τmp0            λ.Object
																τmp1            λ.Object
															)
															τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("start_number")), λ.Add(λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("total_number")), λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("start_number")))))
															for {
																if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
																	break
																}
																ϒsegment_number = τmp1
																λgen.Yield(λ.NewDictWithTable(map[λ.Object]λ.Object{
																	ϒmedia_location_key: λ.Mod(ϒmedia_template, λ.NewDictWithTable(map[λ.Object]λ.Object{
																		λ.NewStr("Number"):    ϒsegment_number,
																		λ.NewStr("Bandwidth"): ϒbandwidth,
																	})),
																	λ.NewStr("duration"): ϒsegment_duration,
																}))
															}
															return λ.None
														})
													}))))
											} else {
												λ.SetItem(ϒrepresentation_ms_info, λ.NewStr("fragments"), λ.NewList())
												ϒsegment_time = λ.NewInt(0)
												ϒsegment_d = λ.None
												ϒsegment_number = λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("start_number"))
												ϒadd_segment_url = λ.NewFunction("add_segment_url",
													nil,
													0, false, false,
													func(λargs []λ.Object) λ.Object {
														var (
															ϒsegment_url λ.Object
														)
														ϒsegment_url = λ.Mod(ϒmedia_template, λ.NewDictWithTable(map[λ.Object]λ.Object{
															λ.NewStr("Time"):      ϒsegment_time,
															λ.NewStr("Bandwidth"): ϒbandwidth,
															λ.NewStr("Number"):    ϒsegment_number,
														}))
														λ.Cal(λ.GetAttr(λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("fragments")), "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
															ϒmedia_location_key:  ϒsegment_url,
															λ.NewStr("duration"): λ.Cal(ϒfloat_or_none, ϒsegment_d, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("timescale"))),
														}))
														return λ.None
													})
												τmp6 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("s"))))
												for {
													if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
														break
													}
													τmp8 = τmp7
													ϒnum = λ.GetItem(τmp8, λ.NewInt(0))
													ϒs = λ.GetItem(τmp8, λ.NewInt(1))
													ϒsegment_time = func() λ.Object {
														if λv := λ.Cal(λ.GetAttr(ϒs, "get", nil), λ.NewStr("t")); λ.IsTrue(λv) {
															return λv
														} else {
															return ϒsegment_time
														}
													}()
													ϒsegment_d = λ.GetItem(ϒs, λ.NewStr("d"))
													λ.Cal(ϒadd_segment_url)
													τmp8 = λ.IAdd(ϒsegment_number, λ.NewInt(1))
													ϒsegment_number = τmp8
													τmp8 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.Cal(λ.GetAttr(ϒs, "get", nil), λ.NewStr("r"), λ.NewInt(0))))
													for {
														if τmp9 = λ.NextDefault(τmp8, λ.AfterLast); τmp9 == λ.AfterLast {
															break
														}
														ϒr = τmp9
														τmp10 = λ.IAdd(ϒsegment_time, ϒsegment_d)
														ϒsegment_time = τmp10
														λ.Cal(ϒadd_segment_url)
														τmp10 = λ.IAdd(ϒsegment_number, λ.NewInt(1))
														ϒsegment_number = τmp10
													}
													τmp8 = λ.IAdd(ϒsegment_time, ϒsegment_d)
													ϒsegment_time = τmp8
												}
											}
										} else {
											if λ.IsTrue(func() λ.Object {
												if λv := λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("segment_urls"))); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("s")))
												}
											}()) {
												ϒfragments = λ.NewList()
												ϒsegment_index = λ.NewInt(0)
												ϒtimescale = λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("timescale"))
												τmp6 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("s")))
												for {
													if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
														break
													}
													ϒs = τmp7
													ϒduration = λ.Cal(ϒfloat_or_none, λ.GetItem(ϒs, λ.NewStr("d")), ϒtimescale)
													τmp8 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.Add(λ.Cal(λ.GetAttr(ϒs, "get", nil), λ.NewStr("r"), λ.NewInt(0)), λ.NewInt(1))))
													for {
														if τmp9 = λ.NextDefault(τmp8, λ.AfterLast); τmp9 == λ.AfterLast {
															break
														}
														ϒr = τmp9
														ϒsegment_uri = λ.GetItem(λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("segment_urls")), ϒsegment_index)
														λ.Cal(λ.GetAttr(ϒfragments, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
															λ.Cal(ϒlocation_key, ϒsegment_uri): ϒsegment_uri,
															λ.NewStr("duration"):               ϒduration,
														}))
														τmp10 = λ.IAdd(ϒsegment_index, λ.NewInt(1))
														ϒsegment_index = τmp10
													}
												}
												λ.SetItem(ϒrepresentation_ms_info, λ.NewStr("fragments"), ϒfragments)
											} else {
												if λ.IsTrue(λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("segment_urls")))) {
													ϒfragments = λ.NewList()
													ϒsegment_duration = func() λ.Object {
														if λ.IsTrue(λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("segment_duration")))) {
															return λ.Cal(ϒfloat_or_none, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("segment_duration")), λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("timescale")))
														} else {
															return λ.None
														}
													}()
													τmp6 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("segment_urls")))
													for {
														if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
															break
														}
														ϒsegment_url = τmp7
														ϒfragment = λ.NewDictWithTable(map[λ.Object]λ.Object{
															λ.Cal(ϒlocation_key, ϒsegment_url): ϒsegment_url,
														})
														if λ.IsTrue(ϒsegment_duration) {
															λ.SetItem(ϒfragment, λ.NewStr("duration"), ϒsegment_duration)
														}
														λ.Cal(λ.GetAttr(ϒfragments, "append", nil), ϒfragment)
													}
													λ.SetItem(ϒrepresentation_ms_info, λ.NewStr("fragments"), ϒfragments)
												}
											}
										}
										if λ.IsTrue(λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("fragments")))) {
											λ.Cal(λ.GetAttr(ϒf, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
												λ.NewStr("fragment_base_url"): ϒbase_url,
												λ.NewStr("fragments"):         λ.NewList(),
												λ.NewStr("protocol"):          λ.NewStr("http_dash_segments"),
											}))
											if λ.IsTrue(λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.NewStr("initialization_url")))) {
												ϒinitialization_url = λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("initialization_url"))
												if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.GetAttr(ϒf, "get", nil), λ.NewStr("url"))))) {
													λ.SetItem(ϒf, λ.NewStr("url"), ϒinitialization_url)
												}
												λ.Cal(λ.GetAttr(λ.GetItem(ϒf, λ.NewStr("fragments")), "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
													λ.Cal(ϒlocation_key, ϒinitialization_url): ϒinitialization_url,
												}))
											}
											λ.Cal(λ.GetAttr(λ.GetItem(ϒf, λ.NewStr("fragments")), "extend", nil), λ.GetItem(ϒrepresentation_ms_info, λ.NewStr("fragments")))
										}
										ϒfull_info = λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒformats_dict, "get", nil), ϒrepresentation_id, λ.NewDictWithTable(map[λ.Object]λ.Object{})), "copy", nil))
										λ.Cal(λ.GetAttr(ϒfull_info, "update", nil), ϒf)
										λ.Cal(λ.GetAttr(ϒformats, "append", nil), ϒfull_info)
									} else {
										λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("Unknown MIME type %s in DASH manifest"), ϒmime_type))
									}
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__extract_ism_formats = λ.NewFunction("_extract_ism_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "ism_url"},
					{Name: "video_id"},
					{Name: "ism_id", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerrnote  = λargs[5]
						ϒfatal    = λargs[6]
						ϒism_doc  λ.Object
						ϒism_id   = λargs[3]
						ϒism_url  = λargs[1]
						ϒnote     = λargs[4]
						ϒres      λ.Object
						ϒself     = λargs[0]
						ϒurlh     λ.Object
						ϒvideo_id = λargs[2]
						τmp0      λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_xml_handle", nil), λ.NewArgs(
						ϒism_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("Downloading ISM manifest")
							}
						}()},
						{Name: "errnote", Value: func() λ.Object {
							if λv := ϒerrnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("Failed to download ISM manifest")
							}
						}()},
						{Name: "fatal", Value: ϒfatal},
					})
					if λ.IsTrue(λ.NewBool(ϒres == λ.False)) {
						return λ.NewList()
					}
					τmp0 = ϒres
					ϒism_doc = λ.GetItem(τmp0, λ.NewInt(0))
					ϒurlh = λ.GetItem(τmp0, λ.NewInt(1))
					return λ.Cal(λ.GetAttr(ϒself, "_parse_ism_formats", nil), ϒism_doc, λ.Cal(λ.GetAttr(ϒurlh, "geturl", nil)), ϒism_id)
				})
			InfoExtractor__parse_ism_formats = λ.NewFunction("_parse_ism_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "ism_doc"},
					{Name: "ism_url"},
					{Name: "ism_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒduration              λ.Object
						ϒformat_id             λ.Object
						ϒformats               λ.Object
						ϒfourcc                λ.Object
						ϒfragment_ctx          λ.Object
						ϒfragment_repeat       λ.Object
						ϒfragments             λ.Object
						ϒheight                λ.Object
						ϒism_doc               = λargs[1]
						ϒism_id                = λargs[3]
						ϒism_url               = λargs[2]
						ϒnext_fragment_time    λ.Object
						ϒsampling_rate         λ.Object
						ϒself                  = λargs[0]
						ϒstream                λ.Object
						ϒstream_fragment       λ.Object
						ϒstream_fragment_index λ.Object
						ϒstream_fragments      λ.Object
						ϒstream_name           λ.Object
						ϒstream_timescale      λ.Object
						ϒstream_type           λ.Object
						ϒtbr                   λ.Object
						ϒtimescale             λ.Object
						ϒtrack                 λ.Object
						ϒtrack_url_pattern     λ.Object
						ϒurl_pattern           λ.Object
						ϒwidth                 λ.Object
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
						τmp3                   λ.Object
						τmp4                   λ.Object
						τmp5                   λ.Object
						τmp6                   λ.Object
						τmp7                   λ.Object
						τmp8                   λ.Object
					)
					λ.NewStr("\n        Parse formats from ISM manifest.\n        References:\n         1. [MS-SSTR]: Smooth Streaming Protocol,\n            https://msdn.microsoft.com/en-us/library/ff469518.aspx\n        ")
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Eq(λ.Cal(λ.GetAttr(ϒism_doc, "get", nil), λ.NewStr("IsLive")), λ.NewStr("TRUE")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Cal(λ.GetAttr(ϒism_doc, "find", nil), λ.NewStr("Protection")) != λ.None)
						}
					}()) {
						return λ.NewList()
					}
					ϒduration = λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(ϒism_doc, "attrib", nil), λ.NewStr("Duration")))
					ϒtimescale = func() λ.Object {
						if λv := λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒism_doc, "get", nil), λ.NewStr("TimeScale"))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewInt(10000000)
						}
					}()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒism_doc, "findall", nil), λ.NewStr("StreamIndex")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒstream = τmp1
						ϒstream_type = λ.Cal(λ.GetAttr(ϒstream, "get", nil), λ.NewStr("Type"))
						if λ.IsTrue(λ.NewBool(!λ.Contains(λ.NewTuple(
							λ.NewStr("video"),
							λ.NewStr("audio"),
						), ϒstream_type))) {
							continue
						}
						ϒurl_pattern = λ.GetItem(λ.GetAttr(ϒstream, "attrib", nil), λ.NewStr("Url"))
						ϒstream_timescale = func() λ.Object {
							if λv := λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒstream, "get", nil), λ.NewStr("TimeScale"))); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒtimescale
							}
						}()
						ϒstream_name = λ.Cal(λ.GetAttr(ϒstream, "get", nil), λ.NewStr("Name"))
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(ϒstream, "findall", nil), λ.NewStr("QualityLevel")))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒtrack = τmp3
							ϒfourcc = λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("FourCC"), func() λ.Object {
								if λ.IsTrue(λ.Eq(λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("AudioTag")), λ.NewStr("255"))) {
									return λ.NewStr("AACL")
								} else {
									return λ.None
								}
							}())
							if λ.IsTrue(λ.NewBool(!λ.Contains(λ.NewTuple(
								λ.NewStr("H264"),
								λ.NewStr("AVC1"),
								λ.NewStr("AACL"),
							), ϒfourcc))) {
								λ.Cal(λ.GetAttr(ϒself, "report_warning", nil), λ.Mod(λ.NewStr("%s is not a supported codec"), ϒfourcc))
								continue
							}
							ϒtbr = λ.FloorDiv(λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(ϒtrack, "attrib", nil), λ.NewStr("Bitrate"))), λ.NewInt(1000))
							ϒwidth = λ.Cal(ϒint_or_none, func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("MaxWidth")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("Width"))
								}
							}())
							ϒheight = λ.Cal(ϒint_or_none, func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("MaxHeight")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("Height"))
								}
							}())
							ϒsampling_rate = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("SamplingRate")))
							ϒtrack_url_pattern = λ.Cal(Ωre.ϒsub, λ.NewStr("{[Bb]itrate}"), λ.GetItem(λ.GetAttr(ϒtrack, "attrib", nil), λ.NewStr("Bitrate")), ϒurl_pattern)
							ϒtrack_url_pattern = λ.Cal(Ωparse.ϒurljoin, ϒism_url, ϒtrack_url_pattern)
							ϒfragments = λ.NewList()
							ϒfragment_ctx = λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("time"): λ.NewInt(0),
							})
							ϒstream_fragments = λ.Cal(λ.GetAttr(ϒstream, "findall", nil), λ.NewStr("c"))
							τmp4 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒstream_fragments))
							for {
								if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
									break
								}
								τmp6 = τmp5
								ϒstream_fragment_index = λ.GetItem(τmp6, λ.NewInt(0))
								ϒstream_fragment = λ.GetItem(τmp6, λ.NewInt(1))
								λ.SetItem(ϒfragment_ctx, λ.NewStr("time"), func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒstream_fragment, "get", nil), λ.NewStr("t"))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.GetItem(ϒfragment_ctx, λ.NewStr("time"))
									}
								}())
								ϒfragment_repeat = func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒstream_fragment, "get", nil), λ.NewStr("r"))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewInt(1)
									}
								}()
								λ.SetItem(ϒfragment_ctx, λ.NewStr("duration"), λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒstream_fragment, "get", nil), λ.NewStr("d"))))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.GetItem(ϒfragment_ctx, λ.NewStr("duration"))))) {
									τmp6, τmp7 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.CatchMulti(
											nil,
											&λ.Catcher{λ.IndexErrorType, func(λex λ.BaseException) {
												ϒnext_fragment_time = ϒduration
											}},
										)
										ϒnext_fragment_time = λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(λ.GetItem(ϒstream_fragment, λ.Add(ϒstream_fragment_index, λ.NewInt(1))), "attrib", nil), λ.NewStr("t")))
										return λ.BlockExitNormally, nil
									}()
									λ.SetItem(ϒfragment_ctx, λ.NewStr("duration"), λ.TrueDiv(λ.Sub(ϒnext_fragment_time, λ.GetItem(ϒfragment_ctx, λ.NewStr("time"))), ϒfragment_repeat))
								}
								τmp7 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, ϒfragment_repeat))
								for {
									if τmp6 = λ.NextDefault(τmp7, λ.AfterLast); τmp6 == λ.AfterLast {
										break
									}
									_ = τmp6
									λ.Cal(λ.GetAttr(ϒfragments, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("url"):      λ.Cal(Ωre.ϒsub, λ.NewStr("{start[ _]time}"), λ.Cal(ϒcompat_str, λ.GetItem(ϒfragment_ctx, λ.NewStr("time"))), ϒtrack_url_pattern),
										λ.NewStr("duration"): λ.TrueDiv(λ.GetItem(ϒfragment_ctx, λ.NewStr("duration")), ϒstream_timescale),
									}))
									τmp8 = λ.IAdd(λ.GetItem(ϒfragment_ctx, λ.NewStr("time")), λ.GetItem(ϒfragment_ctx, λ.NewStr("duration")))
									λ.SetItem(ϒfragment_ctx, λ.NewStr("time"), τmp8)
								}
							}
							ϒformat_id = λ.NewList()
							if λ.IsTrue(ϒism_id) {
								λ.Cal(λ.GetAttr(ϒformat_id, "append", nil), ϒism_id)
							}
							if λ.IsTrue(ϒstream_name) {
								λ.Cal(λ.GetAttr(ϒformat_id, "append", nil), ϒstream_name)
							}
							λ.Cal(λ.GetAttr(ϒformat_id, "append", nil), λ.Cal(ϒcompat_str, ϒtbr))
							λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("format_id"):    λ.Cal(λ.GetAttr(λ.NewStr("-"), "join", nil), ϒformat_id),
								λ.NewStr("url"):          ϒism_url,
								λ.NewStr("manifest_url"): ϒism_url,
								λ.NewStr("ext"): func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒstream_type, λ.NewStr("video"))) {
										return λ.NewStr("ismv")
									} else {
										return λ.NewStr("isma")
									}
								}(),
								λ.NewStr("width"):  ϒwidth,
								λ.NewStr("height"): ϒheight,
								λ.NewStr("tbr"):    ϒtbr,
								λ.NewStr("asr"):    ϒsampling_rate,
								λ.NewStr("vcodec"): func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒstream_type, λ.NewStr("audio"))) {
										return λ.NewStr("none")
									} else {
										return ϒfourcc
									}
								}(),
								λ.NewStr("acodec"): func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒstream_type, λ.NewStr("video"))) {
										return λ.NewStr("none")
									} else {
										return ϒfourcc
									}
								}(),
								λ.NewStr("protocol"):  λ.NewStr("ism"),
								λ.NewStr("fragments"): ϒfragments,
								λ.NewStr("_download_params"): λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("duration"):  ϒduration,
									λ.NewStr("timescale"): ϒstream_timescale,
									λ.NewStr("width"): func() λ.Object {
										if λv := ϒwidth; λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewInt(0)
										}
									}(),
									λ.NewStr("height"): func() λ.Object {
										if λv := ϒheight; λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewInt(0)
										}
									}(),
									λ.NewStr("fourcc"):                ϒfourcc,
									λ.NewStr("codec_private_data"):    λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("CodecPrivateData")),
									λ.NewStr("sampling_rate"):         ϒsampling_rate,
									λ.NewStr("channels"):              λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("Channels"), λ.NewInt(2))),
									λ.NewStr("bits_per_sample"):       λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("BitsPerSample"), λ.NewInt(16))),
									λ.NewStr("nal_unit_length_field"): λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("NALUnitLengthField"), λ.NewInt(4))),
								}),
							}))
						}
					}
					return ϒformats
				})
			InfoExtractor__parse_html5_media_entries = λ.NewFunction("_parse_html5_media_entries",
				[]λ.Param{
					{Name: "self"},
					{Name: "base_url"},
					{Name: "webpage"},
					{Name: "video_id"},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "m3u8_entry_protocol", Def: λ.NewStr("m3u8")},
					{Name: "mpd_id", Def: λ.None},
					{Name: "preference", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_media_formats      λ.Object
						ϒabsolute_url        λ.Object
						ϒbase_url            = λargs[1]
						ϒentries             λ.Object
						ϒf                   λ.Object
						ϒformats             λ.Object
						ϒis_plain_url        λ.Object
						ϒkind                λ.Object
						ϒlang                λ.Object
						ϒm3u8_entry_protocol = λargs[5]
						ϒm3u8_id             = λargs[4]
						ϒmedia_attributes    λ.Object
						ϒmedia_content       λ.Object
						ϒmedia_info          λ.Object
						ϒmedia_tag           λ.Object
						ϒmedia_tags          λ.Object
						ϒmedia_type          λ.Object
						ϒmpd_id              = λargs[6]
						ϒparse_content_type  λ.Object
						ϒpreference          = λargs[7]
						ϒself                = λargs[0]
						ϒsource_attributes   λ.Object
						ϒsource_tag          λ.Object
						ϒsrc                 λ.Object
						ϒtrack_attributes    λ.Object
						ϒtrack_tag           λ.Object
						ϒvideo_id            = λargs[3]
						ϒwebpage             = λargs[2]
						τmp0                 λ.Object
						τmp1                 λ.Object
						τmp2                 λ.Object
						τmp3                 λ.Object
						τmp4                 λ.Object
					)
					ϒabsolute_url = λ.NewFunction("absolute_url",
						[]λ.Param{
							{Name: "item_url"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒitem_url = λargs[0]
							)
							return λ.Cal(ϒurljoin, ϒbase_url, ϒitem_url)
						})
					ϒparse_content_type = λ.NewFunction("parse_content_type",
						[]λ.Param{
							{Name: "content_type"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcodecs       λ.Object
								ϒcontent_type = λargs[0]
								ϒctr          λ.Object
								ϒf            λ.Object
								ϒmimetype     λ.Object
								τmp0          λ.Object
							)
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒcontent_type))) {
								return λ.NewDictWithTable(map[λ.Object]λ.Object{})
							}
							ϒctr = λ.Cal(Ωre.ϒsearch, λ.NewStr("(?P<mimetype>[^/]+/[^;]+)(?:;\\s*codecs=\"?(?P<codecs>[^\"]+))?"), ϒcontent_type)
							if λ.IsTrue(ϒctr) {
								τmp0 = λ.Cal(λ.GetAttr(ϒctr, "groups", nil))
								ϒmimetype = λ.GetItem(τmp0, λ.NewInt(0))
								ϒcodecs = λ.GetItem(τmp0, λ.NewInt(1))
								ϒf = λ.Cal(ϒparse_codecs, ϒcodecs)
								λ.SetItem(ϒf, λ.NewStr("ext"), λ.Cal(ϒmimetype2ext, ϒmimetype))
								return ϒf
							}
							return λ.NewDictWithTable(map[λ.Object]λ.Object{})
						})
					ϒ_media_formats = λ.NewFunction("_media_formats",
						[]λ.Param{
							{Name: "src"},
							{Name: "cur_media_type"},
							{Name: "type_info", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcur_media_type = λargs[1]
								ϒext            λ.Object
								ϒformats        λ.Object
								ϒfull_url       λ.Object
								ϒis_plain_url   λ.Object
								ϒsrc            = λargs[0]
								ϒtype_info      = λargs[2]
							)
							ϒfull_url = λ.Cal(ϒabsolute_url, ϒsrc)
							ϒext = func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒtype_info, "get", nil), λ.NewStr("ext")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒdetermine_ext, ϒfull_url)
								}
							}()
							if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("m3u8"))) {
								ϒis_plain_url = λ.False
								ϒformats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
									ϒfull_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "ext", Value: λ.NewStr("mp4")},
									{Name: "entry_protocol", Value: ϒm3u8_entry_protocol},
									{Name: "m3u8_id", Value: ϒm3u8_id},
									{Name: "preference", Value: ϒpreference},
									{Name: "fatal", Value: λ.False},
								})
							} else {
								if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("mpd"))) {
									ϒis_plain_url = λ.False
									ϒformats = λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
										ϒfull_url,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "mpd_id", Value: ϒmpd_id},
										{Name: "fatal", Value: λ.False},
									})
								} else {
									ϒis_plain_url = λ.True
									ϒformats = λ.NewList(λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("url"): ϒfull_url,
										λ.NewStr("vcodec"): func() λ.Object {
											if λ.IsTrue(λ.Eq(ϒcur_media_type, λ.NewStr("audio"))) {
												return λ.NewStr("none")
											} else {
												return λ.None
											}
										}(),
									}))
								}
							}
							return λ.NewTuple(
								ϒis_plain_url,
								ϒformats,
							)
						})
					ϒentries = λ.NewList()
					ϒmedia_tags = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
								var (
									ϒmedia_tag  λ.Object
									ϒmedia_type λ.Object
									τmp0        λ.Object
									τmp1        λ.Object
									τmp2        λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.NewStr("(?s)(<(?:amp-)?(video|audio)[^>]*/>)"), ϒwebpage))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒmedia_tag = λ.GetItem(τmp2, λ.NewInt(0))
									ϒmedia_type = λ.GetItem(τmp2, λ.NewInt(1))
									λgen.Yield(λ.NewTuple(
										ϒmedia_tag,
										ϒmedia_type,
										λ.NewStr(""),
									))
								}
								return λ.None
							})
						})))
					λ.Cal(λ.GetAttr(ϒmedia_tags, "extend", nil), λ.Cal(Ωre.ϒfindall, λ.NewStr("(?s)(<(?P<tag>(?:amp-)?(?:video|audio))(?:\\s+[^>]*)?>)(.*?)</(?P=tag)>"), ϒwebpage))
					τmp0 = λ.Cal(λ.BuiltinIter, ϒmedia_tags)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒmedia_tag = λ.GetItem(τmp2, λ.NewInt(0))
						ϒmedia_type = λ.GetItem(τmp2, λ.NewInt(1))
						ϒmedia_content = λ.GetItem(τmp2, λ.NewInt(2))
						ϒmedia_info = λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("formats"):   λ.NewList(),
							λ.NewStr("subtitles"): λ.NewDictWithTable(map[λ.Object]λ.Object{}),
						})
						ϒmedia_attributes = λ.Cal(ϒextract_attributes, ϒmedia_tag)
						ϒsrc = λ.Cal(λ.GetAttr(ϒmedia_attributes, "get", nil), λ.NewStr("src"))
						if λ.IsTrue(ϒsrc) {
							τmp2 = λ.Cal(ϒ_media_formats, ϒsrc, ϒmedia_type)
							_ = λ.GetItem(τmp2, λ.NewInt(0))
							ϒformats = λ.GetItem(τmp2, λ.NewInt(1))
							λ.Cal(λ.GetAttr(λ.GetItem(ϒmedia_info, λ.NewStr("formats")), "extend", nil), ϒformats)
						}
						λ.SetItem(ϒmedia_info, λ.NewStr("thumbnail"), λ.Cal(ϒabsolute_url, λ.Cal(λ.GetAttr(ϒmedia_attributes, "get", nil), λ.NewStr("poster"))))
						if λ.IsTrue(ϒmedia_content) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.NewStr("<source[^>]+>"), ϒmedia_content))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒsource_tag = τmp3
								ϒsource_attributes = λ.Cal(ϒextract_attributes, ϒsource_tag)
								ϒsrc = λ.Cal(λ.GetAttr(ϒsource_attributes, "get", nil), λ.NewStr("src"))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒsrc))) {
									continue
								}
								ϒf = λ.Cal(ϒparse_content_type, λ.Cal(λ.GetAttr(ϒsource_attributes, "get", nil), λ.NewStr("type")))
								τmp4 = λ.Cal(ϒ_media_formats, ϒsrc, ϒmedia_type, ϒf)
								ϒis_plain_url = λ.GetItem(τmp4, λ.NewInt(0))
								ϒformats = λ.GetItem(τmp4, λ.NewInt(1))
								if λ.IsTrue(ϒis_plain_url) {
									λ.Cal(λ.GetAttr(ϒf, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("height"):    λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒsource_attributes, "get", nil), λ.NewStr("res"))),
										λ.NewStr("format_id"): λ.Cal(λ.GetAttr(ϒsource_attributes, "get", nil), λ.NewStr("label")),
									}))
									λ.Cal(λ.GetAttr(ϒf, "update", nil), λ.GetItem(ϒformats, λ.NewInt(0)))
									λ.Cal(λ.GetAttr(λ.GetItem(ϒmedia_info, λ.NewStr("formats")), "append", nil), ϒf)
								} else {
									λ.Cal(λ.GetAttr(λ.GetItem(ϒmedia_info, λ.NewStr("formats")), "extend", nil), ϒformats)
								}
							}
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.NewStr("<track[^>]+>"), ϒmedia_content))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒtrack_tag = τmp3
								ϒtrack_attributes = λ.Cal(ϒextract_attributes, ϒtrack_tag)
								ϒkind = λ.Cal(λ.GetAttr(ϒtrack_attributes, "get", nil), λ.NewStr("kind"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.IsTrue(ϒkind)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(λ.Contains(λ.NewTuple(
											λ.NewStr("subtitles"),
											λ.NewStr("captions"),
										), ϒkind))
									}
								}()) {
									ϒsrc = λ.Cal(λ.GetAttr(ϒtrack_attributes, "get", nil), λ.NewStr("src"))
									if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒsrc))) {
										continue
									}
									ϒlang = func() λ.Object {
										if λv := λ.Cal(λ.GetAttr(ϒtrack_attributes, "get", nil), λ.NewStr("srclang")); λ.IsTrue(λv) {
											return λv
										} else if λv := λ.Cal(λ.GetAttr(ϒtrack_attributes, "get", nil), λ.NewStr("lang")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.GetAttr(ϒtrack_attributes, "get", nil), λ.NewStr("label"))
										}
									}()
									λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(λ.GetItem(ϒmedia_info, λ.NewStr("subtitles")), "setdefault", nil), ϒlang, λ.NewList()), "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
										λ.NewStr("url"): λ.Cal(ϒabsolute_url, ϒsrc),
									}))
								}
							}
						}
						τmp2 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒmedia_info, λ.NewStr("formats")))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒf = τmp3
							λ.SetItem(λ.Cal(λ.GetAttr(ϒf, "setdefault", nil), λ.NewStr("http_headers"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), λ.NewStr("Referer"), ϒbase_url)
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.GetItem(ϒmedia_info, λ.NewStr("formats")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.GetItem(ϒmedia_info, λ.NewStr("subtitles"))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒentries, "append", nil), ϒmedia_info)
						}
					}
					return ϒentries
				})
			InfoExtractor__parse_jwplayer_data = λ.NewFunction("_parse_jwplayer_data",
				[]λ.Param{
					{Name: "self"},
					{Name: "jwplayer_data"},
					{Name: "video_id", Def: λ.None},
					{Name: "require_title", Def: λ.True},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "mpd_id", Def: λ.None},
					{Name: "rtmp_params", Def: λ.None},
					{Name: "base_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒbase_url      = λargs[7]
						ϒentries       λ.Object
						ϒentry         λ.Object
						ϒformats       λ.Object
						ϒjwplayer_data = λargs[1]
						ϒm3u8_id       = λargs[4]
						ϒmpd_id        = λargs[5]
						ϒrequire_title = λargs[3]
						ϒrtmp_params   = λargs[6]
						ϒself          = λargs[0]
						ϒsubtitles     λ.Object
						ϒthis_video_id λ.Object
						ϒtrack         λ.Object
						ϒtrack_kind    λ.Object
						ϒtrack_url     λ.Object
						ϒtracks        λ.Object
						ϒvideo_data    λ.Object
						ϒvideo_id      = λargs[2]
						τmp0           λ.Object
						τmp1           λ.Object
						τmp2           λ.Object
						τmp3           λ.Object
					)
					if λ.IsTrue(λ.NewBool(!λ.Contains(ϒjwplayer_data, λ.NewStr("playlist")))) {
						ϒjwplayer_data = λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("playlist"): λ.NewList(ϒjwplayer_data),
						})
					}
					ϒentries = λ.NewList()
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, λ.GetItem(ϒjwplayer_data, λ.NewStr("playlist")), λ.ListType)))) {
						λ.SetItem(ϒjwplayer_data, λ.NewStr("playlist"), λ.NewList(λ.GetItem(ϒjwplayer_data, λ.NewStr("playlist"))))
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒjwplayer_data, λ.NewStr("playlist")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒvideo_data = τmp1
						if λ.IsTrue(λ.NewBool(!λ.Contains(ϒvideo_data, λ.NewStr("sources")))) {
							λ.SetItem(ϒvideo_data, λ.NewStr("sources"), λ.NewList(ϒvideo_data))
						}
						ϒthis_video_id = func() λ.Object {
							if λv := ϒvideo_id; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.GetItem(ϒvideo_data, λ.NewStr("mediaid"))
							}
						}()
						ϒformats = λ.Call(λ.GetAttr(ϒself, "_parse_jwplayer_formats", nil), λ.NewArgs(λ.GetItem(ϒvideo_data, λ.NewStr("sources"))), λ.KWArgs{
							{Name: "video_id", Value: ϒthis_video_id},
							{Name: "m3u8_id", Value: ϒm3u8_id},
							{Name: "mpd_id", Value: ϒmpd_id},
							{Name: "rtmp_params", Value: ϒrtmp_params},
							{Name: "base_url", Value: ϒbase_url},
						})
						ϒsubtitles = λ.NewDictWithTable(map[λ.Object]λ.Object{})
						ϒtracks = λ.Cal(λ.GetAttr(ϒvideo_data, "get", nil), λ.NewStr("tracks"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒtracks; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.BuiltinIsInstance, ϒtracks, λ.ListType)
							}
						}()) {
							τmp2 = λ.Cal(λ.BuiltinIter, ϒtracks)
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒtrack = τmp3
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒtrack, λ.DictType)))) {
									continue
								}
								ϒtrack_kind = λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("kind"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.IsTrue(ϒtrack_kind)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒtrack_kind, ϒcompat_str)))
									}
								}()) {
									continue
								}
								if λ.IsTrue(λ.NewBool(!λ.Contains(λ.NewTuple(
									λ.NewStr("captions"),
									λ.NewStr("subtitles"),
								), λ.Cal(λ.GetAttr(ϒtrack_kind, "lower", nil))))) {
									continue
								}
								ϒtrack_url = λ.Cal(ϒurljoin, ϒbase_url, λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("file")))
								if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒtrack_url))) {
									continue
								}
								λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒsubtitles, "setdefault", nil), func() λ.Object {
									if λv := λ.Cal(λ.GetAttr(ϒtrack, "get", nil), λ.NewStr("label")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewStr("en")
									}
								}(), λ.NewList()), "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
									λ.NewStr("url"): λ.Cal(λ.GetAttr(ϒself, "_proto_relative_url", nil), ϒtrack_url),
								}))
							}
						}
						ϒentry = λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("id"): ϒthis_video_id,
							λ.NewStr("title"): λ.Cal(ϒunescapeHTML, func() λ.Object {
								if λ.IsTrue(ϒrequire_title) {
									return λ.GetItem(ϒvideo_data, λ.NewStr("title"))
								} else {
									return λ.Cal(λ.GetAttr(ϒvideo_data, "get", nil), λ.NewStr("title"))
								}
							}()),
							λ.NewStr("description"): λ.Cal(λ.GetAttr(ϒvideo_data, "get", nil), λ.NewStr("description")),
							λ.NewStr("thumbnail"):   λ.Cal(λ.GetAttr(ϒself, "_proto_relative_url", nil), λ.Cal(λ.GetAttr(ϒvideo_data, "get", nil), λ.NewStr("image"))),
							λ.NewStr("timestamp"):   λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒvideo_data, "get", nil), λ.NewStr("pubdate"))),
							λ.NewStr("duration"): λ.Cal(ϒfloat_or_none, func() λ.Object {
								if λv := λ.Cal(λ.GetAttr(ϒjwplayer_data, "get", nil), λ.NewStr("duration")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.GetAttr(ϒvideo_data, "get", nil), λ.NewStr("duration"))
								}
							}()),
							λ.NewStr("subtitles"): ϒsubtitles,
						})
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(λ.Cal(λ.BuiltinLen, ϒformats), λ.NewInt(1)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(Ωre.ϒsearch, λ.NewStr("^(?:http|//).*(?:youtube\\.com|youtu\\.be)/.+"), λ.GetItem(λ.GetItem(ϒformats, λ.NewInt(0)), λ.NewStr("url")))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒentry, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("_type"): λ.NewStr("url_transparent"),
								λ.NewStr("url"):   λ.GetItem(λ.GetItem(ϒformats, λ.NewInt(0)), λ.NewStr("url")),
							}))
						} else {
							λ.Cal(λ.GetAttr(ϒself, "_sort_formats", nil), ϒformats)
							λ.SetItem(ϒentry, λ.NewStr("formats"), ϒformats)
						}
						λ.Cal(λ.GetAttr(ϒentries, "append", nil), ϒentry)
					}
					if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒentries), λ.NewInt(1))) {
						return λ.GetItem(ϒentries, λ.NewInt(0))
					} else {
						return λ.Cal(λ.GetAttr(ϒself, "playlist_result", nil), ϒentries)
					}
					return λ.None
				})
			InfoExtractor__parse_jwplayer_formats = λ.NewFunction("_parse_jwplayer_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "jwplayer_sources_data"},
					{Name: "video_id", Def: λ.None},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "mpd_id", Def: λ.None},
					{Name: "rtmp_params", Def: λ.None},
					{Name: "base_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒa_format              λ.Object
						ϒbase_url              = λargs[6]
						ϒext                   λ.Object
						ϒformats               λ.Object
						ϒheight                λ.Object
						ϒjwplayer_sources_data = λargs[1]
						ϒm3u8_id               = λargs[3]
						ϒmpd_id                = λargs[4]
						ϒplay_path             λ.Object
						ϒprefix                λ.Object
						ϒrtmp_params           = λargs[5]
						ϒrtmp_url              λ.Object
						ϒrtmp_url_parts        λ.Object
						ϒself                  = λargs[0]
						ϒsource                λ.Object
						ϒsource_type           λ.Object
						ϒsource_url            λ.Object
						ϒurls                  λ.Object
						ϒvideo_id              = λargs[2]
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
					)
					ϒurls = λ.NewList()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒjwplayer_sources_data)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒsource = τmp1
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒsource, λ.DictType)))) {
							continue
						}
						ϒsource_url = λ.Cal(λ.GetAttr(ϒself, "_proto_relative_url", nil), λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("file")))
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(ϒsource_url))) {
							continue
						}
						if λ.IsTrue(ϒbase_url) {
							ϒsource_url = λ.Cal(Ωparse.ϒurljoin, ϒbase_url, ϒsource_url)
						}
						if λ.IsTrue(λ.NewBool(λ.Contains(ϒurls, ϒsource_url))) {
							continue
						}
						λ.Cal(λ.GetAttr(ϒurls, "append", nil), ϒsource_url)
						ϒsource_type = func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("type")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewStr("")
							}
						}()
						ϒext = func() λ.Object {
							if λv := λ.Cal(ϒmimetype2ext, ϒsource_type); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(ϒdetermine_ext, ϒsource_url)
							}
						}()
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒsource_type, λ.NewStr("hls")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒext, λ.NewStr("m3u8"))
							}
						}()) {
							λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
								ϒsource_url,
								ϒvideo_id,
								λ.NewStr("mp4"),
							), λ.KWArgs{
								{Name: "entry_protocol", Value: λ.NewStr("m3u8_native")},
								{Name: "m3u8_id", Value: ϒm3u8_id},
								{Name: "fatal", Value: λ.False},
							}))
						} else {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(ϒsource_type, λ.NewStr("dash")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(ϒext, λ.NewStr("mpd"))
								}
							}()) {
								λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
									ϒsource_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "mpd_id", Value: ϒmpd_id},
									{Name: "fatal", Value: λ.False},
								}))
							} else {
								if λ.IsTrue(λ.Eq(ϒext, λ.NewStr("smil"))) {
									λ.Cal(λ.GetAttr(ϒformats, "extend", nil), λ.Call(λ.GetAttr(ϒself, "_extract_smil_formats", nil), λ.NewArgs(
										ϒsource_url,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "fatal", Value: λ.False},
									}))
								} else {
									if λ.IsTrue(func() λ.Object {
										if λv := λ.Cal(λ.GetAttr(ϒsource_type, "startswith", nil), λ.NewStr("audio")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewBool(λ.Contains(λ.NewTuple(
												λ.NewStr("oga"),
												λ.NewStr("aac"),
												λ.NewStr("mp3"),
												λ.NewStr("mpeg"),
												λ.NewStr("vorbis"),
											), ϒext))
										}
									}()) {
										λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("url"):    ϒsource_url,
											λ.NewStr("vcodec"): λ.NewStr("none"),
											λ.NewStr("ext"):    ϒext,
										}))
									} else {
										ϒheight = λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("height")))
										if λ.IsTrue(λ.NewBool(ϒheight == λ.None)) {
											ϒheight = λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
												λ.NewStr("^(\\d{3,4})[pP]?(?:\\b|$)"),
												λ.Cal(ϒcompat_str, func() λ.Object {
													if λv := λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("label")); λ.IsTrue(λv) {
														return λv
													} else {
														return λ.NewStr("")
													}
												}()),
												λ.NewStr("height"),
											), λ.KWArgs{
												{Name: "default", Value: λ.None},
											}))
										}
										ϒa_format = λ.NewDictWithTable(map[λ.Object]λ.Object{
											λ.NewStr("url"):    ϒsource_url,
											λ.NewStr("width"):  λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("width"))),
											λ.NewStr("height"): ϒheight,
											λ.NewStr("tbr"):    λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒsource, "get", nil), λ.NewStr("bitrate"))),
											λ.NewStr("ext"):    ϒext,
										})
										if λ.IsTrue(λ.Cal(λ.GetAttr(ϒsource_url, "startswith", nil), λ.NewStr("rtmp"))) {
											λ.SetItem(ϒa_format, λ.NewStr("ext"), λ.NewStr("flv"))
											ϒrtmp_url_parts = λ.Cal(λ.None, λ.NewStr("((?:mp4|mp3|flv):)"), ϒsource_url, λ.NewInt(1))
											if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒrtmp_url_parts), λ.NewInt(3))) {
												τmp2 = ϒrtmp_url_parts
												ϒrtmp_url = λ.GetItem(τmp2, λ.NewInt(0))
												ϒprefix = λ.GetItem(τmp2, λ.NewInt(1))
												ϒplay_path = λ.GetItem(τmp2, λ.NewInt(2))
												λ.Cal(λ.GetAttr(ϒa_format, "update", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
													λ.NewStr("url"):       ϒrtmp_url,
													λ.NewStr("play_path"): λ.Add(ϒprefix, ϒplay_path),
												}))
											}
											if λ.IsTrue(ϒrtmp_params) {
												λ.Cal(λ.GetAttr(ϒa_format, "update", nil), ϒrtmp_params)
											}
										}
										λ.Cal(λ.GetAttr(ϒformats, "append", nil), ϒa_format)
									}
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__live_title = λ.NewFunction("_live_title",
				[]λ.Param{
					{Name: "self"},
					{Name: "name"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒname = λargs[1]
						ϒself = λargs[0]
					)
					_ = ϒself
					λ.NewStr(" Generate the title for a live video ")
					return ϒname
				})
			InfoExtractor__int = λ.NewFunction("_int",
				[]λ.Param{
					{Name: "self"},
					{Name: "v"},
					{Name: "name"},
					{Name: "fatal", Def: λ.False},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal  = λargs[3]
						ϒkwargs = λargs[4]
						ϒmsg    λ.Object
						ϒname   = λargs[2]
						ϒres    λ.Object
						ϒself   = λargs[0]
						ϒv      = λargs[1]
					)
					ϒres = λ.Call(ϒint_or_none, λ.NewArgs(ϒv), λ.KWArgs{
						{Name: "", Value: ϒkwargs},
					})
					if λ.IsTrue(λ.NewBool(λ.Contains(ϒkwargs, λ.NewStr("get_attr")))) {
						λ.Cal(λ.BuiltinPrint, λ.Cal(λ.BuiltinGetAttr, ϒv, λ.GetItem(ϒkwargs, λ.NewStr("get_attr"))))
					}
					if λ.IsTrue(λ.NewBool(ϒres == λ.None)) {
						ϒmsg = λ.Mod(λ.NewStr("Failed to extract %s: Could not parse value %r"), λ.NewTuple(
							ϒname,
							ϒv,
						))
						if λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(ExtractorError, ϒmsg)))
						} else {
							λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), ϒmsg)
						}
					}
					return ϒres
				})
			InfoExtractor__float = λ.NewFunction("_float",
				[]λ.Param{
					{Name: "self"},
					{Name: "v"},
					{Name: "name"},
					{Name: "fatal", Def: λ.False},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal  = λargs[3]
						ϒkwargs = λargs[4]
						ϒmsg    λ.Object
						ϒname   = λargs[2]
						ϒres    λ.Object
						ϒself   = λargs[0]
						ϒv      = λargs[1]
					)
					ϒres = λ.Call(ϒfloat_or_none, λ.NewArgs(ϒv), λ.KWArgs{
						{Name: "", Value: ϒkwargs},
					})
					if λ.IsTrue(λ.NewBool(ϒres == λ.None)) {
						ϒmsg = λ.Mod(λ.NewStr("Failed to extract %s: Could not parse value %r"), λ.NewTuple(
							ϒname,
							ϒv,
						))
						if λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(ExtractorError, ϒmsg)))
						} else {
							λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", nil), ϒmsg)
						}
					}
					return ϒres
				})
			InfoExtractor__set_cookie = λ.NewFunction("_set_cookie",
				[]λ.Param{
					{Name: "self"},
					{Name: "domain"},
					{Name: "name"},
					{Name: "value"},
					{Name: "expire_time", Def: λ.None},
					{Name: "port", Def: λ.None},
					{Name: "path", Def: λ.NewStr("/")},
					{Name: "secure", Def: λ.False},
					{Name: "discard", Def: λ.False},
					{Name: "rest", Def: λ.NewDictWithTable(map[λ.Object]λ.Object{})},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcookie      λ.Object
						ϒdiscard     = λargs[8]
						ϒdomain      = λargs[1]
						ϒexpire_time = λargs[4]
						ϒkwargs      = λargs[10]
						ϒname        = λargs[2]
						ϒpath        = λargs[6]
						ϒport        = λargs[5]
						ϒrest        = λargs[9]
						ϒsecure      = λargs[7]
						ϒself        = λargs[0]
						ϒvalue       = λargs[3]
					)
					_ = ϒkwargs
					ϒcookie = λ.Cal(Ωcookiejar.Cookie, λ.NewInt(0), ϒname, ϒvalue, ϒport, λ.NewBool(ϒport != λ.None), ϒdomain, λ.True, λ.Cal(λ.GetAttr(ϒdomain, "startswith", nil), λ.NewStr(".")), ϒpath, λ.True, ϒsecure, ϒexpire_time, ϒdiscard, λ.None, λ.None, ϒrest)
					λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "cookiejar", nil), "set_cookie", nil), ϒcookie)
					return λ.None
				})
			InfoExtractor_geo_verification_headers = λ.NewFunction("geo_verification_headers",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒgeo_verification_proxy λ.Object
						ϒheaders                λ.Object
						ϒself                   = λargs[0]
					)
					ϒheaders = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					ϒgeo_verification_proxy = λ.Cal(λ.GetAttr(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", nil), λ.NewStr("geo_verification_proxy"))
					if λ.IsTrue(ϒgeo_verification_proxy) {
						λ.SetItem(ϒheaders, λ.NewStr("Ytdl-request-proxy"), ϒgeo_verification_proxy)
					}
					return ϒheaders
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("IE_NAME"):                      InfoExtractor_IE_NAME,
				λ.NewStr("_GEO_BYPASS"):                  InfoExtractor__GEO_BYPASS,
				λ.NewStr("_GEO_COUNTRIES"):               InfoExtractor__GEO_COUNTRIES,
				λ.NewStr("_GEO_IP_BLOCKS"):               InfoExtractor__GEO_IP_BLOCKS,
				λ.NewStr("_WORKING"):                     InfoExtractor__WORKING,
				λ.NewStr("__can_accept_status_code"):     InfoExtractor___can_accept_status_code,
				λ.NewStr("__check_blocked"):              InfoExtractor___check_blocked,
				λ.NewStr("__init__"):                     InfoExtractor___init__,
				λ.NewStr("_check_formats"):               InfoExtractor__check_formats,
				λ.NewStr("_download_json"):               InfoExtractor__download_json,
				λ.NewStr("_download_json_handle"):        InfoExtractor__download_json_handle,
				λ.NewStr("_download_smil"):               InfoExtractor__download_smil,
				λ.NewStr("_download_webpage"):            InfoExtractor__download_webpage,
				λ.NewStr("_download_webpage_handle"):     InfoExtractor__download_webpage_handle,
				λ.NewStr("_download_xml"):                InfoExtractor__download_xml,
				λ.NewStr("_download_xml_handle"):         InfoExtractor__download_xml_handle,
				λ.NewStr("_downloader"):                  InfoExtractor__downloader,
				λ.NewStr("_extract_f4m_formats"):         InfoExtractor__extract_f4m_formats,
				λ.NewStr("_extract_ism_formats"):         InfoExtractor__extract_ism_formats,
				λ.NewStr("_extract_m3u8_formats"):        InfoExtractor__extract_m3u8_formats,
				λ.NewStr("_extract_mpd_formats"):         InfoExtractor__extract_mpd_formats,
				λ.NewStr("_extract_smil_formats"):        InfoExtractor__extract_smil_formats,
				λ.NewStr("_family_friendly_search"):      InfoExtractor__family_friendly_search,
				λ.NewStr("_float"):                       InfoExtractor__float,
				λ.NewStr("_get_login_info"):              InfoExtractor__get_login_info,
				λ.NewStr("_get_netrc_login_info"):        InfoExtractor__get_netrc_login_info,
				λ.NewStr("_guess_encoding_from_content"): InfoExtractor__guess_encoding_from_content,
				λ.NewStr("_hidden_inputs"):               InfoExtractor__hidden_inputs,
				λ.NewStr("_html_search_meta"):            InfoExtractor__html_search_meta,
				λ.NewStr("_html_search_regex"):           InfoExtractor__html_search_regex,
				λ.NewStr("_initialize_geo_bypass"):       InfoExtractor__initialize_geo_bypass,
				λ.NewStr("_int"):                         InfoExtractor__int,
				λ.NewStr("_is_valid_url"):                InfoExtractor__is_valid_url,
				λ.NewStr("_json_ld"):                     InfoExtractor__json_ld,
				λ.NewStr("_live_title"):                  InfoExtractor__live_title,
				λ.NewStr("_match_id"):                    InfoExtractor__match_id,
				λ.NewStr("_media_rating_search"):         InfoExtractor__media_rating_search,
				λ.NewStr("_meta_regex"):                  InfoExtractor__meta_regex,
				λ.NewStr("_og_regexes"):                  InfoExtractor__og_regexes,
				λ.NewStr("_og_search_description"):       InfoExtractor__og_search_description,
				λ.NewStr("_og_search_property"):          InfoExtractor__og_search_property,
				λ.NewStr("_og_search_thumbnail"):         InfoExtractor__og_search_thumbnail,
				λ.NewStr("_og_search_title"):             InfoExtractor__og_search_title,
				λ.NewStr("_og_search_url"):               InfoExtractor__og_search_url,
				λ.NewStr("_og_search_video_url"):         InfoExtractor__og_search_video_url,
				λ.NewStr("_parse_f4m_formats"):           InfoExtractor__parse_f4m_formats,
				λ.NewStr("_parse_html5_media_entries"):   InfoExtractor__parse_html5_media_entries,
				λ.NewStr("_parse_ism_formats"):           InfoExtractor__parse_ism_formats,
				λ.NewStr("_parse_json"):                  InfoExtractor__parse_json,
				λ.NewStr("_parse_jwplayer_data"):         InfoExtractor__parse_jwplayer_data,
				λ.NewStr("_parse_jwplayer_formats"):      InfoExtractor__parse_jwplayer_formats,
				λ.NewStr("_parse_m3u8_formats"):          InfoExtractor__parse_m3u8_formats,
				λ.NewStr("_parse_mpd_formats"):           InfoExtractor__parse_mpd_formats,
				λ.NewStr("_parse_smil_formats"):          InfoExtractor__parse_smil_formats,
				λ.NewStr("_parse_smil_namespace"):        InfoExtractor__parse_smil_namespace,
				λ.NewStr("_parse_xml"):                   InfoExtractor__parse_xml,
				λ.NewStr("_proto_relative_url"):          InfoExtractor__proto_relative_url,
				λ.NewStr("_ready"):                       InfoExtractor__ready,
				λ.NewStr("_real_initialize"):             InfoExtractor__real_initialize,
				λ.NewStr("_remove_duplicate_formats"):    InfoExtractor__remove_duplicate_formats,
				λ.NewStr("_request_webpage"):             InfoExtractor__request_webpage,
				λ.NewStr("_rta_search"):                  InfoExtractor__rta_search,
				λ.NewStr("_search_json_ld"):              InfoExtractor__search_json_ld,
				λ.NewStr("_search_regex"):                InfoExtractor__search_regex,
				λ.NewStr("_set_cookie"):                  InfoExtractor__set_cookie,
				λ.NewStr("_sort_formats"):                InfoExtractor__sort_formats,
				λ.NewStr("_webpage_read_content"):        InfoExtractor__webpage_read_content,
				λ.NewStr("_x_forwarded_for_ip"):          InfoExtractor__x_forwarded_for_ip,
				λ.NewStr("_xpath_ns"):                    InfoExtractor__xpath_ns,
				λ.NewStr("extract"):                      InfoExtractor_extract,
				λ.NewStr("geo_verification_headers"):     InfoExtractor_geo_verification_headers,
				λ.NewStr("http_scheme"):                  InfoExtractor_http_scheme,
				λ.NewStr("ie_key"):                       InfoExtractor_ie_key,
				λ.NewStr("initialize"):                   InfoExtractor_initialize,
				λ.NewStr("playlist_result"):              InfoExtractor_playlist_result,
				λ.NewStr("report_download_webpage"):      InfoExtractor_report_download_webpage,
				λ.NewStr("report_extraction"):            InfoExtractor_report_extraction,
				λ.NewStr("report_warning"):               InfoExtractor_report_warning,
				λ.NewStr("set_downloader"):               InfoExtractor_set_downloader,
				λ.NewStr("suitable"):                     InfoExtractor_suitable,
				λ.NewStr("to_screen"):                    InfoExtractor_to_screen,
				λ.NewStr("url_result"):                   InfoExtractor_url_result,
				λ.NewStr("working"):                      InfoExtractor_working,
			})
		}())
		SearchInfoExtractor = λ.Cal(λ.TypeType, λ.NewStr("SearchInfoExtractor"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				SearchInfoExtractor__make_valid_url λ.Object
				SearchInfoExtractor_suitable        λ.Object
			)
			λ.NewStr("\n    Base class for paged search queries extractors.\n    They accept URLs in the format _SEARCH_KEY(|all|[0-9]):{query}\n    Instances should define _SEARCH_KEY and _MAX_RESULTS.\n    ")
			SearchInfoExtractor__make_valid_url = λ.NewFunction("_make_valid_url",
				[]λ.Param{
					{Name: "cls"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
					)
					return λ.Mod(λ.NewStr("%s(?P<prefix>|[1-9][0-9]*|all):(?P<query>[\\s\\S]+)"), λ.GetAttr(ϒcls, "_SEARCH_KEY", nil))
				})
			SearchInfoExtractor__make_valid_url = λ.Cal(λ.ClassMethodType, SearchInfoExtractor__make_valid_url)
			SearchInfoExtractor_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return λ.NewBool(λ.Cal(Ωre.ϒmatch, λ.Cal(λ.GetAttr(ϒcls, "_make_valid_url", nil)), ϒurl) != λ.None)
				})
			SearchInfoExtractor_suitable = λ.Cal(λ.ClassMethodType, SearchInfoExtractor_suitable)
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_make_valid_url"): SearchInfoExtractor__make_valid_url,
				λ.NewStr("suitable"):        SearchInfoExtractor_suitable,
			})
		}())
	})
}

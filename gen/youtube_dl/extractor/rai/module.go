// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * rai/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/rai.py
 */

package rai

import (
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError      λ.Object
	GeoRestrictedError  λ.Object
	InfoExtractor       λ.Object
	RaiBaseIE           λ.Object
	RaiIE               λ.Object
	RaiPlayIE           λ.Object
	RaiPlayLiveIE       λ.Object
	RaiPlayPlaylistIE   λ.Object
	ϒcompat_str         λ.Object
	ϒdetermine_ext      λ.Object
	ϒfind_xpath_attr    λ.Object
	ϒfix_xml_ampersands λ.Object
	ϒint_or_none        λ.Object
	ϒparse_duration     λ.Object
	ϒstrip_or_none      λ.Object
	ϒtry_get            λ.Object
	ϒunescapeHTML       λ.Object
	ϒunified_strdate    λ.Object
	ϒunified_timestamp  λ.Object
	ϒupdate_url_query   λ.Object
	ϒurljoin            λ.Object
	ϒxpath_text         λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_str = Ωcompat.ϒcompat_str
		ExtractorError = Ωutils.ExtractorError
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ϒfind_xpath_attr = Ωutils.ϒfind_xpath_attr
		ϒfix_xml_ampersands = Ωutils.ϒfix_xml_ampersands
		GeoRestrictedError = Ωutils.GeoRestrictedError
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒstrip_or_none = Ωutils.ϒstrip_or_none
		ϒtry_get = Ωutils.ϒtry_get
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		ϒupdate_url_query = Ωutils.ϒupdate_url_query
		ϒurljoin = Ωutils.ϒurljoin
		ϒxpath_text = Ωutils.ϒxpath_text
		RaiBaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("RaiBaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				RaiBaseIE__GEO_BYPASS            λ.Object
				RaiBaseIE__GEO_COUNTRIES         λ.Object
				RaiBaseIE__UUID_RE               λ.Object
				RaiBaseIE__extract_relinker_info λ.Object
				RaiBaseIE__extract_subtitles     λ.Object
			)
			RaiBaseIE__UUID_RE = λ.StrLiteral("[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}")
			RaiBaseIE__GEO_COUNTRIES = λ.NewList(λ.StrLiteral("IT"))
			RaiBaseIE__GEO_BYPASS = λ.False
			RaiBaseIE__extract_relinker_info = λ.NewFunction("_extract_relinker_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "relinker_url"},
					{Name: "video_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒbitrate       λ.Object
						ϒduration      λ.Object
						ϒext           λ.Object
						ϒformats       λ.Object
						ϒgeoprotection λ.Object
						ϒis_live       λ.Object
						ϒmanifest_url  λ.Object
						ϒmedia_url     λ.Object
						ϒplatform      λ.Object
						ϒrelinker      λ.Object
						ϒrelinker_url  = λargs[1]
						ϒself          = λargs[0]
						ϒurl_elem      λ.Object
						ϒvideo_id      = λargs[2]
						τmp0           λ.Object
						τmp1           λ.Object
					)
					if !λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("https?://"), ϒrelinker_url)) {
						return λ.DictLiteral(map[string]λ.Object{
							"formats": λ.NewList(λ.DictLiteral(map[string]λ.Object{
								"url": ϒrelinker_url,
							})),
						})
					}
					ϒformats = λ.NewList()
					ϒgeoprotection = λ.None
					ϒis_live = λ.None
					ϒduration = λ.None
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.StrLiteral("mon"),
						λ.StrLiteral("flash"),
						λ.StrLiteral("native"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒplatform = τmp1
						ϒrelinker = λ.Call(λ.GetAttr(ϒself, "_download_xml", nil), λ.NewArgs(
							ϒrelinker_url,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "note", Value: λ.Mod(λ.StrLiteral("Downloading XML metadata for platform %s"), ϒplatform)},
							{Name: "transform_source", Value: ϒfix_xml_ampersands},
							{Name: "query", Value: λ.DictLiteral(map[string]λ.Object{
								"output": λ.IntLiteral(45),
								"pl":     ϒplatform,
							})},
							{Name: "headers", Value: λ.Calm(ϒself, "geo_verification_headers")},
						})
						if !λ.IsTrue(ϒgeoprotection) {
							ϒgeoprotection = λ.Eq(λ.Call(ϒxpath_text, λ.NewArgs(
								ϒrelinker,
								λ.StrLiteral("./geoprotection"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}), λ.StrLiteral("Y"))
						}
						if !λ.IsTrue(ϒis_live) {
							ϒis_live = λ.Eq(λ.Call(ϒxpath_text, λ.NewArgs(
								ϒrelinker,
								λ.StrLiteral("./is_live"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}), λ.StrLiteral("Y"))
						}
						if !λ.IsTrue(ϒduration) {
							ϒduration = λ.Cal(ϒparse_duration, λ.Call(ϒxpath_text, λ.NewArgs(
								ϒrelinker,
								λ.StrLiteral("./duration"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						}
						ϒurl_elem = λ.Cal(ϒfind_xpath_attr, ϒrelinker, λ.StrLiteral("./url"), λ.StrLiteral("type"), λ.StrLiteral("content"))
						if ϒurl_elem == λ.None {
							continue
						}
						ϒmedia_url = λ.GetAttr(ϒurl_elem, "text", nil)
						if λ.IsTrue(λ.Eq(ϒmedia_url, λ.StrLiteral("http://download.rai.it/video_no_available.mp4"))) {
							continue
						}
						ϒext = λ.Cal(ϒdetermine_ext, ϒmedia_url)
						if λ.IsTrue(func() λ.Object {
							if λv := func() λ.Object {
								if λv := λ.Eq(ϒext, λ.StrLiteral("m3u8")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Ne(ϒplatform, λ.StrLiteral("mon"))
								}
							}(); λ.IsTrue(λv) {
								return λv
							} else {
								return func() λ.Object {
									if λv := λ.Eq(ϒext, λ.StrLiteral("f4m")); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Ne(ϒplatform, λ.StrLiteral("flash"))
									}
								}()
							}
						}()) {
							continue
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒext, λ.StrLiteral("m3u8")); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.NewBool(λ.Contains(ϒmedia_url, λ.StrLiteral("format=m3u8"))); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒplatform, λ.StrLiteral("mon"))
							}
						}()) {
							λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
								ϒmedia_url,
								ϒvideo_id,
								λ.StrLiteral("mp4"),
								λ.StrLiteral("m3u8_native"),
							), λ.KWArgs{
								{Name: "m3u8_id", Value: λ.StrLiteral("hls")},
								{Name: "fatal", Value: λ.False},
							}))
						} else {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(ϒext, λ.StrLiteral("f4m")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(ϒplatform, λ.StrLiteral("flash"))
								}
							}()) {
								ϒmanifest_url = λ.Cal(ϒupdate_url_query, λ.Calm(ϒmedia_url, "replace", λ.StrLiteral("manifest#live_hds.f4m"), λ.StrLiteral("manifest.f4m")), λ.DictLiteral(map[string]string{
									"hdcore": "3.7.0",
									"plugin": "aasp-3.7.0.39.44",
								}))
								λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
									ϒmanifest_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "f4m_id", Value: λ.StrLiteral("hds")},
									{Name: "fatal", Value: λ.False},
								}))
							} else {
								ϒbitrate = λ.Cal(ϒint_or_none, λ.Cal(ϒxpath_text, ϒrelinker, λ.StrLiteral("bitrate")))
								λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
									"url": ϒmedia_url,
									"tbr": func() λ.Object {
										if λ.IsTrue(λ.Gt(ϒbitrate, λ.IntLiteral(0))) {
											return ϒbitrate
										} else {
											return λ.None
										}
									}(),
									"format_id": func() λ.Object {
										if λ.IsTrue(λ.Gt(ϒbitrate, λ.IntLiteral(0))) {
											return λ.Mod(λ.StrLiteral("http-%d"), ϒbitrate)
										} else {
											return λ.StrLiteral("http")
										}
									}(),
								}))
							}
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(ϒformats)); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(ϒgeoprotection == λ.True)
						}
					}()) {
						λ.Call(λ.GetAttr(ϒself, "raise_geo_restricted", nil), nil, λ.KWArgs{
							{Name: "countries", Value: λ.GetAttr(ϒself, "_GEO_COUNTRIES", nil)},
						})
					}
					return λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒk   λ.Object
									ϒv   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
									τmp2 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(λ.DictLiteral(map[string]λ.Object{
									"is_live":  ϒis_live,
									"duration": ϒduration,
									"formats":  ϒformats,
								}), "items"))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒk = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒv = λ.GetItem(τmp2, λ.IntLiteral(1))
									if ϒv != λ.None {
										λgy.Yield(λ.NewTuple(
											ϒk,
											ϒv,
										))
									}
								}
								return λ.None
							})
						})))
				})
			RaiBaseIE__extract_subtitles = λ.NewFunction("_extract_subtitles",
				[]λ.Param{
					{Name: "url"},
					{Name: "subtitle_url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						SRT_EXT       λ.Object
						STL_EXT       λ.Object
						ϒsrt_url      λ.Object
						ϒsubtitle_url = λargs[1]
						ϒsubtitles    λ.Object
						ϒurl          = λargs[0]
					)
					ϒsubtitles = λ.DictLiteral(map[λ.Object]λ.Object{})
					if λ.IsTrue(func() λ.Object {
						if λv := ϒsubtitle_url; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.BuiltinIsInstance, ϒsubtitle_url, ϒcompat_str)
						}
					}()) {
						ϒsubtitle_url = λ.Cal(ϒurljoin, ϒurl, ϒsubtitle_url)
						STL_EXT = λ.StrLiteral(".stl")
						SRT_EXT = λ.StrLiteral(".srt")
						λ.SetItem(ϒsubtitles, λ.StrLiteral("it"), λ.NewList(λ.DictLiteral(map[string]λ.Object{
							"ext": λ.StrLiteral("stl"),
							"url": ϒsubtitle_url,
						})))
						if λ.IsTrue(λ.Calm(ϒsubtitle_url, "endswith", STL_EXT)) {
							ϒsrt_url = λ.Add(λ.GetItem(ϒsubtitle_url, λ.NewSlice(λ.None, λ.Neg(λ.Cal(λ.BuiltinLen, STL_EXT)), λ.None)), SRT_EXT)
							λ.Calm(λ.GetItem(ϒsubtitles, λ.StrLiteral("it")), "append", λ.DictLiteral(map[string]λ.Object{
								"ext": λ.StrLiteral("srt"),
								"url": ϒsrt_url,
							}))
						}
					}
					return ϒsubtitles
				})
			RaiBaseIE__extract_subtitles = λ.Cal(λ.StaticMethodType, RaiBaseIE__extract_subtitles)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_GEO_BYPASS":            RaiBaseIE__GEO_BYPASS,
				"_GEO_COUNTRIES":         RaiBaseIE__GEO_COUNTRIES,
				"_UUID_RE":               RaiBaseIE__UUID_RE,
				"_extract_relinker_info": RaiBaseIE__extract_relinker_info,
				"_extract_subtitles":     RaiBaseIE__extract_subtitles,
			})
		}())
		RaiPlayIE = λ.Cal(λ.TypeType, λ.StrLiteral("RaiPlayIE"), λ.NewTuple(RaiBaseIE), func() λ.Dict {
			var (
				RaiPlayIE__VALID_URL λ.Object
			)
			RaiPlayIE__VALID_URL = λ.Mod(λ.StrLiteral("(?P<url>https?://(?:www\\.)?raiplay\\.it/.+?-(?P<id>%s)\\.html)"), λ.GetAttr(RaiBaseIE, "_UUID_RE", nil))
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": RaiPlayIE__VALID_URL,
			})
		}())
		RaiPlayLiveIE = λ.Cal(λ.TypeType, λ.StrLiteral("RaiPlayLiveIE"), λ.NewTuple(RaiBaseIE), func() λ.Dict {
			var (
				RaiPlayLiveIE__VALID_URL λ.Object
			)
			RaiPlayLiveIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?raiplay\\.it/dirette/(?P<id>[^/?#&]+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": RaiPlayLiveIE__VALID_URL,
			})
		}())
		RaiPlayPlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("RaiPlayPlaylistIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				RaiPlayPlaylistIE__VALID_URL λ.Object
			)
			RaiPlayPlaylistIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?raiplay\\.it/programmi/(?P<id>[^/?#&]+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": RaiPlayPlaylistIE__VALID_URL,
			})
		}())
		RaiIE = λ.Cal(λ.TypeType, λ.StrLiteral("RaiIE"), λ.NewTuple(RaiBaseIE), func() λ.Dict {
			var (
				RaiIE__VALID_URL               λ.Object
				RaiIE__extract_from_content_id λ.Object
				RaiIE__real_extract            λ.Object
			)
			RaiIE__VALID_URL = λ.Mod(λ.StrLiteral("https?://[^/]+\\.(?:rai\\.(?:it|tv)|rainews\\.it)/.+?-(?P<id>%s)(?:-.+?)?\\.html"), λ.GetAttr(RaiBaseIE, "_UUID_RE", nil))
			RaiIE__extract_from_content_id = λ.NewFunction("_extract_from_content_id",
				[]λ.Param{
					{Name: "self"},
					{Name: "content_id"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent_id    = λargs[1]
						ϒimage_type    λ.Object
						ϒinfo          λ.Object
						ϒmedia         λ.Object
						ϒmedia_type    λ.Object
						ϒrelinker_info λ.Object
						ϒself          = λargs[0]
						ϒsubtitles     λ.Object
						ϒthumbnail_url λ.Object
						ϒthumbnails    λ.Object
						ϒtitle         λ.Object
						ϒurl           = λargs[2]
						τmp0           λ.Object
						τmp1           λ.Object
					)
					ϒmedia = λ.Calm(ϒself, "_download_json", λ.Mod(λ.StrLiteral("http://www.rai.tv/dl/RaiTV/programmi/media/ContentItem-%s.html?json"), ϒcontent_id), ϒcontent_id, λ.StrLiteral("Downloading video JSON"))
					ϒtitle = λ.Calm(λ.GetItem(ϒmedia, λ.StrLiteral("name")), "strip")
					ϒmedia_type = λ.GetItem(ϒmedia, λ.StrLiteral("type"))
					if λ.Contains(ϒmedia_type, λ.StrLiteral("Audio")) {
						ϒrelinker_info = λ.DictLiteral(map[string]λ.Object{
							"formats": λ.NewList(λ.DictLiteral(map[string]λ.Object{
								"format_id": λ.Calm(ϒmedia, "get", λ.StrLiteral("formatoAudio")),
								"url":       λ.GetItem(ϒmedia, λ.StrLiteral("audioUrl")),
								"ext":       λ.Calm(ϒmedia, "get", λ.StrLiteral("formatoAudio")),
							})),
						})
					} else {
						if λ.Contains(ϒmedia_type, λ.StrLiteral("Video")) {
							ϒrelinker_info = λ.Calm(ϒself, "_extract_relinker_info", λ.GetItem(ϒmedia, λ.StrLiteral("mediaUri")), ϒcontent_id)
						} else {
							panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("not a media file"))))
						}
					}
					λ.Calm(ϒself, "_sort_formats", λ.GetItem(ϒrelinker_info, λ.StrLiteral("formats")))
					ϒthumbnails = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.StrLiteral("image"),
						λ.StrLiteral("image_medium"),
						λ.StrLiteral("image_300"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒimage_type = τmp1
						ϒthumbnail_url = λ.Calm(ϒmedia, "get", ϒimage_type)
						if λ.IsTrue(ϒthumbnail_url) {
							λ.Calm(ϒthumbnails, "append", λ.DictLiteral(map[string]λ.Object{
								"url": λ.Cal(Ωparse.ϒurljoin, ϒurl, ϒthumbnail_url),
							}))
						}
					}
					ϒsubtitles = λ.Calm(ϒself, "_extract_subtitles", ϒurl, λ.Calm(ϒmedia, "get", λ.StrLiteral("subtitlesUrl")))
					ϒinfo = λ.DictLiteral(map[string]λ.Object{
						"id":          ϒcontent_id,
						"title":       ϒtitle,
						"description": λ.Cal(ϒstrip_or_none, λ.Calm(ϒmedia, "get", λ.StrLiteral("desc"))),
						"thumbnails":  ϒthumbnails,
						"uploader":    λ.Calm(ϒmedia, "get", λ.StrLiteral("author")),
						"upload_date": λ.Cal(ϒunified_strdate, λ.Calm(ϒmedia, "get", λ.StrLiteral("date"))),
						"duration":    λ.Cal(ϒparse_duration, λ.Calm(ϒmedia, "get", λ.StrLiteral("length"))),
						"subtitles":   ϒsubtitles,
					})
					λ.Calm(ϒinfo, "update", ϒrelinker_info)
					return ϒinfo
				})
			RaiIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent_item_id  λ.Object
						ϒcontent_item_ids λ.Object
						ϒcontent_item_url λ.Object
						ϒinfo             λ.Object
						ϒrelinker_info    λ.Object
						ϒrelinker_url     λ.Object
						ϒself             = λargs[0]
						ϒtitle            λ.Object
						ϒurl              = λargs[1]
						ϒvideo_id         λ.Object
						ϒwebpage          λ.Object
						τmp0              λ.Object
						τmp1              λ.Object
						τmp2              λ.Object
						τmp3              λ.Object
					)
					ϒvideo_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒwebpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒvideo_id)
					ϒcontent_item_id = λ.None
					ϒcontent_item_url = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
						λ.NewTuple(
							λ.StrLiteral("og:url"),
							λ.StrLiteral("og:video"),
							λ.StrLiteral("og:video:secure_url"),
							λ.StrLiteral("twitter:url"),
							λ.StrLiteral("twitter:player"),
							λ.StrLiteral("jsonlink"),
						),
						ϒwebpage,
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒcontent_item_url) {
						ϒcontent_item_id = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.Mod(λ.StrLiteral("ContentItem-(%s)"), λ.GetAttr(ϒself, "_UUID_RE", nil)),
							ϒcontent_item_url,
							λ.StrLiteral("content item id"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
					}
					if !λ.IsTrue(ϒcontent_item_id) {
						ϒcontent_item_id = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.Mod(λ.StrLiteral("(?x)\n                    (?:\n                        (?:initEdizione|drawMediaRaiTV)\\(|\n                        <(?:[^>]+\\bdata-id|var\\s+uniquename)=\n                    )\n                    ([\"\\'])\n                    (?:(?!\\1).)*\\bContentItem-(?P<id>%s)\n                "), λ.GetAttr(ϒself, "_UUID_RE", nil)),
							ϒwebpage,
							λ.StrLiteral("content item id"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
							{Name: "group", Value: λ.StrLiteral("id")},
						})
					}
					ϒcontent_item_ids = λ.Cal(λ.SetType)
					if λ.IsTrue(ϒcontent_item_id) {
						λ.Calm(ϒcontent_item_ids, "add", ϒcontent_item_id)
					}
					if !λ.Contains(ϒcontent_item_ids, ϒvideo_id) {
						λ.Calm(ϒcontent_item_ids, "add", ϒvideo_id)
					}
					τmp0 = λ.Cal(λ.BuiltinIter, ϒcontent_item_ids)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒcontent_item_id = τmp1
						τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{GeoRestrictedError, func(λex λ.BaseException) {
									panic(λ.Raise(λex))
								}},
								&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
									// pass
								}},
							)
							λexit, λret = λ.BlockExitReturn, λ.Calm(ϒself, "_extract_from_content_id", ϒcontent_item_id, ϒurl)
							return
							return λ.BlockExitNormally, nil
						}()
						if τmp2 == λ.BlockExitReturn {
							return τmp3
						}
					}
					ϒrelinker_url = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?x)\n                (?:\n                    var\\s+videoURL|\n                    mediaInfo\\.mediaUri\n                )\\s*=\\s*\n                ([\\'\"])\n                (?P<url>\n                    (?:https?:)?\n                    //mediapolis(?:vod)?\\.rai\\.it/relinker/relinkerServlet\\.htm\\?\n                    (?:(?!\\1).)*\\bcont=(?:(?!\\1).)+)\\1\n            "),
						ϒwebpage,
						λ.StrLiteral("relinker URL"),
					), λ.KWArgs{
						{Name: "group", Value: λ.StrLiteral("url")},
					})
					ϒrelinker_info = λ.Calm(ϒself, "_extract_relinker_info", λ.Cal(ϒurljoin, ϒurl, ϒrelinker_url), ϒvideo_id)
					λ.Calm(ϒself, "_sort_formats", λ.GetItem(ϒrelinker_info, λ.StrLiteral("formats")))
					ϒtitle = func() λ.Object {
						if λv := λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("var\\s+videoTitolo\\s*=\\s*([\\'\"])(?P<title>[^\\'\"]+)\\1"),
							ϒwebpage,
							λ.StrLiteral("title"),
						), λ.KWArgs{
							{Name: "group", Value: λ.StrLiteral("title")},
							{Name: "default", Value: λ.None},
						}); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(ϒself, "_og_search_title", ϒwebpage)
						}
					}()
					ϒinfo = λ.DictLiteral(map[string]λ.Object{
						"id":    ϒvideo_id,
						"title": ϒtitle,
					})
					λ.Calm(ϒinfo, "update", ϒrelinker_info)
					return ϒinfo
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL":               RaiIE__VALID_URL,
				"_extract_from_content_id": RaiIE__extract_from_content_id,
				"_real_extract":            RaiIE__real_extract,
			})
		}())
	})
}

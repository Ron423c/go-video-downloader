// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * flickr/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/flickr.py
 */

package flickr

import (
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError                 λ.Object
	FlickrIE                       λ.Object
	InfoExtractor                  λ.Object
	ϒcompat_str                    λ.Object
	ϒcompat_urllib_parse_urlencode λ.Object
	ϒint_or_none                   λ.Object
	ϒqualities                     λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒcompat_urllib_parse_urlencode = Ωcompat.ϒcompat_urllib_parse_urlencode
		ExtractorError = Ωutils.ExtractorError
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒqualities = Ωutils.ϒqualities
		FlickrIE = λ.Cal(λ.TypeType, λ.NewStr("FlickrIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				FlickrIE__API_BASE_URL λ.Object
				FlickrIE__LICENSES     λ.Object
				FlickrIE__TEST         λ.Object
				FlickrIE__VALID_URL    λ.Object
				FlickrIE__call_api     λ.Object
				FlickrIE__real_extract λ.Object
			)
			FlickrIE__VALID_URL = λ.NewStr("https?://(?:www\\.|secure\\.)?flickr\\.com/photos/[\\w\\-_@]+/(?P<id>\\d+)")
			FlickrIE__TEST = λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("url"): λ.NewStr("http://www.flickr.com/photos/forestwander-nature-pictures/5645318632/in/photostream/"),
				λ.NewStr("md5"): λ.NewStr("164fe3fa6c22e18d448d4d5af2330f31"),
				λ.NewStr("info_dict"): λ.NewDictWithTable(map[λ.Object]λ.Object{
					λ.NewStr("id"):            λ.NewStr("5645318632"),
					λ.NewStr("ext"):           λ.NewStr("mpg"),
					λ.NewStr("description"):   λ.NewStr("Waterfalls in the Springtime at Dark Hollow Waterfalls. These are located just off of Skyline Drive in Virginia. They are only about 6/10 of a mile hike but it is a pretty steep hill and a good climb back up."),
					λ.NewStr("title"):         λ.NewStr("Dark Hollow Waterfalls"),
					λ.NewStr("duration"):      λ.NewInt(19),
					λ.NewStr("timestamp"):     λ.NewInt(1303528740),
					λ.NewStr("upload_date"):   λ.NewStr("20110423"),
					λ.NewStr("uploader_id"):   λ.NewStr("10922353@N03"),
					λ.NewStr("uploader"):      λ.NewStr("Forest Wander"),
					λ.NewStr("uploader_url"):  λ.NewStr("https://www.flickr.com/photos/forestwander-nature-pictures/"),
					λ.NewStr("comment_count"): λ.IntType,
					λ.NewStr("view_count"):    λ.IntType,
					λ.NewStr("tags"):          λ.ListType,
					λ.NewStr("license"):       λ.NewStr("Attribution-ShareAlike"),
				}),
			})
			FlickrIE__API_BASE_URL = λ.NewStr("https://api.flickr.com/services/rest?")
			FlickrIE__LICENSES = λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("0"):  λ.NewStr("All Rights Reserved"),
				λ.NewStr("1"):  λ.NewStr("Attribution-NonCommercial-ShareAlike"),
				λ.NewStr("2"):  λ.NewStr("Attribution-NonCommercial"),
				λ.NewStr("3"):  λ.NewStr("Attribution-NonCommercial-NoDerivs"),
				λ.NewStr("4"):  λ.NewStr("Attribution"),
				λ.NewStr("5"):  λ.NewStr("Attribution-ShareAlike"),
				λ.NewStr("6"):  λ.NewStr("Attribution-NoDerivs"),
				λ.NewStr("7"):  λ.NewStr("No known copyright restrictions"),
				λ.NewStr("8"):  λ.NewStr("United States government work"),
				λ.NewStr("9"):  λ.NewStr("Public Domain Dedication (CC0)"),
				λ.NewStr("10"): λ.NewStr("Public Domain Work"),
			})
			FlickrIE__call_api = λ.NewFunction("_call_api",
				[]λ.Param{
					{Name: "self"},
					{Name: "method"},
					{Name: "video_id"},
					{Name: "api_key"},
					{Name: "note"},
					{Name: "secret", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒapi_key  = λargs[3]
						ϒdata     λ.Object
						ϒmethod   = λargs[1]
						ϒnote     = λargs[4]
						ϒquery    λ.Object
						ϒsecret   = λargs[5]
						ϒself     = λargs[0]
						ϒvideo_id = λargs[2]
					)
					ϒquery = λ.NewDictWithTable(map[λ.Object]λ.Object{
						λ.NewStr("photo_id"):       ϒvideo_id,
						λ.NewStr("method"):         λ.Mod(λ.NewStr("flickr.%s"), ϒmethod),
						λ.NewStr("api_key"):        ϒapi_key,
						λ.NewStr("format"):         λ.NewStr("json"),
						λ.NewStr("nojsoncallback"): λ.NewInt(1),
					})
					if λ.IsTrue(ϒsecret) {
						λ.SetItem(ϒquery, λ.NewStr("secret"), ϒsecret)
					}
					ϒdata = λ.Cal(λ.GetAttr(ϒself, "_download_json", nil), λ.Add(λ.GetAttr(ϒself, "_API_BASE_URL", nil), λ.Cal(ϒcompat_urllib_parse_urlencode, ϒquery)), ϒvideo_id, ϒnote)
					if λ.IsTrue(λ.Ne(λ.GetItem(ϒdata, λ.NewStr("stat")), λ.NewStr("ok"))) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.GetItem(ϒdata, λ.NewStr("message")))))
					}
					return ϒdata
				})
			FlickrIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒapi_key       λ.Object
						ϒformats       λ.Object
						ϒowner         λ.Object
						ϒpreference    λ.Object
						ϒself          = λargs[0]
						ϒstream        λ.Object
						ϒstream_type   λ.Object
						ϒstreams       λ.Object
						ϒuploader_id   λ.Object
						ϒuploader_path λ.Object
						ϒuploader_url  λ.Object
						ϒurl           = λargs[1]
						ϒvideo_id      λ.Object
						ϒvideo_info    λ.Object
						τmp0           λ.Object
						τmp1           λ.Object
					)
					ϒvideo_id = λ.Cal(λ.GetAttr(ϒself, "_match_id", nil), ϒurl)
					ϒapi_key = λ.GetItem(λ.Cal(λ.GetAttr(ϒself, "_download_json", nil), λ.NewStr("https://www.flickr.com/hermes_error_beacon.gne"), ϒvideo_id, λ.NewStr("Downloading api key")), λ.NewStr("site_key"))
					ϒvideo_info = λ.GetItem(λ.Cal(λ.GetAttr(ϒself, "_call_api", nil), λ.NewStr("photos.getInfo"), ϒvideo_id, ϒapi_key, λ.NewStr("Downloading video info")), λ.NewStr("photo"))
					if λ.IsTrue(λ.Eq(λ.GetItem(ϒvideo_info, λ.NewStr("media")), λ.NewStr("video"))) {
						ϒstreams = λ.GetItem(λ.Cal(λ.GetAttr(ϒself, "_call_api", nil), λ.NewStr("video.getStreamInfo"), ϒvideo_id, ϒapi_key, λ.NewStr("Downloading streams info"), λ.GetItem(ϒvideo_info, λ.NewStr("secret"))), λ.NewStr("streams"))
						ϒpreference = λ.Cal(ϒqualities, λ.NewList(
							λ.NewStr("288p"),
							λ.NewStr("iphone_wifi"),
							λ.NewStr("100"),
							λ.NewStr("300"),
							λ.NewStr("700"),
							λ.NewStr("360p"),
							λ.NewStr("appletv"),
							λ.NewStr("720p"),
							λ.NewStr("1080p"),
							λ.NewStr("orig"),
						))
						ϒformats = λ.NewList()
						τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒstreams, λ.NewStr("stream")))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒstream = τmp1
							ϒstream_type = λ.Cal(ϒcompat_str, λ.Cal(λ.GetAttr(ϒstream, "get", nil), λ.NewStr("type")))
							λ.Cal(λ.GetAttr(ϒformats, "append", nil), λ.NewDictWithTable(map[λ.Object]λ.Object{
								λ.NewStr("format_id"):  ϒstream_type,
								λ.NewStr("url"):        λ.GetItem(ϒstream, λ.NewStr("_content")),
								λ.NewStr("preference"): λ.Cal(ϒpreference, ϒstream_type),
							}))
						}
						λ.Cal(λ.GetAttr(ϒself, "_sort_formats", nil), ϒformats)
						ϒowner = λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("owner"), λ.NewDictWithTable(map[λ.Object]λ.Object{}))
						ϒuploader_id = λ.Cal(λ.GetAttr(ϒowner, "get", nil), λ.NewStr("nsid"))
						ϒuploader_path = func() λ.Object {
							if λv := λ.Cal(λ.GetAttr(ϒowner, "get", nil), λ.NewStr("path_alias")); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒuploader_id
							}
						}()
						ϒuploader_url = func() λ.Object {
							if λ.IsTrue(ϒuploader_path) {
								return λ.Mod(λ.NewStr("https://www.flickr.com/photos/%s/"), ϒuploader_path)
							} else {
								return λ.None
							}
						}()
						return λ.NewDictWithTable(map[λ.Object]λ.Object{
							λ.NewStr("id"):            ϒvideo_id,
							λ.NewStr("title"):         λ.GetItem(λ.GetItem(ϒvideo_info, λ.NewStr("title")), λ.NewStr("_content")),
							λ.NewStr("description"):   λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("description"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), "get", nil), λ.NewStr("_content")),
							λ.NewStr("formats"):       ϒformats,
							λ.NewStr("timestamp"):     λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("dateuploaded"))),
							λ.NewStr("duration"):      λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("video"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), "get", nil), λ.NewStr("duration"))),
							λ.NewStr("uploader_id"):   ϒuploader_id,
							λ.NewStr("uploader"):      λ.Cal(λ.GetAttr(ϒowner, "get", nil), λ.NewStr("realname")),
							λ.NewStr("uploader_url"):  ϒuploader_url,
							λ.NewStr("comment_count"): λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("comments"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), "get", nil), λ.NewStr("_content"))),
							λ.NewStr("view_count"):    λ.Cal(ϒint_or_none, λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("views"))),
							λ.NewStr("tags"): λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgen λ.Generator) λ.Object {
										var (
											ϒtag λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.GetAttr(λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("tags"), λ.NewDictWithTable(map[λ.Object]λ.Object{})), "get", nil), λ.NewStr("tag"), λ.NewList()))
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒtag = τmp1
											λgen.Yield(λ.Cal(λ.GetAttr(ϒtag, "get", nil), λ.NewStr("_content")))
										}
										return λ.None
									})
								}))),
							λ.NewStr("license"): λ.Cal(λ.GetAttr(λ.GetAttr(ϒself, "_LICENSES", nil), "get", nil), λ.Cal(λ.GetAttr(ϒvideo_info, "get", nil), λ.NewStr("license"))),
						})
					} else {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.NewStr("not a video")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					return λ.None
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("_API_BASE_URL"): FlickrIE__API_BASE_URL,
				λ.NewStr("_LICENSES"):     FlickrIE__LICENSES,
				λ.NewStr("_TEST"):         FlickrIE__TEST,
				λ.NewStr("_VALID_URL"):    FlickrIE__VALID_URL,
				λ.NewStr("_call_api"):     FlickrIE__call_api,
				λ.NewStr("_real_extract"): FlickrIE__real_extract,
			})
		}())
	})
}
